<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-10-17T12:47:48.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 集群同步</title>
    <link href="http://www.iocoder.cn/Eureka/server-cluster/"/>
    <id>http://www.iocoder.cn/Eureka/server-cluster/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2017-10-17T12:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/server-cluster/">http://www.iocoder.cn/Eureka/server-cluster/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2. 集群节点初始化与更新</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.1 集群节点启动</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.2 更新集群节点信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.3 集群节点</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">3. 获取初始注册信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4. 同步注册信息</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.1 同步操作类型</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.2 发起 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.3 接收 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.4 处理 Eureka-Server 同步结果</a></li></ul></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 集群同步注册信息</strong>。</p><p>Eureka-Server 集群如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/01.png" alt=""></p><ul><li>Eureka-Server 集群不区分<strong>主从节点</strong>或者 <strong>Primary &amp; Secondary 节点</strong>，所有节点<strong>相同角色( 也就是没有角色 )，完全对等</strong>。</li><li>Eureka-Client 可以向<strong>任意</strong> Eureka-Client 发起任意<strong>读写</strong>操作，Eureka-Server 将操作复制到另外的 Eureka-Server 以达到<strong>最终一致性</strong>。注意，Eureka-Server 是选择了 AP 的组件。</li></ul><p>Eureka-Server 可以使用直接配置所有节点的服务地址，或者基于 DNS 配置。推荐阅读：<a href="http://blog.didispace.com/springcloud6/?from=http://www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud构建微服务架构（六）高可用服务注册中心》</a> 。</p><p>本文主要类在 <code>com.netflix.eureka.cluster</code> 包下。</p><p>OK，让我们开始愉快的遨游在代码的海洋。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><p>ps ：<strong>注意</strong>，本文提到的<strong>同步</strong>，准确来说是<strong>复制( Replication )</strong>。</p><h1 id="2-集群节点初始化与更新"><a href="#2-集群节点初始化与更新" class="headerlink" title="2. 集群节点初始化与更新"></a>2. 集群节点初始化与更新</h1><p><code>com.netflix.eureka.cluster.PeerEurekaNodes</code> ，Eureka-Server 集群节点集合 。构造方法如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PeerEurekaNodes.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 编解码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 服务地址数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeerEurekaNodes</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            PeerAwareInstanceRegistry registry,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            ApplicationInfoManager applicationInfoManager)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.registry = registry;</div><div class="line">        <span class="keyword">this</span>.serverConfig = serverConfig;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.serverCodecs = serverCodecs;</div><div class="line">        <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>peerEurekaNodes</code>, <code>peerEurekaNodeUrls</code>, <code>taskExecutor</code> 属性，在构造方法中<strong>未设置和初始化</strong>，而是在 <code>PeerEurekaNodes#start()</code> 方法，设置和初始化，下文我们会解析这个方法。</li><li>Eureka-Server 在初始化时，调用 <code>EurekaBootStrap#getPeerEurekaNodes(...)</code> 方法，创建 PeerEurekaNodes ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L245" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的实现。</li></ul><h2 id="2-1-集群节点启动"><a href="#2-1-集群节点启动" class="headerlink" title="2.1 集群节点启动"></a>2.1 集群节点启动</h2><p>调用 <code>PeerEurekaNodes#start()</code> 方法，集群节点启动，主要完成两个逻辑：</p><ul><li>初始化集群节点信息</li><li>初始化固定周期( 默认：10 分钟，可配置 )更新集群节点信息的任务</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 创建 定时任务服务</span></div><div class="line"> <span class="number">3</span>:     taskExecutor = Executors.newSingleThreadScheduledExecutor(</div><div class="line"> <span class="number">4</span>:             <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line"> <span class="number">5</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">6</span>:                 <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:                     Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</div><div class="line"> <span class="number">8</span>:                     thread.setDaemon(<span class="keyword">true</span>);</div><div class="line"> <span class="number">9</span>:                     <span class="keyword">return</span> thread;</div><div class="line"><span class="number">10</span>:                 &#125;</div><div class="line"><span class="number">11</span>:             &#125;</div><div class="line"><span class="number">12</span>:     );</div><div class="line"><span class="number">13</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="comment">// 初始化 集群节点信息</span></div><div class="line"><span class="number">15</span>:         updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">16</span>:         <span class="comment">// 初始化 初始化固定周期更新集群节点信息的任务</span></div><div class="line"><span class="number">17</span>:         Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="number">18</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">19</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">20</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                     updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">22</span>:                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:                     logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</div><div class="line"><span class="number">24</span>:                 &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:         &#125;;</div><div class="line"><span class="number">28</span>:         taskExecutor.scheduleWithFixedDelay(</div><div class="line"><span class="number">29</span>:                 peersUpdateTask,</div><div class="line"><span class="number">30</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">31</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">32</span>:                 TimeUnit.MILLISECONDS</div><div class="line"><span class="number">33</span>:         );</div><div class="line"><span class="number">34</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">35</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>:     <span class="comment">// 打印 集群节点信息</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</div><div class="line"><span class="number">40</span>:     &#125;</div><div class="line"><span class="number">41</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 15 行 &amp;&amp; 第 21 行 ：调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息。</li></ul><h2 id="2-2-更新集群节点信息"><a href="#2-2-更新集群节点信息" class="headerlink" title="2.2 更新集群节点信息"></a>2.2 更新集群节点信息</h2><p>调用 <code>#resolvePeerUrls()</code> 方法，获得 Eureka-Server 集群服务地址数组，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">resolvePeerUrls</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 Eureka-Server 集群服务地址数组</span></div><div class="line"> <span class="number">3</span>:     InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"> <span class="number">4</span>:     String zone = InstanceInfo.getZone(clientConfig.getAvailabilityZones(clientConfig.getRegion()), myInfo);</div><div class="line"> <span class="number">5</span>:     List&lt;String&gt; replicaUrls = EndpointUtils.getDiscoveryServiceUrls(clientConfig, zone, <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(myInfo));</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 移除自己（避免向自己同步）</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line"> <span class="number">9</span>:     <span class="keyword">while</span> (idx &lt; replicaUrls.size()) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (isThisMyUrl(replicaUrls.get(idx))) &#123;</div><div class="line"><span class="number">11</span>:             replicaUrls.remove(idx);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             idx++;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> replicaUrls;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 5 行 ：获得 Eureka-Server 集群服务地址数组。<code>EndpointUtils#getDiscoveryServiceUrls(...)</code> 方法，逻辑与 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》「3.4 ConfigClusterResolver」</a> 基本类似。EndpointUtils 正在逐步，猜测未来这里会替换。</li><li>第 7 至 15 行 ：移除自身节点，避免向自己同步。</li></ul><hr><p>调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息，主要完成两部分逻辑：</p><ul><li>添加新增的集群节点</li><li>关闭删除的集群节点</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</div><div class="line"> <span class="number">3</span>:         logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</div><div class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">5</span>:     &#125;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 计算 新增的集群节点地址</span></div><div class="line"> <span class="number">8</span>:     Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</div><div class="line"> <span class="number">9</span>:     toShutdown.removeAll(newPeerUrls);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 计算 删除的集群节点地址</span></div><div class="line"><span class="number">12</span>:     Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">13</span>:     toAdd.removeAll(peerEurekaNodeUrls);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span>;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 关闭删除的集群节点</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Remove peers no long available</span></div><div class="line"><span class="number">21</span>:     List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</div><div class="line"><span class="number">23</span>:         logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</div><div class="line"><span class="number">24</span>:         <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="number">25</span>:         <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</div><div class="line"><span class="number">26</span>:             PeerEurekaNode eurekaNode = newNodeList.get(i);</div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</div><div class="line"><span class="number">28</span>:                 newNodeList.remove(i);</div><div class="line"><span class="number">29</span>:                 eurekaNode.shutDown(); <span class="comment">// 关闭</span></div><div class="line"><span class="number">30</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">31</span>:                 i++;</div><div class="line"><span class="number">32</span>:             &#125;</div><div class="line"><span class="number">33</span>:         &#125;</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">// 添加新增的集群节点</span></div><div class="line"><span class="number">37</span>:     <span class="comment">// Add new peers</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</div><div class="line"><span class="number">41</span>:             newNodeList.add(createPeerEurekaNode(peerUrl));</div><div class="line"><span class="number">42</span>:         &#125;</div><div class="line"><span class="number">43</span>:     &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">// 赋值</span></div><div class="line"><span class="number">46</span>:     <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</div><div class="line"><span class="number">47</span>:     <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">48</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 9 行 ：<strong>计算</strong>新增的集群节点地址。</li><li>第 11 至 13 行 ：<strong>计算</strong>删除的集群节点地址。</li><li>第 19 至 34 行 ：<strong>关闭</strong>删除的集群节点。</li><li><p>第 36 至 43 行 ：<strong>添加</strong>新增的集群节点。调用 <code>#createPeerEurekaNode(peerUrl)</code> 方法，创建集群节点，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</div><div class="line"><span class="number">3</span>:     String targetHost = hostFromUrl(peerEurekaNodeUrl);</div><div class="line"><span class="number">4</span>:     <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">5</span>:         targetHost = <span class="string">"host"</span>;</div><div class="line"><span class="number">6</span>:     &#125;</div><div class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</div><div class="line"><span class="number">8</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：创建 Eureka-Server 集群通信客户端，在 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》「4.2 JerseyReplicationClient」</a> 有详细解析。</li><li>第 7 行 ：创建 PeerEurekaNode ，在 <a href="#">「2.3 PeerEurekaNode」</a> 有详细解析。</li></ul></li></ul><h2 id="2-3-集群节点"><a href="#2-3-集群节点" class="headerlink" title="2.3 集群节点"></a>2.3 集群节点</h2><p><code>com.netflix.eureka.cluster.PeerEurekaNode</code> ，单个集群节点。</p><p>点击 <a href="https://github.com/YunaiV/eureka/blob/fcc9027a197783a23e7cb72ad0f617b7dc63d221/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看<strong>构造方法</strong></p><ul><li>第 129 行 ：创建 ReplicationTaskProcessor 。在 <a href="#">「4.1.2 同步操作任务处理器」</a> 详细解析</li><li>第 131 至 140 行 ：创建<strong>批量任务</strong>分发器，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》</a> 有详细解析。</li><li>第 142 至 151 行 ：创建<strong>单任务</strong>分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态。暂时跳过。</li></ul><h1 id="3-获取初始注册信息"><a href="#3-获取初始注册信息" class="headerlink" title="3. 获取初始注册信息"></a>3. 获取初始注册信息</h1><p>Eureka-Server 启动时，调用 <code>PeerAwareInstanceRegistryImpl#syncUp()</code> 方法，从集群的一个 Eureka-Server 节点获取<strong>初始</strong>注册信息，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// Copy entire entry from neighboring DS node</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 未读取到注册信息，sleep 等待</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">10</span>:                 Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</div><div class="line"><span class="number">11</span>:             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Interrupted during registry transfer.."</span>);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="comment">// 获取注册信息</span></div><div class="line"><span class="number">18</span>:         Applications apps = eurekaClient.getApplications();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>:                     <span class="keyword">if</span> (isRegisterable(instance)) &#123; <span class="comment">// 判断是否能够注册</span></div><div class="line"><span class="number">23</span>:                         register(instance, instance.getLeaseInfo().getDurationInSecs(), <span class="keyword">true</span>); <span class="comment">// 注册</span></div><div class="line"><span class="number">24</span>:                         count++;</div><div class="line"><span class="number">25</span>:                     &#125;</div><div class="line"><span class="number">26</span>:                 &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">27</span>:                     logger.error(<span class="string">"During DS init copy"</span>, t);</div><div class="line"><span class="number">28</span>:                 &#125;</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>:     <span class="keyword">return</span> count;</div><div class="line"><span class="number">33</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 15 行 ：未获取到注册信息，<code>sleep</code> 等待再次重试。</li><li>第 17 至 30 行 ：获取注册信息，若获取到，注册到自身节点。<ul><li>第 22 行 ：判断应用实例是否能够注册到自身节点。主要用于亚马逊 AWS 环境下的判断，若非部署在亚马逊里，都返回 <code>true</code> 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java#L593" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li>第 23 行 ：调用 <code>#register()</code> 方法，注册应用实例到自身节点。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析。</li></ul></li></ul><hr><p>若调用 <code>#syncUp()</code> 方法，未获取到应用实例，则 Eureka-Server 会有一段时间( 默认：5 分钟，可配 )不允许被 Eureka-Client 获取注册信息，避免影响 Eureka-Client 。</p><ul><li><p>标记 Eureka-Server 启动时，未获取到应用实例，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> peerInstancesTransferEmptyOnStartup = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>判断 Eureka-Server 是否允许被 Eureka-Client 获取注册信息，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup) &#123;</div><div class="line">           <span class="comment">// 设置启动时间</span></div><div class="line">           <span class="keyword">this</span>.startupTime = System.currentTimeMillis();</div><div class="line">           <span class="keyword">if</span> (!(System.currentTimeMillis() &gt; <span class="keyword">this</span>.startupTime + serverConfig.getWaitTimeInMsWhenSyncEmpty())) &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// ... 省略其他代码</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    ``` </div><div class="line"></div><div class="line"># 4. 同步注册信息</div><div class="line"></div><div class="line">Eureka-Server 集群同步注册信息如下图：</div><div class="line"></div><div class="line">![](http:<span class="comment">//www.iocoder.cn/images/Eureka/2018_08_07/02.png)</span></div><div class="line"></div><div class="line">* Eureka-Server 接收到 Eureka-Client 的 Register、Heartbeat、Cancel、StatusUpdate、DeleteStatusOverride 操作，固定间隔( 默认值 ：<span class="number">500</span> 毫秒，可配 )向 Eureka-Server 集群内其他节点同步( **准实时，非实时** )。</div><div class="line"></div><div class="line">## 4.1 同步操作类型</div><div class="line"></div><div class="line">`com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action` ，同步操作类型，代码如下：</div><div class="line"></div><div class="line">```Java</div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Action &#123;</div><div class="line">   Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略监控相关属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Register ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析</p></li><li>Heartbeat ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析</li><li>Cancel ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/?self">《Eureka 源码解析 —— 应用实例注册发现（三）之下线》</a> 有详细解析</li><li>StatusUpdate ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li><li>DeleteStatusOverride ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li></ul><h2 id="4-2-发起-Eureka-Server-同步操作"><a href="#4-2-发起-Eureka-Server-同步操作" class="headerlink" title="4.2 发起 Eureka-Server 同步操作"></a>4.2 发起 Eureka-Server 同步操作</h2><p>Eureka-Server 在完成 Eureka-Client 发起的上述操作在<strong>自身节点的执行后</strong>，向集群内其他 Eureka-Server 发起同步操作。以 Register 操作举例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>最后一行，调用 <code>#replicateToPeers(...)</code> 方法，传递<strong>对应的同步操作类型</strong>，发起同步操作。</li></ul><hr><p><code>#replicateToPeers(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">2</span>:                               InstanceInfo info <span class="comment">/* optional */</span>,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                               InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     Stopwatch tracer = action.getTimer().start();</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">7</span>:             numberOfReplicationsLastMin.increment();</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// Eureka-Server 发起的请求 或者 集群为空</span></div><div class="line"><span class="number">11</span>:         <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></div><div class="line"><span class="number">12</span>:         <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">return</span>;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</div><div class="line"><span class="number">17</span>:             <span class="comment">// If the url represents this host, do not replicate to yourself.</span></div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</div><div class="line"><span class="number">19</span>:                 <span class="keyword">continue</span>;</div><div class="line"><span class="number">20</span>:             &#125;</div><div class="line"><span class="number">21</span>:             replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">24</span>:         tracer.stop();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 至 14 行 ：Eureka-Server 在处理上述操作( Action )，无论来自 Eureka-Client 发起请求，还是 Eureka-Server 发起同步，调用的内部方法相同，通过 <code>isReplication=true</code> 参数，避免死循环同步。</li><li>第 16 至 22 行 ：<strong>循环</strong>集群内<strong>每个</strong>节点，调用 <code>#replicateInstanceActionsToPeers(...)</code> 方法，发起同步操作。</li></ul><hr><p><code>#replicateInstanceActionsToPeers(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateInstanceActionsToPeers</span><span class="params">(Action action, String appName,</span></span></div><div class="line"><span class="function"><span class="params">                                            String id, InstanceInfo info, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                            PeerEurekaNode node)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       InstanceInfo infoFromRegistry;</div><div class="line">       CurrentRequestVersion.set(Version.V2);</div><div class="line">       <span class="keyword">switch</span> (action) &#123;</div><div class="line">           <span class="keyword">case</span> Cancel:</div><div class="line">               node.cancel(appName, id);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Heartbeat:</div><div class="line">               InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Register:</div><div class="line">               node.register(info);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> StatusUpdate:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.statusUpdate(appName, id, newStatus, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.deleteStatusOverride(appName, id, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot replicate information to &#123;&#125; for action &#123;&#125;"</span>, node.getServiceUrl(), action.name(), t);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>Cancel</strong> ：调用 <code>PeerEurekaNode#cancel(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L157" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>Heartbeat</strong> ：调用 <code>PeerEurekaNode#heartbeat(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L194" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>Register</strong> ：调用 <code>PeerEurekaNode#register(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L134" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>StatusUpdate</strong> ：调用 <code>PeerEurekaNode#statusUpdate(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L243" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>DeleteStatusOverride</strong> ：调用 <code>PeerEurekaNode#deleteStatusOverride(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L294" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><p>上面的每个方法实现，我们<strong>都</strong>会看到类似这么一段代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">batchingDispatcher.process(</div><div class="line">    taskId(<span class="string">"$&#123;action&#125;"</span>, appName, id), <span class="comment">// id</span></div><div class="line">    <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> replicationClient.doString(...);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="comment">// do Something...</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;, <span class="comment">// ReplicationTask 子类</span></div><div class="line">    expiryTime</div><div class="line">)</div></pre></td></tr></table></figure><ul><li><p><code>#task(...)</code> 方法，生成同步操作任务<strong>编号</strong>。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">taskId</span><span class="params">(String requestType, String appName, String id)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> requestType + <span class="string">'#'</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>相同应用实例的相同同步操作使用相同任务编号</strong>。在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「2. 整体流程」</a> 中，我们看到” 接收线程( Runner )合并任务，将相同任务编号的任务合并，只执行一次。 “，因此，相同应用实例的相同同步操作就能被合并，减少操作量。例如，Eureka-Server 同步某个应用实例的 Heartbeat 操作，接收同步的 Eureak-Server 挂了，一方面这个应用的这次操作会<strong>重试</strong>，另一方面，这个应用实例会发起<strong>新的</strong> Heartbeat 操作，通过任务编号合并，接收同步的 Eureka-Server 恢复后，减少收到<strong>重复积压</strong>的任务。</li></ul><ul><li>InstanceReplicationTask ，同步操作任务，在 <a href="#">「4.1.1 同步操作任务」</a> 详细解析。</li><li><code>expiryTime</code> ，任务过期时间。</li></ul></li></ul></li></ul><h3 id="4-1-1-同步操作任务"><a href="#4-1-1-同步操作任务" class="headerlink" title="4.1.1 同步操作任务"></a>4.1.1 同步操作任务</h3><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/03.png" alt=""></p><ul><li><code>com.netflix.eureka.cluster.ReplicationTask</code> ，同步任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 ReplicationTask 代码。</li><li>定义了 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li><li>定义了 <code>#execute()</code> <strong>抽象</strong>方法，执行同步任务。</li><li>实现了 <code>#handleSuccess()</code> 方法，处理成功执行同步结果。</li><li>实现了 <code>#handleFailure(...)</code> 方法，处理失败执行同步结果。</li></ul></li><li><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，同步应用实例任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/InstanceReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li><li>实现了父类 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li></ul></li><li><code>com.netflix.eureka.cluster.AsgReplicationTask</code> ，亚马逊 AWS 使用，暂时跳过。</li></ul><p>从上面 <code>PeerEurekaNode#同步操作(...)</code> 方法，<strong>全部</strong>实现了 InstanceReplicationTask 类的 <code>#execute()</code> 方法，<strong>部分</strong>重写了 <code>#handleFailure(...)</code> 方法。</p><h3 id="4-1-2-同步操作任务处理器"><a href="#4-1-2-同步操作任务处理器" class="headerlink" title="4.1.2 同步操作任务处理器"></a>4.1.2 同步操作任务处理器</h3><p><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，实现 TaskProcessor <strong>接口</strong>，同步操作任务处理器。</p><ul><li>TaskProcessor ，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「10. 任务执行器【执行任务】」</a> 有详细解析。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li></ul><p><code>ReplicationTaskProcessor#process(task)</code> ，<strong>处理单任务</strong>，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态，暂时跳过，感兴趣的同学可以点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L38" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。</p><p><code>ReplicationTaskProcessor#process(tasks)</code> ，<strong>处理批量任务</strong>，用于 Eureka-Server 集群注册信息的同步操作任务，通过调用被同步的 Eureka-Server 的 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：创建批量提交同步操作任务的请求对象( ReplicationList ) 。比较易懂，咱就不啰嗦贴代码了。<ul><li>ReplicationList ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationList.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstance ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstance.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li><code>#createReplicationListOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#createReplicationInstanceOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L173" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li>第 7 行 ：调用 <code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，请求 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求。<ul><li><code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L109" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。 </li><li>ReplicationListResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationListResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstanceResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstanceResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li></ul></li><li>第 9 至 31 行 ：处理批量提交同步操作任务的响应，在 <a href="#">「4.4 处理 Eureka-Server 同步结果」</a> 详细解析。</li></ul><h2 id="4-3-接收-Eureka-Server-同步操作"><a href="#4-3-接收-Eureka-Server-同步操作" class="headerlink" title="4.3 接收 Eureka-Server 同步操作"></a>4.3 接收 Eureka-Server 同步操作</h2><p><code>com.netflix.eureka.resources.PeerReplicationResource</code> ，同步操作任务 Resource ( Controller )。</p><p><code>peerreplication/batch/</code> 接口，映射 <code>PeerReplicationResource#batchReplication(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Path</span>(<span class="string">"batch"</span>)</div><div class="line"> <span class="number">2</span>: <span class="meta">@POST</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">batchReplication</span><span class="params">(ReplicationList replicationList)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         ReplicationListResponse batchResponse = <span class="keyword">new</span> ReplicationListResponse();</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 逐个同步操作任务处理，并将处理结果( ReplicationInstanceResponse ) 合并到 ReplicationListResponse 。</span></div><div class="line"> <span class="number">7</span>:         <span class="keyword">for</span> (ReplicationInstance instanceInfo : replicationList.getReplicationList()) &#123;</div><div class="line"> <span class="number">8</span>:             <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">9</span>:                 batchResponse.addResponse(dispatch(instanceInfo));</div><div class="line"><span class="number">10</span>:             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">11</span>:                 batchResponse.addResponse(<span class="keyword">new</span> ReplicationInstanceResponse(Status.INTERNAL_SERVER_ERROR.getStatusCode(), <span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:                 logger.error(instanceInfo.getAction() + <span class="string">" request processing failed for batch item "</span></div><div class="line"><span class="number">13</span>:                         + instanceInfo.getAppName() + <span class="string">'/'</span> + instanceInfo.getId(), e);</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span> Response.ok(batchResponse).build();</div><div class="line"><span class="number">17</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"Cannot execute batch Request"</span>, e);</div><div class="line"><span class="number">19</span>:         <span class="keyword">return</span> Response.status(Status.INTERNAL_SERVER_ERROR).build();</div><div class="line"><span class="number">20</span>:     &#125;</div><div class="line"><span class="number">21</span>: &#125;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="function"><span class="keyword">private</span> ReplicationInstanceResponse <span class="title">dispatch</span><span class="params">(ReplicationInstance instanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">24</span>:     ApplicationResource applicationResource = createApplicationResource(instanceInfo);</div><div class="line"><span class="number">25</span>:     InstanceResource resource = createInstanceResource(instanceInfo, applicationResource);</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     String lastDirtyTimestamp = toString(instanceInfo.getLastDirtyTimestamp());</div><div class="line"><span class="number">28</span>:     String overriddenStatus = toString(instanceInfo.getOverriddenStatus());</div><div class="line"><span class="number">29</span>:     String instanceStatus = toString(instanceInfo.getStatus());</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:     Builder singleResponseBuilder = <span class="keyword">new</span> Builder();</div><div class="line"><span class="number">32</span>:     <span class="keyword">switch</span> (instanceInfo.getAction()) &#123;</div><div class="line"><span class="number">33</span>:         <span class="keyword">case</span> Register:</div><div class="line"><span class="number">34</span>:             singleResponseBuilder = handleRegister(instanceInfo, applicationResource);</div><div class="line"><span class="number">35</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>:         <span class="keyword">case</span> Heartbeat:</div><div class="line"><span class="number">37</span>:             singleResponseBuilder = handleHeartbeat(serverConfig, resource, lastDirtyTimestamp, overriddenStatus, instanceStatus);</div><div class="line"><span class="number">38</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">39</span>:         <span class="keyword">case</span> Cancel:</div><div class="line"><span class="number">40</span>:             singleResponseBuilder = handleCancel(resource);</div><div class="line"><span class="number">41</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">42</span>:         <span class="keyword">case</span> StatusUpdate:</div><div class="line"><span class="number">43</span>:             singleResponseBuilder = handleStatusUpdate(instanceInfo, resource);</div><div class="line"><span class="number">44</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">45</span>:         <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line"><span class="number">46</span>:             singleResponseBuilder = handleDeleteStatusOverride(instanceInfo, resource);</div><div class="line"><span class="number">47</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">48</span>:     &#125;</div><div class="line"><span class="number">49</span>:     <span class="keyword">return</span> singleResponseBuilder.build();</div><div class="line"><span class="number">50</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 15 行 ：逐个处理<strong>单个</strong>同步操作任务，并将处理结果( ReplicationInstanceResponse ) 添加到 ReplicationListResponse 。</li><li>第 23 至 50 行 ：处理<strong>单个</strong>同步操作任务，返回处理结果( ReplicationInstanceResponse )。<ul><li>第 24 至 25 行 ：创建 ApplicationResource , InstanceResource 。我们看到，实际该方法是把<strong>单个</strong>同步操作任务提交到其他 Resource ( Controller ) 处理，Eureka-Server 收到 Eureka-Client 请求响应的 Resource ( Controller ) 是<strong>相同的逻辑</strong>。</li><li>Register ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L137" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleRegister(...)</code> 方法。</li><li>Heartbeat ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L147" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleHeartbeat(...)</code> 方法。</li><li>Cancel ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleCancel(...)</code> 方法。</li><li>StatusUpdate ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L165" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleStatusUpdate(...)</code> 方法。</li><li>DeleteStatusOverride ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L170" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleDeleteStatusOverride(...)</code> 方法。</li></ul></li></ul><h2 id="4-4-处理-Eureka-Server-同步结果"><a href="#4-4-处理-Eureka-Server-同步结果" class="headerlink" title="4.4 处理 Eureka-Server 同步结果"></a>4.4 处理 Eureka-Server 同步结果</h2><p>😈 想想就有小激动，终于写到这里了。</p><p>接 <code>ReplicationTaskProcessor#process(tasks)</code> 方法，处理批量提交同步操作任务的响应，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ，调用 <code>#isSuccess(...)</code> 方法，判断请求是否成功，响应状态码是否在  [200, 300) 范围内。</li><li>第 11 至 13 行 ：状态码 503 ，目前 Eureka-Server 返回 503 的原因是被限流。在 <a href="">《TODO[0021]：限流》</a> 详细解析。<strong>该情况为瞬时错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</li><li>第 14 至 18 行 ：非<strong>预期</strong>状态码，目前 Eureka-Server 在代码上看下来，不会返回这样的状态码。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</li><li>第 20 行 ：请求成功，调用 <code>#handleBatchResponse(...)</code> 方法，逐个处理<strong>每个</strong> ReplicationTask 和 ReplicationInstanceResponse 。<strong>这里有一点要注意下，请求成功指的是整个请求成功，实际每个 ReplicationInstanceResponse 可能返回的状态码不在 [200, 300) 范围内</strong>。该方法下文详细解析。</li><li><p>第 23 至 25 行 ：请求发生网络异常，例如网络超时，打印网络异常日志。目前日志的打印为部分采样，条件为网络发生异常每间隔 10 秒打印一条，避免网络发生异常打印超级大量的日志。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p><ul><li><code>#isNetworkConnectException(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L163" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#logNetworkErrorSample(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L103" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li><p>第 26 至 29 行 ：非<strong>预期</strong>异常，目前 Eureka-Server 在代码上看下来，不会抛出这样的异常。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p></li></ul><hr><p><code>#handleBatchResponse(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(List&lt;ReplicationTask&gt; tasks, List&lt;ReplicationInstanceResponse&gt; responseList)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (tasks.size() != responseList.size()) &#123;</div><div class="line">       <span class="comment">// This should ideally never happen unless there is a bug in the software.</span></div><div class="line">       logger.error(<span class="string">"Batch response size different from submitted task list (&#123;&#125; != &#123;&#125;); skipping response analysis"</span>, responseList.size(), tasks.size());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</div><div class="line">       handleBatchResponse(tasks.get(i), responseList.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(ReplicationTask task, ReplicationInstanceResponse response)</span> </span>&#123;</div><div class="line">   <span class="comment">// 执行成功</span></div><div class="line">   <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line">   <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</div><div class="line">       task.handleSuccess();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 执行失败</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       task.handleFailure(response.getStatusCode(), response.getResponseEntity());</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Replication task "</span> + task.getTaskName() + <span class="string">" error handler failure"</span>, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>ReplicationTask#handleSuccess()</code> 方法，无任务同步操作任务重写，是个<strong>空方法</strong>，代码如下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ReplicationTask.java</div><div class="line">public void handleSuccess() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>ReplicationTask#handleFailure()</code> 方法，有<strong>两个</strong>同步操作任务重写：</p><ul><li><p>Cancel ：当 Eureka-Server 不存在下线的应用实例时，返回 404 状态码，此时打印错误日志，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#cancel(...)</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">    <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">        logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>Heartbeat ：情况较为复杂，我们换一行继续说，避免排版有问题，影响阅读。</p></li></ul></li></ul><p>噔噔噔恰，本文的重要头戏来啦！Last But Very Importment ！！！</p><p>Eureka-Server 是允许<strong>同一时刻</strong>允许在任意节点被 Eureka-Client 发起<strong>写入</strong>相关的操作，网络是不可靠的资源，Eureka-Client 可能向一个 Eureka-Server 注册成功，但是网络波动，导致 Eureka-Client 误以为失败，此时恰好 Eureka-Client 变更了应用实例的状态，重试向另一个 Eureka-Server 注册，那么两个 Eureka-Server 对该应用实例的状态产生冲突。</p><p>再例如…… 我们不要继续举例子，网络波动真的很复杂。我们来看看 Eureka 是怎么处理的。</p><p>应用实例( InstanceInfo ) 的 <code>lastDirtyTimestamp</code> 属性，使用<strong>时间戳</strong>，表示应用实例的<strong>版本号</strong>，当请求方( 不仅仅是 Eureka-Client ，也可能是同步注册操作的 Eureka-Server ) 向 Eureka-Server 发起注册时，若 Eureka-Server 已存在拥有更大 <code>lastDirtyTimestamp</code> 该实例( <strong>相同应用并且相同应用实例编号被认为是相同实例</strong> )，则请求方注册的应用实例( InstanceInfo ) 无法覆盖注册此 Eureka-Server 的该实例( 见 <code>AbstractInstanceRegistry#register(...)</code> 方法 )。例如我们上面举的例子，第一个 Eureka-Server 向 第二个 Eureka-Server 同步注册应用实例时，不会注册覆盖，反倒是第二个 Eureka-Server 同步注册应用到第一个 Eureka-Server ，注册覆盖成功，因为 <code>lastDirtyTimestamp</code> ( 应用实例状态变更时，可以设置 <code>lastDirtyTimestamp</code> 为当前时间，见 <code>ApplicationInfoManager#setInstanceStatus(status)</code> 方法 )。</p><p>但是光靠<strong>注册</strong>请求判断 <code>lastDirtyTimestamp</code> 显然是不够的，因为网络异常情况下时，同步操作任务多次执行失败到达过期时间后，此时在 Eureka-Server 集群同步起到最终一致性<strong>最最最</strong>关键性出现了：Heartbeat 。因为 Heartbeat 会周期性的执行，通过它一方面可以判断 Eureka-Server 是否存在心跳对应的应用实例，另外一方面可以比较应用实例的 <code>lastDirtyTimestamp</code> 。当满足下面任意条件，Eureka-Server 返回 404 状态码：</p><ul><li>1）Eureka-Server 应用实例不存在，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L438" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li><li>2）Eureka-Server 应用实例状态为 <code>UNKNOWN</code>，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L450" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。为什么会是 <code>UNKNOWN</code> ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》「 4.3 续租场景」</a> 有详细解析。</li><li><strong>3）</strong>请求的 <code>lastDirtyTimestamp</code> 更大，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L306" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul><p>请求方接收到 404 状态码返回后，<strong>认为 Eureka-Server 应用实例实际是不存在的</strong>，重新发起应用实例的注册。以本文的 Heartbeat 为例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#heartbeat(...)</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">  <span class="number">5</span>:         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">  <span class="number">6</span>:         <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:             logger.warn(<span class="string">"&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;"</span>,</div><div class="line">  <span class="number">8</span>:                     getTaskName(), info.getId(), info.getStatus());</div><div class="line">  <span class="number">9</span>:             register(info);</div><div class="line"> <span class="number">10</span>:         &#125;</div><div class="line"> <span class="number">11</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"> <span class="number">12</span>:         InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</div><div class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (peerInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:             syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</div><div class="line"> <span class="number">15</span>:         &#125;</div><div class="line"> <span class="number">16</span>:     &#125;</div><div class="line"> <span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 4 至 10 行 ：接收到 404 状态码，调用 <code>#register(...)</code> 方法，向该被心跳同步操作失败的 Eureka-Server 发起注册<strong>本地的应用实例</strong>的请求。</p><ul><li>上述 <strong>3）</strong> ，会使用请求参数 <code>overriddenStatus</code> 存储到 Eureka-Server 的应用实例覆盖状态集合( <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> )，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L123" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul></li><li><p>第 11 至 16 行 ：恰好是 <strong>3）</strong> 反过来的情况，本地的应用实例的 <code>lastDirtyTimestamp</code> 小于 Eureka-Server 该应用实例的，此时 Eureka-Server 返回 409 状态码，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L314" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。调用 <code>#syncInstancesIfTimestampDiffers()</code> 方法，覆盖注册本地应用实例，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L387" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</p></li></ul><p>OK，撒花！记住：Eureka 通过 Heartbeat 实现 Eureka-Server 集群同步的最终一致性。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写的比较嗨皮，所以就送胖友一只胖友</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/01.png" alt=""></p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/server-cluster/&quot;&gt;http://www.iocoder.cn/Eureka/server-cluster/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;

      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 网络通信</title>
    <link href="http://www.iocoder.cn/Eureka/transport/"/>
    <id>http://www.iocoder.cn/Eureka/transport/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2017-10-17T14:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/transport/">http://www.iocoder.cn/Eureka/transport/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">2. EurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">2.1 EurekaJerseyClientImpl</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">2.2 EurekaJerseyClientBuilder</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">3. EurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">3.1 EurekaHttpResponse</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">3.2 TransportClientFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">4. AbstractJerseyEurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">4.1 JerseyApplicationClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">4.2 JerseyReplicationClient</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5. EurekaHttpClientDecorator</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">5.1 MetricsCollectingEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.2 RedirectingEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.3 RetryableEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.4 SessionedEurekaHttpClient</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">6. 创建网络通讯客户端</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka 的网络通信部分</strong>。在不考虑 Eureka 2.x 的兼容的情况下，Eureka 1.x 主要两部分的网络通信：</p><ul><li>Eureka-Client 请求 Eureka-Server 的网络通信</li><li>Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信</li></ul><p>本文涉及类在 <code>com.netflix.discovery.shared.transport</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/01.png" alt=""></p><ul><li>粉色部分 —— EurekaJerseyClient ，对基于 Jersey Server 的 Eureka-Server 的 Jersey 客户端封装。</li><li>绿色部分 —— EurekaHttpClient ，Eureka-Server HTTP 访问客户端，定义了具体的 Eureka-Server API 调用方法。如果把 DiscoveryClient 类比成 Service ，那么 EurekaHttpClient 可以类比城 Dao 。</li><li>综色部分 —— EurekaHttpClient 实现类，<strong>真正</strong>实现了具体的 Eureka-Server API 调用方法。</li><li>红色部分 —— EurekaHttpClient 委托类，提供了<strong>会话、重试、重定向、监控指标收集</strong>等特性。</li><li>黄色部分 —— EurekaHttpClientFactory，用于创建 EurekaHttpClient 。</li></ul><p>类图看起来很复杂，整体调用关系如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/02.png" alt=""></p><p>OK ，我们逐层解析，嗨起来。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaHttpClient"><a href="#2-EurekaHttpClient" class="headerlink" title="2. EurekaHttpClient"></a>2. EurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.jersey.EurekaJerseyClient</code> ，EurekaHttpClient <strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaJerseyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">ApacheHttpClient4 <span class="title">getClient</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyResources</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.sun.jersey.client.apache4.ApacheHttpClient4</code> ，基于 Apache HttpClient4 实现的 Jersey Client 。</li></ul><h2 id="2-1-EurekaJerseyClientImpl"><a href="#2-1-EurekaJerseyClientImpl" class="headerlink" title="2.1 EurekaJerseyClientImpl"></a>2.1 EurekaJerseyClientImpl</h2><p><code>com.netflix.discovery.shared.transport.jersey.EurekaJerseyClientImpl</code> ，EurekaHttpClient <strong>实现类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaJerseyClientImpl</span> <span class="keyword">implements</span> <span class="title">EurekaJerseyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 基于 Apache HttpClient4 实现的 Jersey Client</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheHttpClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Apache HttpClient 空闲连接清理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner apacheHttpClientConnectionCleaner;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ClientConfig jerseyClientConfig;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EurekaJerseyClientImpl</span><span class="params">(<span class="keyword">int</span> connectionTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">final</span> <span class="keyword">int</span> connectionIdleTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                                  ClientConfig clientConfig)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            jerseyClientConfig = clientConfig;</div><div class="line">            <span class="comment">// 创建  ApacheHttpClient</span></div><div class="line">            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);</div><div class="line"></div><div class="line">            <span class="comment">// 设置 连接参数</span></div><div class="line">            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();</div><div class="line">            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);</div><div class="line">            HttpConnectionParams.setSoTimeout(params, readTimeout);</div><div class="line"></div><div class="line">            <span class="comment">// 创建 ApacheHttpClientConnectionCleaner</span></div><div class="line">            <span class="keyword">this</span>.apacheHttpClientConnectionCleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(apacheHttpClient, connectionIdleTimeout);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create Jersey client"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ApacheHttpClient4 <span class="title">getClient</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> apacheHttpClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyResources</span><span class="params">()</span> </span>&#123;</div><div class="line">        apacheHttpClientConnectionCleaner.shutdown();</div><div class="line">        apacheHttpClient.destroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.discovery.shared.transport.jersey.ApacheHttpClientConnectionCleaner</code> ，Apache HttpClient 空闲连接清理器，负责<strong>周期性</strong>关闭处于 <code>half-close</code> 状态的空闲连接。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/ApacheHttpClientConnectionCleaner.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 ApacheHttpClientConnectionCleaner。推荐阅读：<a href="http://seanhe.iteye.com/blog/234759" rel="external nofollow noopener noreferrer" target="_blank">《HttpClient容易忽视的细节——连接关闭》</a> 。</li></ul><h2 id="2-2-EurekaJerseyClientBuilder"><a href="#2-2-EurekaJerseyClientBuilder" class="headerlink" title="2.2 EurekaJerseyClientBuilder"></a>2.2 EurekaJerseyClientBuilder</h2><p>EurekaJerseyClientBuilder ，EurekaJerseyClientImpl <strong>内部类</strong>，用于创建 EurekaJerseyClientImpl 。</p><p>调用 <code>#build()</code> 方法，创建 EurekaJerseyClientImpl ，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaJerseyClientBuilder.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaJerseyClient <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    MyDefaultApacheHttpClient4Config config = <span class="keyword">new</span> MyDefaultApacheHttpClient4Config();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EurekaJerseyClientImpl(connectionTimeout, readTimeout, connectionIdleTimeout, config);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create Jersey client "</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>MyDefaultApacheHttpClient4Config ，继承自 <code>com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config</code> ，实现<strong>自定义配置</strong>。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/EurekaJerseyClientImpl.java#L199" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 MyDefaultApacheHttpClient4Config。例如 ：<ul><li>自定义的<strong>请求、响应的编解码器</strong> <code>com.netflix.discovery.provider.DiscoveryJerseyProvider</code> 。</li><li>禁用<strong>重定向</strong>，使用 RedirectingEurekaHttpClient 实现该特性。</li><li>自定义 UserAgent 。</li><li>自定义 Http Proxy 。</li><li>SSL 功能的增强。ApacheHttpClient4 使用的是 Apache HttpClient 4.1.1 版本，<code>com.netflix.discovery.shared.transport.jersey.SSLSocketFactoryAdapter</code> 将 Apache HttpClient 4.3.4 对 SSL 功能的增强适配到老版本 API 。点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/SSLSocketFactoryAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 SSLSocketFactoryAdapter。</li></ul></li></ul><h1 id="3-EurekaHttpClient"><a href="#3-EurekaHttpClient" class="headerlink" title="3. EurekaHttpClient"></a>3. EurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.EurekaHttpClient</code> ，Eureka-Server HTTP 访问客户端，定义了具体的 Eureka-Server API 调用方法 。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClient.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 EurekaHttpClient。</p><h2 id="3-1-EurekaHttpResponse"><a href="#3-1-EurekaHttpResponse" class="headerlink" title="3.1 EurekaHttpResponse"></a>3.1 EurekaHttpResponse</h2><p><code>com.netflix.discovery.shared.transport.EurekaHttpResponse</code> ，请求响应对象，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回状态码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> statusCode;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回对象( Entity )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T entity;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回 header</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; headers;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重定向地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URI location;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略 setting / getting 和 Builder</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-TransportClientFactory"><a href="#3-2-TransportClientFactory" class="headerlink" title="3.2 TransportClientFactory"></a>3.2 TransportClientFactory</h2><p><code>com.netflix.discovery.shared.transport.TransportClientFactory</code> ，创建 EurekaHttpClient 的工厂<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建 EurekaHttpClient</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> serviceUrl Eureka-Server 地址</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> EurekaHttpClient</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 关闭工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>大多数 EurekaHttpClient 实现类都有其对应的工厂实现类</strong>。</p><h1 id="4-AbstractJerseyEurekaHttpClient"><a href="#4-AbstractJerseyEurekaHttpClient" class="headerlink" title="4. AbstractJerseyEurekaHttpClient"></a>4. AbstractJerseyEurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient</code> ，实现 EurekaHttpClient 的<strong>抽象类</strong>，<strong>真正</strong>实现了具体的 Eureka-Server API 调用方法。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJerseyEurekaHttpClient</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:  * Jersey Client</span></div><div class="line"><span class="comment"> 7:  */</span></div><div class="line"> <span class="number">8</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Client jerseyClient;</div><div class="line"> <span class="number">9</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">10:  * 请求的 Eureka-Server 地址</span></div><div class="line"><span class="comment">11:  */</span></div><div class="line"><span class="number">12</span>: <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">protected</span> <span class="title">AbstractJerseyEurekaHttpClient</span><span class="params">(Client jerseyClient, String serviceUrl)</span> </span>&#123;</div><div class="line"><span class="number">15</span>:     <span class="keyword">this</span>.jerseyClient = jerseyClient;</div><div class="line"><span class="number">16</span>:     <span class="keyword">this</span>.serviceUrl = serviceUrl;</div><div class="line"><span class="number">17</span>:     logger.debug(<span class="string">"Created client for url: &#123;&#125;"</span>, serviceUrl);</div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">21</span>: <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 设置 请求地址</span></div><div class="line"><span class="number">23</span>:     String urlPath = <span class="string">"apps/"</span> + info.getAppName();</div><div class="line"><span class="number">24</span>:     ClientResponse response = <span class="keyword">null</span>;</div><div class="line"><span class="number">25</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">26</span>:         Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line"><span class="number">27</span>:         <span class="comment">// 设置 请求头</span></div><div class="line"><span class="number">28</span>:         addExtraHeaders(resourceBuilder);</div><div class="line"><span class="number">29</span>:         <span class="comment">// 请求 Eureka-Server</span></div><div class="line"><span class="number">30</span>:         response = resourceBuilder</div><div class="line"><span class="number">31</span>:                 .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>) <span class="comment">// GZIP</span></div><div class="line"><span class="number">32</span>:                 .type(MediaType.APPLICATION_JSON_TYPE) <span class="comment">// 请求参数格式 JSON</span></div><div class="line"><span class="number">33</span>:                 .accept(MediaType.APPLICATION_JSON) <span class="comment">// 响应结果格式 JSON</span></div><div class="line"><span class="number">34</span>:                 .post(ClientResponse.class, info); <span class="comment">// 请求参数</span></div><div class="line"><span class="number">35</span>:         <span class="comment">// 创建 EurekaHttpResponse</span></div><div class="line"><span class="number">36</span>:         <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line"><span class="number">37</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">38</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">39</span>:             logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</div><div class="line"><span class="number">40</span>:                     response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:         <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">43</span>:             response.close();</div><div class="line"><span class="number">44</span>:         &#125;</div><div class="line"><span class="number">45</span>:     &#125;</div><div class="line"><span class="number">46</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>jerseyClient</code> 属性，Jersey Client ，使用上文的 <code>EurekaHttpClient#getClient(...)</code> 方法，获取 ApacheHttpClient4 。</li><li><code>serviceUrl</code> 属性，请求的 Eureka-Server 地址。</li><li><p><code>#register()</code> 方法，实现向 Eureka-Server 注册应用实例。<strong>其他方法代码类似</strong>。</p><ul><li>第 22 至 26 行 ：设置请求地址。</li><li><p>第 28 行 ：调用 <code>#addExtraHeaders(...)</code> 方法，设置请求头( header  )。该方法是<strong>抽象方法</strong>，提供子类实现自定义的请求头。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addExtraHeaders</span><span class="params">(Builder webResource)</span></span>;</div></pre></td></tr></table></figure><ul><li>x<ul><li>第 29 至 34 行 ：请求 Eureka-Server 。</li><li>第 35 至 36 行 ：解析响应结果，创建 EurekaHttpResponse 。</li></ul></li></ul></li></ul></li></ul><h2 id="4-1-JerseyApplicationClient"><a href="#4-1-JerseyApplicationClient" class="headerlink" title="4.1 JerseyApplicationClient"></a>4.1 JerseyApplicationClient</h2><p><code>com.netflix.discovery.shared.transport.jersey.JerseyApplicationClient</code> ，实现 Eureka-Client 请求 Eureka-Server 的网络通信。点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyApplicationClient.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 JerseyApplicationClient。</p><h3 id="4-1-1-JerseyEurekaHttpClientFactory"><a href="#4-1-1-JerseyEurekaHttpClientFactory" class="headerlink" title="4.1.1 JerseyEurekaHttpClientFactory"></a>4.1.1 JerseyEurekaHttpClientFactory</h3><p><code>com.netflix.discovery.shared.transport.jersey.JerseyEurekaHttpClientFactory</code> ，创建 JerseyApplicationClient 的<strong>工厂类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyEurekaHttpClientFactory</span> <span class="keyword">implements</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaJerseyClient jerseyClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner cleaner;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; additionalHeaders;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(ApacheHttpClient4 apacheClient, <span class="keyword">long</span> connectionIdleTimeout, Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, apacheClient, connectionIdleTimeout, additionalHeaders);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(EurekaJerseyClient jerseyClient,</span></span></div><div class="line"><span class="function"><span class="params">                                          ApacheHttpClient4 apacheClient,</span></span></div><div class="line"><span class="function"><span class="params">                                          <span class="keyword">long</span> connectionIdleTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</div><div class="line">        <span class="keyword">this</span>.apacheClient = jerseyClient != <span class="keyword">null</span> ? jerseyClient.getClient() : apacheClient;</div><div class="line">        <span class="keyword">this</span>.additionalHeaders = additionalHeaders;</div><div class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(<span class="keyword">this</span>.apacheClient, connectionIdleTimeout);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint endpoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        cleaner.shutdown();</div><div class="line">        <span class="keyword">if</span> (jerseyClient != <span class="keyword">null</span>) &#123;</div><div class="line">            jerseyClient.destroyResources();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            apacheClient.destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-1-2-JerseyEurekaHttpClientFactoryBuilder"><a href="#4-1-2-JerseyEurekaHttpClientFactoryBuilder" class="headerlink" title="4.1.2 JerseyEurekaHttpClientFactoryBuilder"></a>4.1.2 JerseyEurekaHttpClientFactoryBuilder</h3><p>JerseyEurekaHttpClientFactoryBuilder ，JerseyEurekaHttpClientFactory <strong>内部类</strong>，用于创建 JerseyEurekaHttpClientFactory 。点击 <a href="https://github.com/YunaiV/eureka/blob/ff48fa728c7085ad8116517ede88398b0fd693c7/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java#L152" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 JerseyEurekaHttpClientFactory。</p><p>调用 <code>JerseyEurekaHttpClientFactory#create(...)</code> 方法，创建 JerseyEurekaHttpClientFactory ，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JerseyEurekaHttpClientFactory <span class="title">create</span><span class="params">(EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                  Collection&lt;ClientFilter&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                  InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                                  AbstractEurekaIdentity clientIdentity)</span> </span>&#123;</div><div class="line">   JerseyEurekaHttpClientFactoryBuilder clientBuilder = newBuilder()</div><div class="line">           .withAdditionalFilters(additionalFilters) <span class="comment">// 客户端附加过滤器</span></div><div class="line">           .withMyInstanceInfo(myInstanceInfo) <span class="comment">// 应用实例</span></div><div class="line">           .withUserAgent(<span class="string">"Java-EurekaClient"</span>) <span class="comment">// UA</span></div><div class="line">           .withClientConfig(clientConfig)</div><div class="line">           .withClientIdentity(clientIdentity);</div><div class="line"></div><div class="line">   <span class="comment">// 设置 Client Name</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">"true"</span>.equals(System.getProperty(<span class="string">"com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"</span>))) &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"DiscoveryClient-HTTPClient-System"</span>).withSystemSSLConfiguration();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientConfig.getProxyHost() != <span class="keyword">null</span> &amp;&amp; clientConfig.getProxyPort() != <span class="keyword">null</span>) &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"Proxy-DiscoveryClient-HTTPClient"</span>)</div><div class="line">               .withProxy(</div><div class="line">                       clientConfig.getProxyHost(), Integer.parseInt(clientConfig.getProxyPort()),</div><div class="line">                       clientConfig.getProxyUserName(), clientConfig.getProxyPassword()</div><div class="line">               ); <span class="comment">// http proxy</span></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"DiscoveryClient-HTTPClient"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> clientBuilder.build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JerseyEurekaHttpClientFactoryBuilder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> JerseyEurekaHttpClientFactoryBuilder().withExperimental(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-JerseyReplicationClient"><a href="#4-2-JerseyReplicationClient" class="headerlink" title="4.2 JerseyReplicationClient"></a>4.2 JerseyReplicationClient</h2><p><code>com.netflix.eureka.transport.JerseyReplicationClient</code> ，Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信。</p><ul><li><p>实现 <code>AbstractJerseyEurekaHttpClient#addExtraHeaders()</code> 方法，添加自定义头 <code>x-netflix-discovery-replication=true</code> ，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addExtraHeaders</span><span class="params">(Builder webResource)</span> </span>&#123;</div><div class="line">   webResource.header(PeerEurekaNode.HEADER_REPLICATION, <span class="string">"true"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>重写了 <code>#sendHeartBeat(...)</code> 方法，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p></li><li>实现 <code>com.netflix.eureka.cluster.HttpReplicationClient</code> 接口，实现了 <code>#submitBatchUpdates(...)</code> 方法，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</li></ul><h3 id="4-2-1-没有工厂"><a href="#4-2-1-没有工厂" class="headerlink" title="4.2.1 没有工厂"></a>4.2.1 没有工厂</h3><p>JerseyReplicationClient <strong>没有专属的工厂</strong>。</p><p>调用 <code>JerseyReplicationClient#createReplicationClient(...)</code> <strong>静态方法</strong>，创建 JerseyReplicationClient 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L135" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的方法代码。</p><h1 id="5-EurekaHttpClientDecorator"><a href="#5-EurekaHttpClientDecorator" class="headerlink" title="5. EurekaHttpClientDecorator"></a>5. EurekaHttpClientDecorator</h1><p><code>com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator</code>，EurekaHttpClient 委托者<strong>抽象类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClientDecorator</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行请求</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> requestExecutor 请求执行器</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; 请求泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 响应</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> delegate.register(info);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> RequestType.Register;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#execute(...)</code> <strong>抽象方法</strong>，子类实现该方法，实现自己的特性。</li><li><code>#register()</code> 方法，实现向 Eureka-Server 注册应用实例。<strong>其他方法代码类似</strong>。<ul><li>调用 <code>#execute(...)</code> 方法，并将原有的注册实现通过 RequestExecutor 传递进去。</li><li>子类在实现的 <code>#execute(...)</code> 方法，可以调用 <code>RequestExecutor#execute(...)</code> 方法，继续执行原有逻辑。</li><li>参考设计模式：<a href="http://blog.csdn.net/hguisu/article/details/7564039" rel="external nofollow noopener noreferrer" target="_blank">《设计模式 ( 十九 ) 模板方法模式Template method（类行为型）》</a> 。</li></ul></li><li><p>RequestType ，请求类型<strong>枚举类</strong>。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClientDecorator.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</div><div class="line">   Register,</div><div class="line">   Cancel,</div><div class="line">   SendHeartBeat,</div><div class="line">   StatusUpdate,</div><div class="line">   DeleteStatusOverride,</div><div class="line">   GetApplications,</div><div class="line">   GetDelta,</div><div class="line">   GetVip,</div><div class="line">   GetSecureVip,</div><div class="line">   GetApplication,</div><div class="line">   GetInstance,</div><div class="line">   GetApplicationInstance</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>RequestExecutor ，请求执行器<strong>接口</strong>。接口代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClientDecorator.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestExecutor</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 执行请求</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> delegate 委托的 EurekaHttpClient</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 响应</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 请求类型</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function">RequestType <span class="title">getRequestType</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p>EurekaHttpClientDecorator 的<strong>每个实现类实现一个特性</strong>，代码非常非常非常清晰。</p><blockquote><p>FROM <a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">《委托模式》</a><br>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。</p></blockquote><p>我们在上图的基础上，<strong>增加委托的关系</strong>，如下图( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/03.jpeg">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/03.jpeg" alt=""></p><ul><li>请注意，每个委托着实现类，上面可能有类型为 EurekaHttpClientFactory 的属性，用于创建其委托的 EurekaHttpClient 。<strong>为什么会有 Factory</strong> ？例如，RetryableEurekaHttpClient 重试请求多个 Eureka-Server 地址时，每个 Eureka-Server 地址会创建一个 EurekaHttpClient 。所以，下文涉及到 EurekaHttpClientFactory 和<strong>委托的</strong> EurekaHttpClient 的地方，你都需要仔细理解。</li></ul><h2 id="5-1-MetricsCollectingEurekaHttpClient"><a href="#5-1-MetricsCollectingEurekaHttpClient" class="headerlink" title="5.1 MetricsCollectingEurekaHttpClient"></a>5.1 MetricsCollectingEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient</code> ，监控指标收集 EurekaHttpClient ，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p><p><code>#execute()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 获得 请求类型 的 请求指标</span></div><div class="line"> <span class="number">4</span>:     EurekaHttpClientRequestMetrics requestMetrics = metricsByRequestType.get(requestExecutor.getRequestType());</div><div class="line"> <span class="number">5</span>:     Stopwatch stopwatch = requestMetrics.latencyTimer.start();</div><div class="line"> <span class="number">6</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 执行请求</span></div><div class="line"> <span class="number">8</span>:         EurekaHttpResponse&lt;R&gt; httpResponse = requestExecutor.execute(delegate);</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 增加 请求指标</span></div><div class="line"><span class="number">10</span>:         requestMetrics.countersByStatus.get(mappedStatus(httpResponse)).increment();</div><div class="line"><span class="number">11</span>:         <span class="keyword">return</span> httpResponse;</div><div class="line"><span class="number">12</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">13</span>:         requestMetrics.connectionErrors.increment();</div><div class="line"><span class="number">14</span>:         exceptionsMetric.count(e);</div><div class="line"><span class="number">15</span>:         <span class="keyword">throw</span> e;</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">17</span>:         stopwatch.stop();</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ：调用 <code>RequestExecutor#execute(...)</code> 方法，继续执行请求。<ul><li><code>delegate</code> 属性，对应 JerseyApplicationClient 。</li></ul></li></ul><h2 id="5-2-RedirectingEurekaHttpClient"><a href="#5-2-RedirectingEurekaHttpClient" class="headerlink" title="5.2 RedirectingEurekaHttpClient"></a>5.2 RedirectingEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient</code> ，<strong>寻找非 302 重定向</strong>的 Eureka-Server 的 EurekaHttpClient 。</p><p><code>#execute()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     EurekaHttpClient currentEurekaClient = delegateRef.get();</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (currentEurekaClient == <span class="keyword">null</span>) &#123; <span class="comment">// 未找到非 302 的 Eureka-Server</span></div><div class="line"> <span class="number">5</span>:         AtomicReference&lt;EurekaHttpClient&gt; currentEurekaClientRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(factory.newClient(serviceEndpoint));</div><div class="line"> <span class="number">6</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:             EurekaHttpResponse&lt;R&gt; response = executeOnNewServer(requestExecutor, currentEurekaClientRef);</div><div class="line"> <span class="number">8</span>:             <span class="comment">// 关闭原有的委托 EurekaHttpClient ，并设置当前成功非 302 请求的 EurekaHttpClient</span></div><div class="line"> <span class="number">9</span>:             TransportUtils.shutdown(delegateRef.getAndSet(currentEurekaClientRef.get()));</div><div class="line"><span class="number">10</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">11</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">12</span>:             logger.error(<span class="string">"Request execution error"</span>, e);</div><div class="line"><span class="number">13</span>:             TransportUtils.shutdown(currentEurekaClientRef.get());</div><div class="line"><span class="number">14</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 已经找到非 302 的 Eureka-Server</span></div><div class="line"><span class="number">17</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">return</span> requestExecutor.execute(currentEurekaClient);</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">20</span>:             logger.error(<span class="string">"Request execution error"</span>, e);</div><div class="line"><span class="number">21</span>:             delegateRef.compareAndSet(currentEurekaClient, <span class="keyword">null</span>);</div><div class="line"><span class="number">22</span>:             currentEurekaClient.shutdown();</div><div class="line"><span class="number">23</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>：和我们理解的常规的 302 状态返回处理不同！！！</li><li>整个分成两部分：【第 4 至 15 行】、【第 16 至 24 行】。<ul><li>前者，意味着未找到非返回 302 状态码的 Eureka-Server ，此时通过在原始传递进来的 <code>serviceUrls</code> 执行请求，寻找非 302 状态码返回的 Eureka-Server。<ul><li>当返回非 302 状态码时，找到非返回 302 状态码的 Eureka-Server 。</li><li>当返回 302 状态码时，向新的重定向的 Eureka-Server 执行请求直到成功找到或超过最大次数。<ul><li>后者，意味着当前已经找到非返回 302 状态码的 Eureka-Server ，直接执行请求。<strong>注意</strong> ：此时 Eureka-Server 再返回 302 状态码，不再处理。</li><li>目前 Eureka 1.x 的 Eureka-Server 不存在返回 302 状态码，猜测和 Eureka 2.X TODO[0028]：写入集群和读取集群 有关。</li></ul></li></ul></li></ul></li><li>【前者】第 5 行 ：使用初始的 <code>serviceEndpoint</code> ( 相当于 <code>serviceUrls</code> ) 创建<strong>委托</strong> EurekaHttpClient 。</li><li>【前者】第 7 行 ：调用 <code>#executeOnNewServer(...)</code> 方法，通过执行请求的方式，寻找非 302 状态码返回的 Eureka-Server。实现代码，点击 <a href="https://github.com/YunaiV/eureka/blob/ed9a4241e60e3b558f939754f71188d3063771e2/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RedirectingEurekaHttpClient.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的代码实现。</li><li>【前者】【前者】第 9 行 ：关闭原有的 <code>delegateRef</code> ( 因为此处可能存在并发，多个线程都找到非 302 状态码返回的 Eureka-Server )，并设置当前成功非 302 请求的 EurekaHttpClient 到 <code>delegateRef</code>。</li><li>【前者】第 13 行 ：关闭 <code>currentEurekaClientRef</code> ，当请求发生异常或者超过最大重定向次数。</li><li>【后者】第 18 行 ：意味着当前已经找到非返回 302 状态码的 Eureka-Server ，直接执行请求。</li><li>【后者】第 21 至 22 行 ：执行请求发生异常，关闭 <code>currentEurekaClient</code> ，后面要重新非返回 302 状态码的 Eureka-Server 。</li></ul><h3 id="5-2-1-工厂"><a href="#5-2-1-工厂" class="headerlink" title="5.2.1 工厂"></a>5.2.1 工厂</h3><p>RedirectingEurekaHttpClient 提供 <code>#createFactory(...)</code> <strong>静态方法</strong>获得创建其的工厂，点击 <a href="https://github.com/YunaiV/eureka/blob/ed9a4241e60e3b558f939754f71188d3063771e2/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RedirectingEurekaHttpClient.java#L96" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2 id="5-3-RetryableEurekaHttpClient"><a href="#5-3-RetryableEurekaHttpClient" class="headerlink" title="5.3 RetryableEurekaHttpClient"></a>5.3 RetryableEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient</code> ，支持向多个 Eureka-Server 请求重试的 EurekaHttpClient 。</p><p><code>#execute()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     List&lt;EurekaEndpoint&gt; candidateHosts = <span class="keyword">null</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> endpointIdx = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123;</div><div class="line"> <span class="number">6</span>:         EurekaHttpClient currentHttpClient = delegate.get();</div><div class="line"> <span class="number">7</span>:         EurekaEndpoint currentEndpoint = <span class="keyword">null</span>;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:         <span class="comment">// 当前委托的 EurekaHttpClient 不存在</span></div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (currentHttpClient == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">11</span>:             <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">if</span> (candidateHosts == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">13</span>:                 candidateHosts = getHostCandidates();</div><div class="line"><span class="number">14</span>:                 <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</div><div class="line"><span class="number">15</span>:                     <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"There is no known eureka server; cluster server list is empty"</span>);</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:             <span class="comment">// 超过候选的 Eureka-Server 地址数组上限</span></div><div class="line"><span class="number">20</span>:             <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"Cannot execute request on any known server"</span>);</div><div class="line"><span class="number">22</span>:             &#125;</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:             <span class="comment">// 创建候选的 EurekaHttpClient</span></div><div class="line"><span class="number">25</span>:             currentEndpoint = candidateHosts.get(endpointIdx++);</div><div class="line"><span class="number">26</span>:             currentHttpClient = clientFactory.newClient(currentEndpoint);</div><div class="line"><span class="number">27</span>:         &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">30</span>:             <span class="comment">// 执行请求</span></div><div class="line"><span class="number">31</span>:             EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</div><div class="line"><span class="number">32</span>:             <span class="comment">// 判断是否为可接受的相应，若是，返回。</span></div><div class="line"><span class="number">33</span>:             <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</div><div class="line"><span class="number">34</span>:                 delegate.set(currentHttpClient);</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:                     logger.info(<span class="string">"Request execution succeeded on retry #&#123;&#125;"</span>, retry);</div><div class="line"><span class="number">37</span>:                 &#125;</div><div class="line"><span class="number">38</span>:                 <span class="keyword">return</span> response;</div><div class="line"><span class="number">39</span>:             &#125;</div><div class="line"><span class="number">40</span>:             logger.warn(<span class="string">"Request execution failure with status code &#123;&#125;; retrying on another server if available"</span>, response.getStatusCode());</div><div class="line"><span class="number">41</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">42</span>:             logger.warn(<span class="string">"Request execution failed with message: &#123;&#125;"</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></div><div class="line"><span class="number">43</span>:         &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:         <span class="comment">// 请求失败，若是 currentHttpClient ，清除 delegate</span></div><div class="line"><span class="number">46</span>:         <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></div><div class="line"><span class="number">47</span>:         delegate.compareAndSet(currentHttpClient, <span class="keyword">null</span>);</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:         <span class="comment">// 请求失败，将 currentEndpoint 添加到隔离集合</span></div><div class="line"><span class="number">50</span>:         <span class="keyword">if</span> (currentEndpoint != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">51</span>:             quarantineSet.add(currentEndpoint);</div><div class="line"><span class="number">52</span>:         &#125;</div><div class="line"><span class="number">53</span>:     &#125;</div><div class="line"><span class="number">54</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"Retry limit reached; giving up on completing the request"</span>);</div><div class="line"><span class="number">55</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ：当前 <code>currentHttpClient</code> 不存在，意味着原有 <code>delegate</code> 不存在向 Eureka-Server 成功请求的 EurekaHttpClient 。<ul><li>此时需要从配置中的 Eureka-Server 数组重试请求，获得可以请求的 Eureka-Server 。</li><li>如果已经存在请求成功的 <code>delegate</code> ，直接使用它进行执行请求。</li></ul></li><li><p>第 11 至 17 行 ：调用 <code>#getHostCandidates()</code> 方法，获得候选的 Eureka-Server <code>serviceUrls</code> 数组。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> List&lt;EurekaEndpoint&gt; <span class="title">getHostCandidates</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></div><div class="line"> <span class="number">3</span>:     List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints();</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">// 保留交集（移除 quarantineSet 不在 candidateHosts 的元素）</span></div><div class="line"> <span class="number">6</span>:     quarantineSet.retainAll(candidateHosts);</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">// 在保证最小可用的候选的 Eureka-Server 地址数组，移除在隔离集合内的元素</span></div><div class="line"> <span class="number">9</span>:     <span class="comment">// If enough hosts are bad, we have no choice but start over again</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">int</span> threshold = (<span class="keyword">int</span>) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); <span class="comment">// 0.66</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (quarantineSet.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// no-op</span></div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (quarantineSet.size() &gt;= threshold) &#123;</div><div class="line"><span class="number">14</span>:         logger.debug(<span class="string">"Clearing quarantined list of size &#123;&#125;"</span>, quarantineSet.size());</div><div class="line"><span class="number">15</span>:         quarantineSet.clear();</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">17</span>:         List&lt;EurekaEndpoint&gt; remainingHosts = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateHosts.size());</div><div class="line"><span class="number">18</span>:         <span class="keyword">for</span> (EurekaEndpoint endpoint : candidateHosts) &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (!quarantineSet.contains(endpoint)) &#123;</div><div class="line"><span class="number">20</span>:                 remainingHosts.add(endpoint);</div><div class="line"><span class="number">21</span>:             &#125;</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:         candidateHosts = remainingHosts;</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:     <span class="keyword">return</span> candidateHosts;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 行 ：调用 <code>ClusterResolver#getClusterEndpoints()</code> 方法，获得候选的 Eureka-Server 地址数组( <code>candidateHosts</code> )。<strong>注意</strong>：该方法返回的 Eureka-Server 地址数组，使用以本机 IP 为<strong>随机种子</strong>，达到不同 IP 的应用实例获得的数组顺序不同，而相同 IP 的应用实例获得的数组顺序一致，<strong>效果类似基于 IP HASH 的负载均衡算法</strong>。实现该功能的代码，在 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》搜索关键字【ResolverUtils#randomize(…)】</a> 详细解析。</li><li>第 6 行 ：调用 <code>Set#retainAll()</code> 方法，移除隔离的故障 Eureka-Server 地址数组( <code>quarantineSet</code> ) 中不在 <code>candidateHosts</code> 的元素。</li><li>第 8 至 24 行 ：在保证最小可用的 <code>candidateHosts</code>，移除在 <code>quarantineSet</code> 的元素。<ul><li>第 10 行 ：最小可用的阀值，配置 <code>eureka.retryableClientQuarantineRefreshPercentage</code> 来设置百分比，默认值：<code>0.66</code> 。</li><li>最 13 至 15 行 ：<code>quarantineSet</code> 数量超过阀值，清空 <code>quarantineSet</code> ，全部 <code>candidateHosts</code> 重试。</li><li>第 17 至 24 行 ：<code>quarantineSet</code> 数量未超过阀值，移除 <code>candidateHosts</code> 中在 <code>quarantineSet</code> 的元素。</li></ul></li></ul></li><li><p>第 19 至 22 行 ：超过 <code>candidateHosts</code> 上限，全部 Eureka-Server 请求失败，抛出异常。</p></li><li>第 24 至 26 行 ：创建委托的 EurekaHttpClient ，用于下面请求执行。</li><li>第 31 行 ：执行请求。</li><li><p>第 33 行 ：调用 <code>ServerStatusEvaluator#accept()</code> 方法，判断响应状态码和请求类型是否能够接受。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerStatusEvaluators.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServerStatusEvaluator LEGACY_EVALUATOR = <span class="keyword">new</span> ServerStatusEvaluator() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> statusCode, RequestType requestType)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">300</span> || statusCode == <span class="number">302</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.Register &amp;&amp; statusCode == <span class="number">404</span>) &#123; <span class="comment">// 注册，404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.SendHeartBeat &amp;&amp; statusCode == <span class="number">404</span>) &#123; <span class="comment">// 心跳，404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.Cancel) &#123;  <span class="comment">// cancel is best effort 下线，接受全部</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.GetDelta &amp;&amp; (statusCode == <span class="number">403</span> || statusCode == <span class="number">404</span>)) &#123; <span class="comment">// 增量获取注册信息，403 404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>第 34 行 ：请求成功，设置 <code>delegate</code> 。下次请求，优先使用 <code>delegate</code> ，失败才进行候选的 Eureka-Server 地址数组重试。</p></li><li>第 47 行 ：请求失败，<code>delegate</code> 若等于 <code>currentHttpClient</code> ，进行清除。</li><li>第 50 至 52 行 ：请求失败，将请求的 Eureka-Server 地址添加到 <code>quarantineSet</code> 。</li><li>总结来说：<ul><li>【第一步】若当前有请求成功的 EurekaHttpClient ，继续使用。若请求失败，执行【第二步】。</li><li>【第二步】若当前无请求成功的 EurekaHttpClient ，获取候选的 Eureka-Server 地址数组<strong>顺序</strong>创建新的 EurekaHttpClient，直到成功，或者超过最大重试次数。当请求成功，保存该 EurekaHttpClient ，下次继续使用，直到请求失败。</li></ul></li></ul><h3 id="5-3-1-工厂"><a href="#5-3-1-工厂" class="headerlink" title="5.3.1 工厂"></a>5.3.1 工厂</h3><p>RetryableEurekaHttpClient 提供 <code>#createFactory(...)</code> <strong>静态方法</strong>获得创建其的工厂，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RetryableEurekaHttpClient.java#L135" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2 id="5-4-SessionedEurekaHttpClient"><a href="#5-4-SessionedEurekaHttpClient" class="headerlink" title="5.4 SessionedEurekaHttpClient"></a>5.4 SessionedEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient</code> ，支持会话的 EurekaHttpClient 。执行定期的重建会话，防止一个 Eureka-Client 永远只连接一个特定的 Eureka-Server 。反过来，这也保证了 Eureka-Server 集群变更时，Eureka-Client 对 Eureka-Server 连接的负载均衡。</p><p><code>#execute(...)</code> ，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">4</span>:     <span class="keyword">long</span> delay = now - lastReconnectTimeStamp;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// 超过 当前会话时间，关闭当前委托的 EurekaHttpClient 。</span></div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (delay &gt;= currentSessionDurationMs) &#123;</div><div class="line"> <span class="number">8</span>:         logger.debug(<span class="string">"Ending a session and starting anew"</span>);</div><div class="line"> <span class="number">9</span>:         lastReconnectTimeStamp = now;</div><div class="line"><span class="number">10</span>:         currentSessionDurationMs = randomizeSessionDuration(sessionDurationMs);</div><div class="line"><span class="number">11</span>:         TransportUtils.shutdown(eurekaHttpClientRef.getAndSet(<span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="comment">// 获得委托的 EurekaHttpClient 。若不存在，则创建新的委托的 EurekaHttpClient 。</span></div><div class="line"><span class="number">15</span>:     EurekaHttpClient eurekaHttpClient = eurekaHttpClientRef.get();</div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (eurekaHttpClient == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">17</span>:         eurekaHttpClient = TransportUtils.getOrSetAnotherClient(eurekaHttpClientRef, clientFactory.newClient());</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>:     <span class="keyword">return</span> requestExecutor.execute(eurekaHttpClient);</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 7 至 12 行 ：超过当前会话时间，关闭当前委托的 EurekaHttpClient 。</p><ul><li><p>第 10 行 ：调用 <code>#randomizeSessionDuration(...)</code> 方法，计算计算下一次会话超时时长，公式为 <code>sessionDurationMs * (0.5, 1.5)</code> ，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">randomizeSessionDuration</span><span class="params">(<span class="keyword">long</span> sessionDurationMs)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> delta = (<span class="keyword">long</span>) (sessionDurationMs * (random.nextDouble() - <span class="number">0.5</span>));</div><div class="line">   <span class="keyword">return</span> sessionDurationMs + delta;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>TODO[0029]：为啥随机</li></ul></li></ul></li><li><p>第 15 至 18 行 ：获得委托的 EurekaHttpClient 。若不存在，创建新的委托的 EurekaHttpClient 。<code>TransportUtils#getOrSetAnotherClient(...)</code> 方法代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClient <span class="title">getOrSetAnotherClient</span><span class="params">(AtomicReference&lt;EurekaHttpClient&gt; eurekaHttpClientRef, EurekaHttpClient another)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     EurekaHttpClient existing = eurekaHttpClientRef.get();</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 为空才设置</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (eurekaHttpClientRef.compareAndSet(<span class="keyword">null</span>, another)) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> another;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 设置失败，意味着另外一个线程已经设置</span></div><div class="line"> <span class="number">8</span>:     another.shutdown();</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> existing;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure><ul><li>该方法实现，获得 <code>eurekaHttpClientRef</code> 里的 EurekaHttpClient 。若获取不到，将 <code>another</code> 设置到 <code>eurekaHttpClientRef</code> 。当有多个线程设置时，有且只有一个线程设置成功，另外的设置失败的线程们，意味着当前 <code>eurekaHttpClientRef</code> 有 EurekaHttpClient ，返回 <code>eurekaHttpClientRef</code> 。</li><li><p>目前该方法存在 BUG ，失败的线程直接返回 <code>existing</code> 的是 <code>null</code> ，需要修改成 <code>return eurekaHttpClientRef.get()</code> 。模拟重现该 BUG 代码如下 ：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_07_31/04.png" alt=""></p></li></ul></li><li><p>第 19 行 ：执行请求。</p></li></ul><h3 id="5-4-1-没有工厂"><a href="#5-4-1-没有工厂" class="headerlink" title="5.4.1 没有工厂"></a>5.4.1 没有工厂</h3><p>在 SessionedEurekaHttpClient 类里，没有实现创建其的工厂。在 <a href="#">「6. 创建网络通讯客户端」搜索 <code>canonicalClientFactory</code></a> ，可以看到 <code>EurekaHttpClients#canonicalClientFactory(...)</code> 方法，内部有 SessionedEurekaHttpClient 的创建工厂。</p><h1 id="6-创建网络通讯客户端"><a href="#6-创建网络通讯客户端" class="headerlink" title="6. 创建网络通讯客户端"></a>6. 创建网络通讯客户端</h1><p>对于 Eureka-Server 来说，调用 <code>JerseyReplicationClient#createReplicationClient(...)</code> <strong>静态方法</strong>即可创建用于 Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信客户端。</p><p>对于 Eureka-Client 来说，分成用于<strong>注册应用实例( <code>registrationClient</code> )</strong>和<strong>查询注册信息( <code>newQueryClient</code> )</strong>的<strong>两个不同</strong>网络通信客户端。在 DiscoveryClient 初始化时进行创建，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.class</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="number">2</span>:                                         AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:         </div><div class="line">  <span class="number">4</span>:     Collection&lt;?&gt; additionalFilters = args == <span class="keyword">null</span></div><div class="line">  <span class="number">5</span>:             ? Collections.emptyList()</div><div class="line">  <span class="number">6</span>:             : args.additionalFilters;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:     EurekaJerseyClient providedJerseyClient = args == <span class="keyword">null</span></div><div class="line">  <span class="number">9</span>:             ? <span class="keyword">null</span></div><div class="line"> <span class="number">10</span>:             : args.eurekaJerseyClient;</div><div class="line"> <span class="number">11</span>:     </div><div class="line"> <span class="number">12</span>:     TransportClientFactories argsTransportClientFactories = <span class="keyword">null</span>;</div><div class="line"> <span class="number">13</span>:     <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.getTransportClientFactories() != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:         argsTransportClientFactories = args.getTransportClientFactories();</div><div class="line"> <span class="number">15</span>:     &#125;</div><div class="line"> <span class="number">16</span>:     </div><div class="line"> <span class="number">17</span>:     <span class="comment">// Ignore the raw types warnings since the client filter interface changed between jersey 1/2</span></div><div class="line"> <span class="number">18</span>:     <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"> <span class="number">19</span>:     TransportClientFactories transportClientFactories = argsTransportClientFactories == <span class="keyword">null</span></div><div class="line"> <span class="number">20</span>:             ? <span class="keyword">new</span> Jersey1TransportClientFactories()</div><div class="line"> <span class="number">21</span>:             : argsTransportClientFactories;</div><div class="line"> <span class="number">22</span>: </div><div class="line"> <span class="number">23</span>:     <span class="comment">// If the transport factory was not supplied with args, assume they are using jersey 1 for passivity</span></div><div class="line"> <span class="number">24</span>:     <span class="comment">// noinspection unchecked</span></div><div class="line"> <span class="number">25</span>:     eurekaTransport.transportClientFactory = providedJerseyClient == <span class="keyword">null</span></div><div class="line"> <span class="number">26</span>:             ? transportClientFactories.newTransportClientFactory(clientConfig, additionalFilters, applicationInfoManager.getInfo())</div><div class="line"> <span class="number">27</span>:             : transportClientFactories.newTransportClientFactory(additionalFilters, providedJerseyClient);</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:     <span class="comment">// （省略代码）初始化 应用解析器的应用实例数据源 TODO[0028]写入集群和读取集群</span></div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:     <span class="comment">// （省略代码）创建 EndPoint 解析器</span></div><div class="line"> <span class="number">32</span>:     eurekaTransport.bootstrapResolver = EurekaHttpClients.newBootstrapResolver(...)</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:     <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line"> <span class="number">35</span>:         EurekaHttpClientFactory newRegistrationClientFactory = <span class="keyword">null</span>;</div><div class="line"> <span class="number">36</span>:         EurekaHttpClient newRegistrationClient = <span class="keyword">null</span>;</div><div class="line"> <span class="number">37</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">38</span>:             newRegistrationClientFactory = EurekaHttpClients.registrationClientFactory(</div><div class="line"> <span class="number">39</span>:                     eurekaTransport.bootstrapResolver,</div><div class="line"> <span class="number">40</span>:                     eurekaTransport.transportClientFactory,</div><div class="line"> <span class="number">41</span>:                     transportConfig</div><div class="line"> <span class="number">42</span>:             );</div><div class="line"> <span class="number">43</span>:             newRegistrationClient = newRegistrationClientFactory.newClient();</div><div class="line"> <span class="number">44</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">45</span>:             logger.warn(<span class="string">"Transport initialization failure"</span>, e);</div><div class="line"> <span class="number">46</span>:         &#125;</div><div class="line"> <span class="number">47</span>:         eurekaTransport.registrationClientFactory = newRegistrationClientFactory;</div><div class="line"> <span class="number">48</span>:         eurekaTransport.registrationClient = newRegistrationClient;</div><div class="line"> <span class="number">49</span>:     &#125;</div><div class="line"> <span class="number">50</span>: </div><div class="line"> <span class="number">51</span>:     <span class="comment">// new method (resolve from primary servers for read)</span></div><div class="line"> <span class="number">52</span>:     <span class="comment">// Configure new transport layer (candidate for injecting in the future)</span></div><div class="line"> <span class="number">53</span>:     <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line"> <span class="number">54</span>:         EurekaHttpClientFactory newQueryClientFactory = <span class="keyword">null</span>;</div><div class="line"> <span class="number">55</span>:         EurekaHttpClient newQueryClient = <span class="keyword">null</span>;</div><div class="line"> <span class="number">56</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">57</span>:             newQueryClientFactory = EurekaHttpClients.queryClientFactory(</div><div class="line"> <span class="number">58</span>:                     eurekaTransport.bootstrapResolver,</div><div class="line"> <span class="number">59</span>:                     eurekaTransport.transportClientFactory,</div><div class="line"> <span class="number">60</span>:                     clientConfig,</div><div class="line"> <span class="number">61</span>:                     transportConfig,</div><div class="line"> <span class="number">62</span>:                     applicationInfoManager.getInfo(),</div><div class="line"> <span class="number">63</span>:                     applicationsSource</div><div class="line"> <span class="number">64</span>:             );</div><div class="line"> <span class="number">65</span>:             newQueryClient = newQueryClientFactory.newClient();</div><div class="line"> <span class="number">66</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">67</span>:             logger.warn(<span class="string">"Transport initialization failure"</span>, e);</div><div class="line"> <span class="number">68</span>:         &#125;</div><div class="line"> <span class="number">69</span>:         eurekaTransport.queryClientFactory = newQueryClientFactory;</div><div class="line"> <span class="number">70</span>:         eurekaTransport.queryClient = newQueryClient;</div><div class="line"> <span class="number">71</span>:     &#125;</div><div class="line"> <span class="number">72</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 18 至 27 行 ：调用 <code>Jersey1TransportClientFactories#newTransportClientFactory(...)</code> 方法，创建 <code>registrationClient</code> 和 <code>queryClient</code> 公用的委托的 EurekaHttpClientFactory ，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Jersey1TransportClientFactories.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> Collection&lt;ClientFilter&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line">   <span class="comment">// JerseyEurekaHttpClientFactory</span></div><div class="line">   <span class="keyword">final</span> TransportClientFactory jerseyFactory = JerseyEurekaHttpClientFactory.create(</div><div class="line">           clientConfig,</div><div class="line">           additionalFilters,</div><div class="line">           myInstanceInfo,</div><div class="line">           <span class="keyword">new</span> EurekaClientIdentity(myInstanceInfo.getIPAddr())</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// TransportClientFactory</span></div><div class="line">   <span class="keyword">final</span> TransportClientFactory metricsFactory = MetricsCollectingEurekaHttpClient.createFactory(jerseyFactory); <span class="comment">// 委托 TransportClientFactory</span></div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TransportClientFactory() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> metricsFactory.newClient(serviceUrl);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">           metricsFactory.shutdown();</div><div class="line">           jerseyFactory.shutdown();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 TransportClientFactory 里<strong>委托</strong> JerseyEurekaHttpClientFactory 。</li></ul></li><li><p>第 34 至 49 行 ：调用 <code>EurekaHttpClients#registrationClientFactory(...)</code> 方法，创建 <code>registrationClient</code> 的 EurekaHttpClientFactory ，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClients.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">registrationClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                                TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params">                                                                EurekaTransportConfig transportConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> EurekaHttpClientFactory <span class="title">canonicalClientFactory</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> TransportClientFactory transportClientFactory)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> EurekaHttpClientFactory() &#123; <span class="comment">// SessionedEurekaHttpClientFactory</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SessionedEurekaHttpClient(</div><div class="line">                   name,</div><div class="line">                   RetryableEurekaHttpClient.createFactory( <span class="comment">// RetryableEurekaHttpClient</span></div><div class="line">                           name,</div><div class="line">                           transportConfig,</div><div class="line">                           clusterResolver,</div><div class="line">                           RedirectingEurekaHttpClient.createFactory(transportClientFactory), <span class="comment">// RedirectingEurekaHttpClient</span></div><div class="line">                           ServerStatusEvaluators.legacyEvaluator()),</div><div class="line">                   transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="number">1000</span></div><div class="line">           );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">           wrapClosable(clusterResolver).shutdown();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 51 至 71 行 ：调用 <code>EurekaHttpClients#queryClientFactory(...)</code> 方法，创建 <code>queryClient</code> 的 EurekaHttpClientFactory ，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClients.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">queryClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                        TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params">                                                        EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                        EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                        InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                                        ApplicationsResolver.ApplicationsSource applicationsSource)</span> </span>&#123;</div><div class="line"></div><div class="line">   ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery()</div><div class="line">           ? wrapClosable(bootstrapResolver)</div><div class="line">           : queryClientResolver(bootstrapResolver, transportClientFactory,</div><div class="line">           clientConfig, transportConfig, myInstanceInfo, applicationsSource);</div><div class="line">   <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory); <span class="comment">// 该方法上面有</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>这次真的是彩蛋，我们将整体调用关系调整如下如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/05.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/05.png" alt=""></p><p>胖友，你学会了么？</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/transport/&quot;&gt;http://www.iocoder.cn/Eureka/transport/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— EndPoint 与 解析器</title>
    <link href="http://www.iocoder.cn/Eureka/end-point-and-resolver/"/>
    <id>http://www.iocoder.cn/Eureka/end-point-and-resolver/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2017-10-16T11:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">http://www.iocoder.cn/Eureka/end-point-and-resolver/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2. EndPoint</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.1 EurekaEndpoint</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.2 DefaultEndpoint</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.3 AwsEndpoint</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3. 解析器</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.1 ClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.2 ClosableResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.3 DnsTxtRecordClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.4 ConfigClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.5 ZoneAffinityClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6 AsyncResolver</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6.1 定时任务</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6.2 解析 EndPoint 集群</a></li></ul></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">4. 初始化解析器</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>EndPoint 与 解析器</strong>。</p><ul><li>EndPoint ，服务端点。例如，Eureka-Server 的访问地址。</li><li>EndPoint 解析器，将配置的 Eureka-Server 的访问地址解析成 EndPoint 。</li></ul><p>目前有多种 Eureka-Server 访问地址的配置方式，<strong>本文只分享 Eureka 1.x 的配置</strong>，不包含 Eureka 1.x 对 Eureka 2.x 的兼容配置：</p><ul><li>第一种，直接配置实际访问地址。例如，<code>eureka.serviceUrl.defaultZone=http://127.0.0.1:8080/v2</code> 。</li><li>第二种，基于 DNS 解析出访问地址。例如，<code>eureka.shouldUseDns=true</code> 并且  <code>eureka.eurekaServer.domainName=eureka.iocoder.cn</code> 。</li></ul><p>本文涉及类在 <code>com.netflix.discovery.shared.resolver</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_24/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/01.png" alt=""></p><ul><li>红色部分 —— EndPoint</li><li>黄色部分 —— EndPoint 解析器</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EndPoint"><a href="#2-EndPoint" class="headerlink" title="2. EndPoint"></a>2. EndPoint</h1><h2 id="2-1-EurekaEndpoint"><a href="#2-1-EurekaEndpoint" class="headerlink" title="2.1 EurekaEndpoint"></a>2.1 EurekaEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.EurekaEndpoint</code> ，Eureka 服务端点<strong>接口</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEndpoint</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 完整的服务 URL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getServiceUrl</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@deprecated</span> use &#123;<span class="doctag">@link</span> #getNetworkAddress()&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function">String <span class="title">getHostName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 网络地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getNetworkAddress</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否安全( https )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 相对路径</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getRelativeUri</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-DefaultEndpoint"><a href="#2-2-DefaultEndpoint" class="headerlink" title="2.2 DefaultEndpoint"></a>2.2 DefaultEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.DefaultEndpoint</code> ，默认 Eureka 服务端点<strong>实现类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEndpoint</span> <span class="keyword">implements</span> <span class="title">EurekaEndpoint</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String networkAddress;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否安全( https )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSecure;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相对地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String relativeUri;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 完整的服务 URL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEndpoint</span><span class="params">(String serviceUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl;</div><div class="line"></div><div class="line">        <span class="comment">// 将 serviceUrl 分解成 几个属性</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL url = <span class="keyword">new</span> URL(serviceUrl);</div><div class="line">            <span class="keyword">this</span>.networkAddress = url.getHost();</div><div class="line">            <span class="keyword">this</span>.port = url.getPort();</div><div class="line">            <span class="keyword">this</span>.isSecure = <span class="string">"https"</span>.equals(url.getProtocol());</div><div class="line">            <span class="keyword">this</span>.relativeUri = url.getPath();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Malformed serviceUrl: "</span> + serviceUrl);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEndpoint</span><span class="params">(String networkAddress, <span class="keyword">int</span> port, <span class="keyword">boolean</span> isSecure, String relativeUri)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.networkAddress = networkAddress;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">        <span class="keyword">this</span>.isSecure = isSecure;</div><div class="line">        <span class="keyword">this</span>.relativeUri = relativeUri;</div><div class="line"></div><div class="line">        <span class="comment">// 几个属性 拼接成 serviceUrl</span></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder().append(isSecure ? <span class="string">"https"</span> : <span class="string">"http"</span>).append(<span class="string">"://"</span>).append(networkAddress);</div><div class="line"><span class="keyword">if</span> (port &gt;= <span class="number">0</span>) &#123;</div><div class="line">sb.append(<span class="string">':'</span>).append(port);</div><div class="line">&#125;</div><div class="line">        <span class="keyword">if</span> (relativeUri != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!relativeUri.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">                sb.append(<span class="string">'/'</span>);</div><div class="line">            &#125;</div><div class="line">            sb.append(relativeUri);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.serviceUrl = sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>重写了 <code>#equals(...)</code> 和 <code>#hashCode(...)</code> 方法，标准实现方式，这里就不贴代码了。</li><li>重写了 <code>#compareTo(...)</code> 方法，基于 <code>serviceUrl</code> 属性做比较。</li></ul><h2 id="2-3-AwsEndpoint"><a href="#2-3-AwsEndpoint" class="headerlink" title="2.3 AwsEndpoint"></a>2.3 AwsEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.aws.AwsEndpoint</code> ，基于 <code>region</code>、<code>zone</code> 的 Eureka 服务端点<strong>实现类</strong> ( 请不要在意 AWS 开头 )。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwsEndpoint</span> <span class="keyword">extends</span> <span class="title">DefaultEndpoint</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 区域</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String region;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 可用区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String zone;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>重写了 <code>#equals(...)</code> 和 <code>#hashCode(...)</code> 方法，标准实现方式，这里就不贴代码了。</li></ul><h1 id="3-解析器"><a href="#3-解析器" class="headerlink" title="3. 解析器"></a>3. 解析器</h1><p>EndPoint 解析器使用<strong>委托设计模式</strong>实现。所以，上文图片中我们看到好多个解析器，<strong>实际代码非常非常非常清晰</strong>。</p><blockquote><p>FROM <a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">《委托模式》</a><br>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。</p></blockquote><p>我们在上图的基础上，<strong>增加委托的关系</strong>，如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/02.png" alt=""></p><h2 id="3-1-ClusterResolver"><a href="#3-1-ClusterResolver" class="headerlink" title="3.1 ClusterResolver"></a>3.1 ClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.ClusterResolver</code> ，集群解析器<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClusterResolver</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">EurekaEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 地区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getRegion</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> EndPoint 集群( 数组 )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;T&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-ClosableResolver"><a href="#3-2-ClosableResolver" class="headerlink" title="3.2 ClosableResolver"></a>3.2 ClosableResolver</h2><p><code>com.netflix.discovery.shared.resolver.ClosableResolver</code> ，<strong>可关闭</strong>的解析器<strong>接口</strong>，继承自 ClusterResolver <strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClosableResolver</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">EurekaEndpoint</span>&gt; <span class="keyword">extends</span> <span class="title">ClusterResolver</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-3-DnsTxtRecordClusterResolver"><a href="#3-3-DnsTxtRecordClusterResolver" class="headerlink" title="3.3 DnsTxtRecordClusterResolver"></a>3.3 DnsTxtRecordClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.DnsTxtRecordClusterResolver</code> ，基于 DNS <strong>TXT</strong> 记录类型的集群解析器。<strong>类属性</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DnsTxtRecordClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 地区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String region;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 集群根地址，例如 txt.default.eureka.iocoder.cn</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String rootClusterDNS;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否解析可用区( zone )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> extractZoneFromDNS;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否安全</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSecure;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相对地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String relativeUri;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>DnsTxtRecordClusterResolver 通过集群根地址( <code>rootClusterDNS</code> ) 解析出 EndPoint 集群。需要在 DNS 配置<strong>两层</strong>解析记录：</p><ul><li>第一层 ：<ul><li>主机记录 ：格式为 <code>TXT.${REGION}.${自定义二级域名}</code> 。</li><li>记录类型 ：<strong>TXT 记录类型</strong>。</li><li>记录值 ：第二层的<strong>主机记录</strong>。如有多个第二层级，使用<strong>空格</strong>分隔。</li></ul></li><li>第二层：<ul><li>主机记录 ：格式为 <code>TXT.${ZONE}.${自定义二级域名}</code> 或者 <code>${ZONE}.${自定义二级域名}</code>。</li><li>记录类型 ：<strong>TXT 记录类型</strong>。</li><li>记录值 ：EndPoint 的网络地址。如有多个 EndPoint，使用<strong>空格</strong>分隔。<ul><li>举个例子：<br><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/03.png" alt=""></li></ul></li></ul></li></ul></li><li><p><code>rootClusterDNS</code> ，集群根地址。例如：<code>txt.default.eureka.iocoder.cn</code>，其· <code>txt.default.eureka</code> 为 DNS 解析记录的第一层的<strong>主机记录</strong>。</p></li><li><code>region</code> ：地区。需要和 <code>rootClusterDNS</code> 的 <code>${REGION}</code> 一致。</li><li><code>extractZoneFromDNS</code> ：是否解析 DNS 解析记录的第二层级的<strong>主机记录</strong>的 <code>${ZONE}</code> 可用区。</li></ul><hr><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     List&lt;AwsEndpoint&gt; eurekaEndpoints = resolve(region, rootClusterDNS, extractZoneFromDNS, port, isSecure, relativeUri);</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"> <span class="number">5</span>:         logger.debug(<span class="string">"Resolved &#123;&#125; to &#123;&#125;"</span>, rootClusterDNS, eurekaEndpoints);</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">return</span> eurekaEndpoints;</div><div class="line"> <span class="number">8</span>: &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AwsEndpoint&gt; <span class="title">resolve</span><span class="params">(String region, String rootClusterDNS, <span class="keyword">boolean</span> extractZone, <span class="keyword">int</span> port, <span class="keyword">boolean</span> isSecure, String relativeUri)</span> </span>&#123;</div><div class="line"><span class="number">11</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 解析 第一层 DNS 记录</span></div><div class="line"><span class="number">13</span>:         Set&lt;String&gt; zoneDomainNames = resolve(rootClusterDNS);</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (zoneDomainNames.isEmpty()) &#123;</div><div class="line"><span class="number">15</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> ClusterResolverException(<span class="string">"Cannot resolve Eureka cluster addresses; there are no data in TXT record for DN "</span> + rootClusterDNS);</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>:         <span class="comment">// 记录 第二层 DNS 记录</span></div><div class="line"><span class="number">18</span>:         List&lt;AwsEndpoint&gt; endpoints = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (String zoneDomain : zoneDomainNames) &#123;</div><div class="line"><span class="number">20</span>:             String zone = extractZone ? ResolverUtils.extractZoneFromHostName(zoneDomain) : <span class="keyword">null</span>; <span class="comment">// </span></div><div class="line"><span class="number">21</span>:             Set&lt;String&gt; zoneAddresses = resolve(zoneDomain);</div><div class="line"><span class="number">22</span>:             <span class="keyword">for</span> (String address : zoneAddresses) &#123;</div><div class="line"><span class="number">23</span>:                 endpoints.add(<span class="keyword">new</span> AwsEndpoint(address, port, isSecure, relativeUri, region, zone));</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">return</span> endpoints;</div><div class="line"><span class="number">27</span>:     &#125; <span class="keyword">catch</span> (NamingException e) &#123;</div><div class="line"><span class="number">28</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> ClusterResolverException(<span class="string">"Cannot resolve Eureka cluster addresses for root: "</span> + rootClusterDNS, e);</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 12 至 16 行 ：调用 <code>#resolve(rootClusterDNS)</code> 解析<strong>第一层</strong> DNS 记录。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">resolve</span><span class="params">(String rootClusterDNS)</span> <span class="keyword">throws</span> NamingException </span>&#123;</div><div class="line"> <span class="number">2</span>:     Set&lt;String&gt; result;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">4</span>:         result = DnsResolver.getCNamesFromTxtRecord(rootClusterDNS);</div><div class="line"> <span class="number">5</span>:         <span class="comment">// TODO 芋艿：这块是bug，不需要这一段</span></div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!rootClusterDNS.startsWith(<span class="string">"txt."</span>)) &#123;</div><div class="line"> <span class="number">7</span>:             result = DnsResolver.getCNamesFromTxtRecord(<span class="string">"txt."</span> + rootClusterDNS);</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>:     &#125; <span class="keyword">catch</span> (NamingException e) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!rootClusterDNS.startsWith(<span class="string">"txt."</span>)) &#123;</div><div class="line"><span class="number">11</span>:             result = DnsResolver.getCNamesFromTxtRecord(<span class="string">"txt."</span> + rootClusterDNS);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ： 调用 <code>DnsResolver#getCNamesFromTxtRecord(...)</code> 方法，解析 TXT 主机记录。点击<a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java#L126" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看带中文注释的 DnsResolver 的代码，比较解析，笔者就不啰嗦了。</li><li>第 5 至 8 行 ：当传递参数 <code>rootClusterDNS</code> 不以 <code>txt.</code> 开头时，即使第 4 行解析成功，也会报错，此时是个 Eureka 的 BUG 。因此，配置 DNS 解析记录时，主机记录暂时必须以 <code>txt.</code> 开头。</li></ul></li><li><p>第 17 至 25 行 ：循环第一层 DNS 记录的解析结果，进一步解析第二层 DNS 记录。</p><ul><li>第 20 行 ：解析可用区( <code>zone</code> )。</li><li>第 21 行 ：调用 <code>#resolve(rootClusterDNS)</code> 解析<strong>第二层</strong> DNS 记录。 </li></ul></li></ul><h2 id="3-4-ConfigClusterResolver"><a href="#3-4-ConfigClusterResolver" class="headerlink" title="3.4 ConfigClusterResolver"></a>3.4 ConfigClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver</code> ，基于<strong>配置文件</strong>的集群解析器。<strong>类属性</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo myInstanceInfo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClusterResolver</span><span class="params">(EurekaClientConfig clientConfig, InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.myInstanceInfo = myInstanceInfo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 使用 DNS 获取 EndPoint</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line"> <span class="number">6</span>:             logger.info(<span class="string">"Resolving eureka endpoints via DNS: &#123;&#125;"</span>, getDNSName());</div><div class="line"> <span class="number">7</span>:         &#125;</div><div class="line"> <span class="number">8</span>:         <span class="keyword">return</span> getClusterEndpointsFromDns();</div><div class="line"> <span class="number">9</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 直接配置实际访问地址</span></div><div class="line"><span class="number">11</span>:         logger.info(<span class="string">"Resolving eureka endpoints via configuration"</span>);</div><div class="line"><span class="number">12</span>:         <span class="keyword">return</span> getClusterEndpointsFromConfig();</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 3 至 8 行 ：基于 DNS 获取 EndPoint 集群，调用 <code>#getClusterEndpointsFromDns()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpointsFromDns</span><span class="params">()</span> </span>&#123;</div><div class="line">   String discoveryDnsName = getDNSName(); <span class="comment">// 获取 集群根地址</span></div><div class="line">   <span class="keyword">int</span> port = Integer.parseInt(clientConfig.getEurekaServerPort()); <span class="comment">// 端口</span></div><div class="line"></div><div class="line">   <span class="comment">// cheap enough so just re-use</span></div><div class="line">   DnsTxtRecordClusterResolver dnsResolver = <span class="keyword">new</span> DnsTxtRecordClusterResolver(</div><div class="line">           getRegion(),</div><div class="line">           discoveryDnsName,</div><div class="line">           <span class="keyword">true</span>, <span class="comment">// 解析 zone</span></div><div class="line">           port,</div><div class="line">           <span class="keyword">false</span>,</div><div class="line">           clientConfig.getEurekaServerURLContext()</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// 调用 DnsTxtRecordClusterResolver 解析 EndPoint</span></div><div class="line">   List&lt;AwsEndpoint&gt; endpoints = dnsResolver.getClusterEndpoints();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (endpoints.isEmpty()) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot resolve to any endpoints for the given dnsName: &#123;&#125;"</span>, discoveryDnsName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> endpoints;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDNSName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"txt."</span> + getRegion() + <span class="string">'.'</span> + clientConfig.getEurekaServerDNSName();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>必须配置 <code>eureka.shouldUseDns=true</code> ，开启基于 DNS 获取 EndPoint 集群。</li><li>必须配置 <code>eureka.eurekaServer.domainName=${xxxxx}</code> ，配置集群根地址。</li><li>选填配 <code>eureka.eurekaServer.port</code> ，<code>eureka.eurekaServer.context</code> 。</li><li>从代码中我们可以看出，使用 DnsTxtRecordClusterResolver 解析出 EndPoint 集群。</li></ul></li><li><p>第 9 至 13 行 ：直接<strong>配置文件</strong>填写实际 EndPoint 集群，调用 <code>#getClusterEndpointsFromConfig()</code> 方法，实现代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpointsFromConfig</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 可用区</span></div><div class="line"> <span class="number">3</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 获取 应用实例自己 的 可用区</span></div><div class="line"> <span class="number">5</span>:     String myZone = InstanceInfo.getZone(availZones, myInstanceInfo);</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 可用区与 serviceUrls 的映射</span></div><div class="line"> <span class="number">7</span>:     Map&lt;String, List&lt;String&gt;&gt; serviceUrls = EndpointUtils.getServiceUrlsMapFromConfig(clientConfig, myZone, clientConfig.shouldPreferSameZoneEureka());</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 拼装 EndPoint 集群结果</span></div><div class="line"> <span class="number">9</span>:     List&lt;AwsEndpoint&gt; endpoints = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">10</span>:     <span class="keyword">for</span> (String zone : serviceUrls.keySet()) &#123;</div><div class="line"><span class="number">11</span>:         <span class="keyword">for</span> (String url : serviceUrls.get(zone)) &#123;</div><div class="line"><span class="number">12</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">13</span>:                 endpoints.add(<span class="keyword">new</span> AwsEndpoint(url, getRegion(), zone));</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</div><div class="line"><span class="number">15</span>:                 logger.warn(<span class="string">"Invalid eureka server URI: &#123;&#125;; removing from the server pool"</span>, url);</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:     <span class="comment">// 打印日志，EndPoint 集群</span></div><div class="line"><span class="number">21</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">22</span>:         logger.debug(<span class="string">"Config resolved to &#123;&#125;"</span>, endpoints);</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>:     <span class="comment">// 打印日志，解析结果为空</span></div><div class="line"><span class="number">25</span>:     <span class="keyword">if</span> (endpoints.isEmpty()) &#123;</div><div class="line"><span class="number">26</span>:         logger.error(<span class="string">"Cannot resolve to any endpoints from provided configuration: &#123;&#125;"</span>, serviceUrls);</div><div class="line"><span class="number">27</span>:     &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:     <span class="keyword">return</span> endpoints;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 行 ：获得可用区数组。通过 <code>eureka.${REGION}.availabilityZones</code> 配置。</li><li>第 5 行 ：调用 <code>InstanceInfo#getZone(...)</code> 方法，获得<strong>应用实例自己所在的可用区</strong>( <code>zone</code> )。非亚马逊 AWS 环境下，可用区数组的第一个元素就是<strong>应用实例自己所在的可用区</strong>。</li><li><p>第 7 行 ：调用 <code>EndpointUtils#getServiceUrlsMapFromConfig(...)</code> 方法，获得可用区与 <code>serviceUrls</code> 的映射。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EndpointUtils.java</span></div><div class="line">  <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; getServiceUrlsMapFromConfig(EurekaClientConfig clientConfig, String instanceZone, <span class="keyword">boolean</span> preferSameZone) &#123;</div><div class="line">  <span class="number">2</span>:     Map&lt;String, List&lt;String&gt;&gt; orderedUrls = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); <span class="comment">// key：zone；value：serviceUrls</span></div><div class="line">  <span class="number">3</span>:     <span class="comment">// 获得 应用实例的 地区( region )</span></div><div class="line">  <span class="number">4</span>:     String region = getRegion(clientConfig);</div><div class="line">  <span class="number">5</span>:     <span class="comment">// 获得 应用实例的 可用区</span></div><div class="line">  <span class="number">6</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) &#123;</div><div class="line">  <span class="number">8</span>:         availZones = <span class="keyword">new</span> String[<span class="number">1</span>];</div><div class="line">  <span class="number">9</span>:         availZones[<span class="number">0</span>] = DEFAULT_ZONE;</div><div class="line"> <span class="number">10</span>:     &#125;</div><div class="line"> <span class="number">11</span>:     logger.debug(<span class="string">"The availability zone for the given region &#123;&#125; are &#123;&#125;"</span>, region, Arrays.toString(availZones));</div><div class="line"> <span class="number">12</span>:     <span class="comment">// 获得 开始位置</span></div><div class="line"> <span class="number">13</span>:     <span class="keyword">int</span> myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);</div><div class="line"> <span class="number">14</span>:     <span class="comment">// 将 开始位置 的 serviceUrls 添加到结果</span></div><div class="line"> <span class="number">15</span>:     String zone = availZones[myZoneOffset];</div><div class="line"> <span class="number">16</span>:     List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);</div><div class="line"> <span class="number">17</span>:     <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">18</span>:         orderedUrls.put(zone, serviceUrls);</div><div class="line"> <span class="number">19</span>:     &#125;</div><div class="line"> <span class="number">20</span>:     <span class="comment">// 从开始位置顺序遍历剩余的 serviceUrls 添加到结果</span></div><div class="line"> <span class="number">21</span>:     <span class="keyword">int</span> currentOffset = myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</div><div class="line"> <span class="number">22</span>:     <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</div><div class="line"> <span class="number">23</span>:         zone = availZones[currentOffset];</div><div class="line"> <span class="number">24</span>:         serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">26</span>:             orderedUrls.put(zone, serviceUrls);</div><div class="line"> <span class="number">27</span>:         &#125;</div><div class="line"> <span class="number">28</span>:         <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">29</span>:             currentOffset = <span class="number">0</span>;</div><div class="line"> <span class="number">30</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">31</span>:             currentOffset++;</div><div class="line"> <span class="number">32</span>:         &#125;</div><div class="line"> <span class="number">33</span>:     &#125;</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:     <span class="comment">// 为空，报错</span></div><div class="line"> <span class="number">36</span>:     <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</div><div class="line"> <span class="number">37</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DiscoveryClient: invalid serviceUrl specified!"</span>);</div><div class="line"> <span class="number">38</span>:     &#125;</div><div class="line"> <span class="number">39</span>:     <span class="keyword">return</span> orderedUrls;</div><div class="line"> <span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 13 行 ：获得<strong>开始位置</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getZoneOffset</span><span class="params">(String myZone, <span class="keyword">boolean</span> preferSameZone, String[] availZones)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; availZones.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (myZone != <span class="keyword">null</span> &amp;&amp; (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) &#123;</div><div class="line">           <span class="keyword">return</span> i;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   logger.warn(<span class="string">"DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - &#123;&#125;,"</span> +</div><div class="line">           <span class="string">" preferSameZone- &#123;&#125;. Defaulting to "</span> + availZones[<span class="number">0</span>], myZone, preferSameZone);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当方法参数 <code>preferSameZone=true</code> ，即 <code>eureka.preferSameZone=true</code>( 默认值 ：<code>true</code> ) 时，<strong>开始位置</strong>为可用区数组( <code>availZones</code> )的<strong>第一个</strong>和应用实例所在的可用区( <code>myZone</code> )【<strong>相等</strong>】元素的位置。</li><li>当方法参数 <code>preferSameZone=false</code> ，即 <code>eureka.preferSameZone=false</code>( 默认值 ：<code>true</code> ) 时，<strong>开始位置</strong>为可用区数组( <code>availZones</code> )的<strong>第一个</strong>和应用实例所在的可用区( <code>myZone</code> )【<strong>不相等</strong>】元素的位置。</li></ul></li><li><p>第 20 至 33 行 ：从开始位置<strong>顺序</strong>将剩余的可用区的 <code>serviceUrls</code> 添加到结果。<strong>顺序</strong>理解如下图：<br>  <img src="http://www.iocoder.cn/images/Eureka/2018_07_24/04.png" alt=""></p></li></ul></li><li><p>第 9 至 18 行 ：拼装 EndPoint 集群结果。</p></li></ul><h2 id="3-5-ZoneAffinityClusterResolver"><a href="#3-5-ZoneAffinityClusterResolver" class="headerlink" title="3.5 ZoneAffinityClusterResolver"></a>3.5 ZoneAffinityClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.ZoneAffinityClusterResolver</code> ，使用可用区亲和的集群解析器。<strong>类属性</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAffinityClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZoneAffinityClusterResolver.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 委托的解析器</span></div><div class="line"><span class="comment">     * 目前代码里为 &#123;<span class="doctag">@link</span> ConfigClusterResolver&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResolver&lt;AwsEndpoint&gt; delegate;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例的可用区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myZone;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否可用区亲和</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> zoneAffinity;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAffinityClusterResolver</span><span class="params">(ClusterResolver&lt;AwsEndpoint&gt; delegate, String myZone, <span class="keyword">boolean</span> zoneAffinity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate = delegate;</div><div class="line">        <span class="keyword">this</span>.myZone = myZone;</div><div class="line">        <span class="keyword">this</span>.zoneAffinity = zoneAffinity;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>属性 <code>delegate</code> ，委托的解析器。目前代码里使用的是 ConfigClusterResolver 。</li><li>属性 <code>zoneAffinity</code> ，是否可用区亲和。<ul><li><code>true</code> ：EndPoint 可用区为<strong>本地</strong>的优先被放在前面。</li><li><code>false</code> ：EndPoint 可用区<strong>非本地</strong>的优先被放在前面。 </li></ul></li></ul><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 拆分成 本地的可用区和非本地的可用区的 EndPoint 集群</span></div><div class="line"> <span class="number">4</span>:     List&lt;AwsEndpoint&gt;[] parts = ResolverUtils.splitByZone(delegate.getClusterEndpoints(), myZone);</div><div class="line"> <span class="number">5</span>:     List&lt;AwsEndpoint&gt; myZoneEndpoints = parts[<span class="number">0</span>];</div><div class="line"> <span class="number">6</span>:     List&lt;AwsEndpoint&gt; remainingEndpoints = parts[<span class="number">1</span>];</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 随机打乱 EndPoint 集群并进行合并</span></div><div class="line"> <span class="number">8</span>:     List&lt;AwsEndpoint&gt; randomizedList = randomizeAndMerge(myZoneEndpoints, remainingEndpoints);</div><div class="line"> <span class="number">9</span>:     <span class="comment">// 非可用区亲和，将非本地的可用区的 EndPoint 集群放在前面</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">if</span> (!zoneAffinity) &#123;</div><div class="line"><span class="number">11</span>:         Collections.reverse(randomizedList);</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">15</span>:         logger.debug(<span class="string">"Local zone=&#123;&#125;; resolved to: &#123;&#125;"</span>, myZone, randomizedList);</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> randomizedList;</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：调用 <code>ClusterResolver#getClusterEndpoints()</code> 方法，获得 EndPoint 集群。再调用 <code>ResolverUtils#splitByZone(...)</code> 方法，拆分成<strong>本地</strong>和<strong>非本地</strong>的可用区的 EndPoint 集群，点击<a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ResolverUtils.java#L55" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现。</li><li><p>第 8 行 ：调用 <code>#randomizeAndMerge(...)</code> 方法，<strong>分别</strong>随机打乱<strong>每个</strong> EndPoint 集群，并进行<strong>合并</strong>数组，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZoneAffinityClusterResolver.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AwsEndpoint&gt; <span class="title">randomizeAndMerge</span><span class="params">(List&lt;AwsEndpoint&gt; myZoneEndpoints, List&lt;AwsEndpoint&gt; remainingEndpoints)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (myZoneEndpoints.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> ResolverUtils.randomize(remainingEndpoints); <span class="comment">// 打乱</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (remainingEndpoints.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> ResolverUtils.randomize(myZoneEndpoints); <span class="comment">// 打乱</span></div><div class="line">   &#125;</div><div class="line">   List&lt;AwsEndpoint&gt; mergedList = ResolverUtils.randomize(myZoneEndpoints); <span class="comment">// 打乱</span></div><div class="line">   mergedList.addAll(ResolverUtils.randomize(remainingEndpoints)); <span class="comment">// 打乱</span></div><div class="line">   <span class="keyword">return</span> mergedList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolverUtils.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends EurekaEndpoint&gt; <span class="function">List&lt;T&gt; <span class="title">randomize</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">   <span class="comment">// 数组大小为 0 或者 1 ，不进行打乱</span></div><div class="line">   List&lt;T&gt; randomList = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</div><div class="line">   <span class="keyword">if</span> (randomList.size() &lt; <span class="number">2</span>) &#123;</div><div class="line">       <span class="keyword">return</span> randomList;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 以本地IP为随机种子，有如下好处：</span></div><div class="line">   <span class="comment">// 多个主机，实现对同一个 EndPoint 集群负载均衡的效果。</span></div><div class="line">   <span class="comment">// 单个主机，同一个 EndPoint 集群按照固定顺序访问。Eureka-Server 不是强一致性的注册中心，Eureka-Client 对同一个 Eureka-Server 拉取注册信息，保证两者之间增量同步的一致性。</span></div><div class="line">   Random random = <span class="keyword">new</span> Random(LOCAL_IPV4_ADDRESS.hashCode());</div><div class="line">   <span class="keyword">int</span> last = randomList.size() - <span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last; i++) &#123;</div><div class="line">       <span class="keyword">int</span> pos = random.nextInt(randomList.size() - i);</div><div class="line">       <span class="keyword">if</span> (pos != i) &#123;</div><div class="line">           Collections.swap(randomList, i, pos);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> randomList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意，<code>ResolverUtils#randomize(...)</code> 使用以本机IP为随机种子</strong>，有如下好处：<ul><li>多个主机，实现对同一个 EndPoint 集群负载均衡的效果。</li><li>单个主机，同一个 EndPoint 集群按照固定顺序访问。Eureka-Server 不是强一致性的注册中心，Eureka-Client 对同一个 Eureka-Server 拉取注册信息，保证两者之间增量同步的一致性。</li></ul></li></ul></li><li><p>第 10 至 12 行 ：非可用区亲和，将非本地的可用区的 EndPoint 集群放在前面。</p></li></ul><h2 id="3-6-AsyncResolver"><a href="#3-6-AsyncResolver" class="headerlink" title="3.6 AsyncResolver"></a>3.6 AsyncResolver</h2><p><code>com.netflix.discovery.shared.resolver.AsyncResolver</code> ，<strong>异步执行</strong>解析的集群解析器。AsyncResolver 属性较多，而且复杂的多，我们拆分到具体方法里分享。</p><h3 id="3-6-1-定时任务"><a href="#3-6-1-定时任务" class="headerlink" title="3.6.1 定时任务"></a>3.6.1 定时任务</h3><p>AsyncResolver 内置定时任务，<strong>定时</strong>刷新 EndPoint 集群解析结果。</p><p><strong>为什么要刷新</strong>？例如，Eureka-Server 的 <code>serviceUrls</code> 基于 DNS 配置。</p><p><strong>定时任务代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 是否已经调度定时任务 &#123;<span class="doctag">@link</span> #updateTask&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean scheduled = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 委托的解析器</span></div><div class="line"><span class="comment">* 目前代码为 &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.resolver.aws.ZoneAffinityClusterResolver&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClusterResolver&lt;T&gt; delegate;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 定时服务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executorService;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 线程池执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 后台任务</span></div><div class="line"><span class="comment">* 定时解析 EndPoint 集群</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimedSupervisorTask backgroundTask;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 EndPoint 集群结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;List&lt;T&gt;&gt; resultsRef;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 定时解析 EndPoint 集群的频率</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> refreshIntervalMs;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 预热超时时间，单位：毫秒</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> warmUpTimeoutMs;</div><div class="line"></div><div class="line"><span class="comment">// Metric timestamp, tracking last time when data were effectively changed.</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastLoadTimestamp = -<span class="number">1</span>;</div><div class="line"></div><div class="line">AsyncResolver(String name,</div><div class="line">             ClusterResolver&lt;T&gt; delegate,</div><div class="line">             List&lt;T&gt; initialValue,</div><div class="line">             <span class="keyword">int</span> executorThreadPoolSize,</div><div class="line">             <span class="keyword">int</span> refreshIntervalMs,</div><div class="line">             <span class="keyword">int</span> warmUpTimeoutMs) &#123;</div><div class="line">   <span class="keyword">this</span>.name = name;</div><div class="line">   <span class="keyword">this</span>.delegate = delegate;</div><div class="line">   <span class="keyword">this</span>.refreshIntervalMs = refreshIntervalMs;</div><div class="line">   <span class="keyword">this</span>.warmUpTimeoutMs = warmUpTimeoutMs;</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 定时服务</span></div><div class="line">   <span class="keyword">this</span>.executorService = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="comment">// 线程大小=1</span></div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                   .setNameFormat(<span class="string">"AsyncResolver-"</span> + name + <span class="string">"-%d"</span>)</div><div class="line">                   .setDaemon(<span class="keyword">true</span>)</div><div class="line">                   .build());</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 线程池执行器</span></div><div class="line">   <span class="keyword">this</span>.threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           <span class="number">1</span>, <span class="comment">// 线程大小=1</span></div><div class="line">           executorThreadPoolSize, <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">           <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),  <span class="comment">// use direct handoff</span></div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                   .setNameFormat(<span class="string">"AsyncResolver-"</span> + name + <span class="string">"-executor-%d"</span>)</div><div class="line">                   .setDaemon(<span class="keyword">true</span>)</div><div class="line">                   .build()</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 后台任务</span></div><div class="line">   <span class="keyword">this</span>.backgroundTask = <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">           <span class="keyword">this</span>.getClass().getSimpleName(),</div><div class="line">           executorService,</div><div class="line">           threadPoolExecutor,</div><div class="line">           refreshIntervalMs,</div><div class="line">           TimeUnit.MILLISECONDS,</div><div class="line">           <span class="number">5</span>,</div><div class="line">           updateTask</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="keyword">this</span>.resultsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(initialValue);</div><div class="line">   Monitors.registerObject(name, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>backgroundTask</code> ，后台任务，定时解析 EndPoint 集群。</p><ul><li>TimedSupervisorTask ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》「2.3 TimedSupervisorTask」</a> 有详细解析。</li><li><p><code>updateTask</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable updateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;T&gt; newList = delegate.getClusterEndpoints(); <span class="comment">// 调用 委托的解析器 解析 EndPoint 集群</span></div><div class="line">            <span class="keyword">if</span> (newList != <span class="keyword">null</span>) &#123;</div><div class="line">                resultsRef.getAndSet(newList);</div><div class="line">                lastLoadTimestamp = System.currentTimeMillis();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                logger.warn(<span class="string">"Delegate returned null list of cluster endpoints"</span>);</div><div class="line">            &#125;</div><div class="line">            logger.debug(<span class="string">"Resolved to &#123;&#125;"</span>, newList);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            logger.warn(<span class="string">"Failed to retrieve cluster endpoints from the delegate"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><code>delegate</code> ，委托的解析器，目前代码为 ZoneAffinityClusterResolver。</li></ul></li><li><p>后台任务的<strong>发起</strong>在 <code>#getClusterEndpoints()</code> 方法，在 <a href="#">「3.6.2 解析 EndPoint 集群」</a> 详细解析。</p></li></ul></li></ul><h3 id="3-6-2-解析-EndPoint-集群"><a href="#3-6-2-解析-EndPoint-集群" class="headerlink" title="3.6.2 解析 EndPoint 集群"></a>3.6.2 解析 EndPoint 集群</h3><p>调用 <code>#getClusterEndpoints()</code> 方法，解析 EndPoint 集群，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> delay = refreshIntervalMs;</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 若未预热解析 EndPoint 集群结果，进行预热</span></div><div class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (warmedUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!doWarmUp()) &#123;</div><div class="line"> <span class="number">7</span>:             delay = <span class="number">0</span>; <span class="comment">// 预热失败，取消定时任务的第一次延迟</span></div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 若未调度定时任务，进行调度</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (scheduled.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"><span class="number">12</span>:         scheduleTask(delay);</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>:     <span class="comment">// 返回 EndPoint 集群</span></div><div class="line"><span class="number">15</span>:     <span class="keyword">return</span> resultsRef.get();</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 5 至 9 行 ：<strong>若未预热解析 EndPoint 集群结果</strong>，调用 <code>#doWarmUp()</code> 方法，进行预热。若预热失败，取消定时任务的第一次延迟。<code>#doWarmUp()</code> 方法实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">doWarmUp</span><span class="params">()</span> </span>&#123;</div><div class="line">   Future future = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       future = threadPoolExecutor.submit(updateTask);</div><div class="line">       future.get(warmUpTimeoutMs, TimeUnit.MILLISECONDS);  <span class="comment">// block until done or timeout</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"Best effort warm up failed"</span>, e);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line">           future.cancel(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>updateTask</code> ，解析 EndPoint 集群。</li></ul></li><li><p>第 10 至 13 行 ： <strong>若未调度定时任务，进行调度</strong>，调用 <code>#scheduleTask()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTask</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">   executorService.schedule(backgroundTask, delay, TimeUnit.MILLISECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 15 行 ：返回 EndPoint 集群。<strong>当第一次预热失败，会返回空，直到定时任务获得到结果</strong>。</p></li></ul><h1 id="4-初始化解析器"><a href="#4-初始化解析器" class="headerlink" title="4. 初始化解析器"></a>4. 初始化解析器</h1><p>Eureka-Client 在初始化时，调用 <code>DiscoveryClient#scheduleServerEndpointTask()</code> 方法，初始化 AsyncResolver 解析器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></div><div class="line"><span class="function"><span class="params">                                            AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</div><div class="line">                                            </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="comment">// 创建 EndPoint 解析器</span></div><div class="line">   eurekaTransport.bootstrapResolver = EurekaHttpClients.newBootstrapResolver(</div><div class="line">           clientConfig,</div><div class="line">           transportConfig,</div><div class="line">           eurekaTransport.transportClientFactory,</div><div class="line">           applicationInfoManager.getInfo(),</div><div class="line">           applicationsSource</div><div class="line">   );</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>EurekaHttpClients#newBootstrapResolver(...)</code> 方法，创建 EndPoint 解析器，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPOSITE_BOOTSTRAP_STRATEGY = <span class="string">"composite"</span>;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClosableResolver&lt;AwsEndpoint&gt; <span class="title">newBootstrapResolver</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:         <span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">5</span>:         <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">6</span>:         <span class="keyword">final</span> TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">7</span>:         <span class="keyword">final</span> InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">8</span>:         <span class="keyword">final</span> ApplicationsResolver.ApplicationsSource applicationsSource)</span></span></div><div class="line"><span class="function"> 9: </span>&#123;</div><div class="line"><span class="number">10</span>:     <span class="keyword">if</span> (COMPOSITE_BOOTSTRAP_STRATEGY.equals(transportConfig.getBootstrapResolverStrategy())) &#123;</div><div class="line"><span class="number">11</span>:         <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line"><span class="number">12</span>:             <span class="keyword">return</span> compositeBootstrapResolver(</div><div class="line"><span class="number">13</span>:                     clientConfig,</div><div class="line"><span class="number">14</span>:                     transportConfig,</div><div class="line"><span class="number">15</span>:                     transportClientFactory,</div><div class="line"><span class="number">16</span>:                     myInstanceInfo,</div><div class="line"><span class="number">17</span>:                     applicationsSource</div><div class="line"><span class="number">18</span>:             );</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             logger.warn(<span class="string">"Cannot create a composite bootstrap resolver if registry fetch is disabled."</span> +</div><div class="line"><span class="number">21</span>:                     <span class="string">" Falling back to using a default bootstrap resolver."</span>);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:     <span class="comment">// if all else fails, return the default</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">return</span> defaultBootstrapResolver(clientConfig, myInstanceInfo);</div><div class="line"><span class="number">27</span>: &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">30:  * <span class="doctag">@return</span> a bootstrap resolver that resolves eureka server endpoints based on either DNS or static config,</span></div><div class="line"><span class="comment">31:  *         depending on configuration for one or the other. This resolver will warm up at the start.</span></div><div class="line"><span class="comment">32:  */</span></div><div class="line"><span class="number">33</span>: <span class="function"><span class="keyword">static</span> ClosableResolver&lt;AwsEndpoint&gt; <span class="title">defaultBootstrapResolver</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">34</span>:                                                               <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">35</span>:     <span class="comment">// 获得 可用区集合</span></div><div class="line"><span class="number">36</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line"><span class="number">37</span>:     <span class="comment">// 获得 应用实例的 可用区</span></div><div class="line"><span class="number">38</span>:     String myZone = InstanceInfo.getZone(availZones, myInstanceInfo);</div><div class="line"><span class="number">39</span>: </div><div class="line"><span class="number">40</span>:     <span class="comment">// 创建 ZoneAffinityClusterResolver</span></div><div class="line"><span class="number">41</span>:     ClusterResolver&lt;AwsEndpoint&gt; delegateResolver = <span class="keyword">new</span> ZoneAffinityClusterResolver(</div><div class="line"><span class="number">42</span>:             <span class="keyword">new</span> ConfigClusterResolver(clientConfig, myInstanceInfo),</div><div class="line"><span class="number">43</span>:             myZone,</div><div class="line"><span class="number">44</span>:             <span class="keyword">true</span></div><div class="line"><span class="number">45</span>:     );</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>:     <span class="comment">// 第一次 EndPoint 解析</span></div><div class="line"><span class="number">48</span>:     List&lt;AwsEndpoint&gt; initialValue = delegateResolver.getClusterEndpoints();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:     <span class="comment">// 解析不到 Eureka-Server EndPoint ，快速失败</span></div><div class="line"><span class="number">51</span>:     <span class="keyword">if</span> (initialValue.isEmpty()) &#123;</div><div class="line"><span class="number">52</span>:         String msg = <span class="string">"Initial resolution of Eureka server endpoints failed. Check ConfigClusterResolver logs for more info"</span>;</div><div class="line"><span class="number">53</span>:         logger.error(msg);</div><div class="line"><span class="number">54</span>:         failFastOnInitCheck(clientConfig, msg);</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>:     <span class="comment">// 创建 AsyncResolver</span></div><div class="line"><span class="number">58</span>:     <span class="keyword">return</span> <span class="keyword">new</span> AsyncResolver&lt;&gt;(</div><div class="line"><span class="number">59</span>:             EurekaClientNames.BOOTSTRAP,</div><div class="line"><span class="number">60</span>:             delegateResolver,</div><div class="line"><span class="number">61</span>:             initialValue,</div><div class="line"><span class="number">62</span>:             <span class="number">1</span>,</div><div class="line"><span class="number">63</span>:             clientConfig.getEurekaServiceUrlPollIntervalSeconds() * <span class="number">1000</span></div><div class="line"><span class="number">64</span>:     );</div><div class="line"><span class="number">65</span>: &#125;</div></pre></td></tr></table></figure></li></ul><pre><code>* 第 10 至 23 行 ：组合解析器，用于 Eureka 1.x 对 Eureka 2.x 的兼容配置，暂时不需要了解。TODO[0028]写入集群和读取集群* 第 26 行 ：调用 `#defaultBootstrapResolver()` 方法，创建默认的解析器 AsyncResolver 。* 第 40 至 45 行 ：创建 ZoneAffinityClusterResolver 。在 ZoneAffinityClusterResolver 构造方法的参数，我们看到创建 ConfigClusterResolver 作为 `delegate` 参数。* 第 48 行 ：调用 `ZoneAffinityClusterResolver#getClusterEndpoints()` 方法，**第一次 Eureka-Server EndPoint 集群解析**。* 第 51 至 55 行 ：解析不到 Eureka-Server EndPoint 集群时，可以通过配置( `eureka.experimental.clientTransportFailFastOnInit=true` )，使 Eureka-Client 初始化失败。`#failFastOnInitCheck(...)` 方法，实现代码如下：    <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// potential future feature, guarding with experimental flag for now</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">failFastOnInitCheck</span><span class="params">(EurekaClientConfig clientConfig, String msg)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="string">"true"</span>.equals(clientConfig.getExperimental(<span class="string">"clientTransportFailFastOnInit"</span>))) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(msg);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>    * x</code></pre><ul><li><p>第 58 至 64 行 ：创建 AsyncResolver 。从代码上，我们可以看到，<code>AsyncResolver.resultsRef</code> 属性一开始已经用 <code>initialValue</code> 传递给 AsyncResolver 构造方法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncResolver</span><span class="params">(String name,</span></span></div><div class="line"><span class="function"><span class="params">                      ClusterResolver&lt;T&gt; delegate,</span></span></div><div class="line"><span class="function"><span class="params">                      List&lt;T&gt; initialValues,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> executorThreadPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> refreshIntervalMs)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(</div><div class="line">             name,</div><div class="line">             delegate,</div><div class="line">             initialValues,</div><div class="line">             executorThreadPoolSize,</div><div class="line">             refreshIntervalMs,</div><div class="line">             <span class="number">0</span></div><div class="line">     );</div><div class="line">    </div><div class="line">     <span class="comment">// 设置已经预热</span></div><div class="line">     warmedUp.set(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>T T  一开始看解析器，没反应过来是委托设计模式，一脸懵逼+一脸懵逼+一脸懵逼。后面理顺了，发现超级奈斯( Nice ) 啊 ！！！！</p><p>胖友，你学会了么？</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/end-point-and-resolver/&quot;&gt;http://www.iocoder.cn/Eureka/end-point-and-resolver/&lt;/a&gt; 「芋道源码」欢迎
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 任务批处理</title>
    <link href="http://www.iocoder.cn/Eureka/batch-tasks/"/>
    <id>http://www.iocoder.cn/Eureka/batch-tasks/</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2017-10-17T14:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/batch-tasks/">http://www.iocoder.cn/Eureka/batch-tasks/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">2. 整体流程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">3. 任务处理器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4. 创建任务分发器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.1 批量任务执行分发器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.2 单任务执行分发器</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">5. 创建任务接收执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6. 创建任务执行器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.1 创建批量任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.2 创建单任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.3 工作线程抽象类</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">7. 网络通信整形器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">8. 任务接收执行器【处理任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">9. 任务接收线程【调度任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10. 任务执行器【执行任务】</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.1 批量任务工作线程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.2 单任务工作线程</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>任务批处理</strong>。Eureka-Server 集群通过任务批处理同步应用实例注册实例，所以本文也是为 Eureka-Server 集群同步的分享做铺垫。</p><p>本文涉及类在 <code>com.netflix.eureka.util.batcher</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png" alt=""></p><ul><li>紫色部分 —— 任务分发器</li><li>蓝色部分 —— 任务接收器</li><li>红色部分 —— 任务执行器</li><li>绿色部分 —— 任务处理器</li><li>黄色部分 —— 任务持有者( 任务 )</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-整体流程"><a href="#2-整体流程" class="headerlink" title="2. 整体流程"></a>2. 整体流程</h1><p>任务执行的整体流程如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png" alt=""></p><ul><li>细箭头 —— 任务执行经历的操作</li><li>粗箭头 —— 任务队列流转的方向</li><li><p><strong>不同于</strong>一般情况下，任务提交了<strong>立即</strong>同步或异步执行，任务的执行拆分了<strong>三层队列</strong>：</p><ul><li><p>第一层，接收队列( <code>acceptorQueue</code> )，重新处理队列( <code>reprocessQueue</code> )。</p><ul><li>蓝线：分发器在收到任务执行请求后，提交到接收队列，<strong>任务实际未执行</strong>。</li><li>黄线：执行器的工作线程处理任务失败，将符合条件( 见 <a href="#">「3. 任务处理器」</a> )的失败任务提交到重新执行队列。</li></ul><ul><li><p>第二层，待执行队列( <code>processingOrder</code> )</p><ul><li>粉线：接收线程( Runner )将重新执行队列，接收队列提交到待执行队列。</li></ul></li><li><p>第三层，工作队列( <code>workQueue</code> )</p><ul><li>粉线：接收线程( Runner )将待执行队列的任务根据参数( <code>maxBatchingSize</code> )将任务合并成<strong>批量任务</strong>，调度( 提交 )到工作队列。</li><li>黄线：执行器的工作线程<strong>池</strong>，一个工作线程可以拉取一个<strong>批量任务</strong>进行执行。</li></ul></li></ul></li></ul></li><li><p><strong>三层队列的好处</strong>：</p><ul><li>接收队列，避免处理任务的阻塞等待。</li><li>接收线程( Runner )合并任务，将相同任务编号( <strong>是的，任务是带有编号的</strong> )的任务合并，只执行一次。</li><li>Eureka-Server 为集群同步提供批量操作<strong>多个</strong>应用实例的<strong>接口</strong>，一个<strong>批量任务</strong>可以一次调度接口完成，避免多次调用的开销。当然，这样做的前提是合并任务，这也导致 Eureka-Server 集群之间对应用实例的注册和下线带来更大的延迟。<strong>毕竟，Eureka 是在 CAP 之间，选择了 AP</strong>。</li></ul></li></ul><h1 id="3-任务处理器"><a href="#3-任务处理器" class="headerlink" title="3. 任务处理器"></a>3. 任务处理器</h1><p><code>com.netflix.eureka.util.batcher.TaskProcessor</code> ，任务处理器<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * A processed task/task list ends up in one of the following states:</span></div><div class="line"><span class="comment">     * &lt;ul&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> Success&#125; processing finished successfully&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> TransientError&#125; processing failed, but shall be retried later&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> PermanentError&#125; processing failed, and is non recoverable&lt;/li&gt;</span></div><div class="line"><span class="comment">     * &lt;/ul&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> ProcessingResult &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 成功</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Success,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 拥挤错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Congestion,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 瞬时错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        TransientError,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 永久错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        PermanentError</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理单任务</span></div><div class="line"><span class="comment">     * In non-batched mode a single task is processed at a time.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(T task)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理批量任务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * For batched mode a collection of tasks is run at a time. The result is provided for the aggregated result,</span></div><div class="line"><span class="comment">     * and all tasks are handled in the same way according to what is returned (for example are rescheduled, if the</span></div><div class="line"><span class="comment">     * error is transient).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(List&lt;T&gt; tasks)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ProcessingResult ，处理任务结果。<ul><li><code>Success</code> ，成功。</li><li><code>Congestion</code> ，拥挤错误，<strong>任务将会被重试</strong>。例如，请求被限流。</li><li><code>TransientError</code> ，瞬时错误，<strong>任务将会被重试</strong>。例如，网络请求超时。</li><li><code>PermanentError</code> ，永久错误，<strong>任务将会被丢弃</strong>。例如，执行时发生程序异常。</li></ul></li><li><code>#process(task)</code> 方法，处理单任务。</li><li><code>#process(tasks)</code> 方法，处理批量任务。</li></ul><h1 id="4-创建任务分发器"><a href="#4-创建任务分发器" class="headerlink" title="4. 创建任务分发器"></a>4. 创建任务分发器</h1><p><code>com.netflix.eureka.util.batcher.TaskDispatcher</code> ，任务分发器<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskDispatcher</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#process(...)</code> 方法，提交任务编号，任务，任务过期时间给任务分发器处理。</li></ul><p><code>com.netflix.eureka.util.batcher.TaskDispatchers</code> ，任务分发器<strong>工厂类</strong>，用于创建任务分发器。其内部提供两种任务分发器的实现：</p><ul><li><strong>批量任务</strong>执行的分发器，用于 Eureka-Server 集群注册信息的同步任务。</li><li><strong>单任务</strong>执行的分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( Autoscaling Group ) 同步状态。虽然本系列暂时对 AWS 相关的不做解析，从工具类的角度来说，本文会对该分发器进行分享。</li></ul><p><code>com.netflix.eureka.cluster.ReplicationTaskProcessor</code> ，实现 TaskDispatcher ，Eureka-Server 集群任务处理器。感兴趣的同学，可以点击<a href="https://github.com/YunaiV/eureka/blob/6e1b694898aa2f4c155936420c2ce5850f142742/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>自己研究，我们将在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p><h2 id="4-1-批量任务执行分发器"><a href="#4-1-批量任务执行分发器" class="headerlink" title="4.1 批量任务执行分发器"></a>4.1 批量任务执行分发器</h2><p>调用 <code>TaskDispatchers#createBatchingTaskDispatcher(...)</code> 方法，创建<strong>批量任务</strong>执行的分发器，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatchers.java</span></div><div class="line">  <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">  2:  * 创建批量任务执行的分发器</span></div><div class="line"><span class="comment">  3:  *</span></div><div class="line"><span class="comment">  4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment">  5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment">  6:  * <span class="doctag">@param</span> workloadSize 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">  7:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">  8:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">  9:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 10:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment"> 11:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment"> 12:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment"> 13:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment"> 14:  * <span class="doctag">@return</span> 批量任务执行的分发器</span></div><div class="line"><span class="comment"> 15:  */</span></div><div class="line"> <span class="number">16</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">17</span>:                                                                          <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">18</span>:                                                                          <span class="keyword">int</span> workloadSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">19</span>:                                                                          <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">20</span>:                                                                          <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">21</span>:                                                                          <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">22</span>:                                                                          <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">23</span>:                                                                          TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"> <span class="number">24</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"> <span class="number">25</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"> <span class="number">26</span>:             id, maxBufferSize, workloadSize, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"> <span class="number">27</span>:     );</div><div class="line"> <span class="number">28</span>:     <span class="comment">// 创建 批量任务执行器</span></div><div class="line"> <span class="number">29</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.batchExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"> <span class="number">30</span>:     <span class="comment">// 创建 批量任务分发器</span></div><div class="line"> <span class="number">31</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"> <span class="number">32</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">33</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"> <span class="number">34</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"> <span class="number">35</span>:         &#125;</div><div class="line"> <span class="number">36</span>: </div><div class="line"> <span class="number">37</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">38</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">39</span>:             acceptorExecutor.shutdown();</div><div class="line"> <span class="number">40</span>:             taskExecutor.shutdown();</div><div class="line"> <span class="number">41</span>:         &#125;</div><div class="line"> <span class="number">42</span>:     &#125;;</div><div class="line"> <span class="number">43</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 1 至 23 行 ：方法参数。比较多哈，请耐心理解。<ul><li><code>workloadSize</code> 参数，单个批量任务包含任务最大数量。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 24 至 27 行 ：创建任务<strong>接收</strong>执行器。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>批量</strong>任务执行器。在 <a href="#">「6.1 创建批量任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>批量</strong>任务分发器。<ul><li>第 32 至 35 行 ：<code>#process()</code> 方法的实现，调用 <code>AcceptorExecutor#process(...)</code> 方法，提交 [ 任务编号 , 任务 , 任务过期时间 ] 给任务分发器处理。</li></ul></li></ul><h2 id="4-2-单任务执行分发器"><a href="#4-2-单任务执行分发器" class="headerlink" title="4.2 单任务执行分发器"></a>4.2 单任务执行分发器</h2><p>调用 <code>TaskDispatchers#createNonBatchingTaskDispatcher(...)</code> 方法，创建<strong>单任务</strong>执行的分发器，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 2:  * 创建单任务执行的分发器</span></div><div class="line"><span class="comment"> 3:  *</span></div><div class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment"> 6:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment"> 7:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment"> 8:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 9:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">10:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment">11:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">12:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">13:  * <span class="doctag">@return</span> 单任务执行的分发器</span></div><div class="line"><span class="comment">14:  */</span></div><div class="line"><span class="number">15</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createNonBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">16</span>:                                                                             <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">17</span>:                                                                             <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">18</span>:                                                                             <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">19</span>:                                                                             <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">20</span>:                                                                             <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">21</span>:                                                                             TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"><span class="number">24</span>:             id, maxBufferSize, <span class="comment">/* workloadSize = 1 */</span><span class="number">1</span>, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"><span class="number">25</span>:     );</div><div class="line"><span class="number">26</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.singleItemExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"><span class="number">27</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"><span class="number">28</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">29</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"><span class="number">30</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">34</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">35</span>:             acceptorExecutor.shutdown();</div><div class="line"><span class="number">36</span>:             taskExecutor.shutdown();</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 1 至 21 行 ：方法参数。比较多哈，请耐心理解。<ul><li><del><code>workloadSize</code> 参数</del>，相比 <code>#createBatchingTaskDispatcher(...)</code> 少这个参数。<strong>在第 24 行，你会发现该参数传递给 AcceptorExecutor 使用 1 噢</strong>。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 21 至 25 行 ：创建任务<strong>接收</strong>执行器。和 <code>#createBatchingTaskDispatcher(...)</code> 只差 <code>workloadSize = 1</code> 参数。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>单</strong>任务执行器。<strong>和 <code>#createBatchingTaskDispatcher(...)</code> 差别很大</strong>。<a href="#">「6.2 创建单任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>单</strong>任务分发器。和 <code>#createBatchingTaskDispatcher(...)</code> 一样。</li></ul><h1 id="5-创建任务接收执行器"><a href="#5-创建任务接收执行器" class="headerlink" title="5. 创建任务接收执行器"></a>5. 创建任务接收执行器</h1><p><code>com.netflix.eureka.util.batcher.AcceptorExecutor</code> ，任务接收执行器。创建构造方法代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">AcceptorExecutor</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AcceptorExecutor.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:      * 待执行队列最大数量</span></div><div class="line"><span class="comment"> 7:      * &#123;<span class="doctag">@link</span> #processingOrder&#125;</span></div><div class="line"><span class="comment"> 8:      */</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBufferSize;</div><div class="line"><span class="number">10</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">11:      * 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">12:      */</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBatchingSize;</div><div class="line"><span class="number">14</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">15:      * 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">16:      */</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBatchingDelay;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">20:      * 是否关闭</span></div><div class="line"><span class="comment">21:      */</span></div><div class="line"><span class="number">22</span>:     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">23</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">24:      * 接收任务队列</span></div><div class="line"><span class="comment">25:      */</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; acceptorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">27</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">28:      * 重新执行任务队列</span></div><div class="line"><span class="comment">29:      */</span></div><div class="line"><span class="number">30</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;TaskHolder&lt;ID, T&gt;&gt; reprocessQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</div><div class="line"><span class="number">31</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">32:      * 接收任务线程</span></div><div class="line"><span class="comment">33:      */</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Thread acceptorThread;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">37:      * 待执行任务映射</span></div><div class="line"><span class="comment">38:      */</span></div><div class="line"><span class="number">39</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ID, TaskHolder&lt;ID, T&gt;&gt; pendingTasks = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="number">40</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">41:      * 待执行队列</span></div><div class="line"><span class="comment">42:      */</span></div><div class="line"><span class="number">43</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ID&gt; processingOrder = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">46:      * 单任务工作请求信号量</span></div><div class="line"><span class="comment">47:      */</span></div><div class="line"><span class="number">48</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore singleItemWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">49</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">50:      * 单任务工作队列</span></div><div class="line"><span class="comment">51:      */</span></div><div class="line"><span class="number">52</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; singleItemWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">53</span>: </div><div class="line"><span class="number">54</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">55:      * 批量任务工作请求信号量</span></div><div class="line"><span class="comment">56:      */</span></div><div class="line"><span class="number">57</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">58</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">59:      * 批量任务工作队列</span></div><div class="line"><span class="comment">60:      */</span></div><div class="line"><span class="number">61</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">62</span>: </div><div class="line"><span class="number">63</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">64:      * 网络通信整形器</span></div><div class="line"><span class="comment">65:      */</span></div><div class="line"><span class="number">66</span>:     <span class="keyword">private</span> <span class="keyword">final</span> TrafficShaper trafficShaper;</div><div class="line"><span class="number">67</span>: </div><div class="line"><span class="number">68</span>:     AcceptorExecutor(String id,</div><div class="line"><span class="number">69</span>:                      <span class="keyword">int</span> maxBufferSize,</div><div class="line"><span class="number">70</span>:                      <span class="keyword">int</span> maxBatchingSize,</div><div class="line"><span class="number">71</span>:                      <span class="keyword">long</span> maxBatchingDelay,</div><div class="line"><span class="number">72</span>:                      <span class="keyword">long</span> congestionRetryDelayMs,</div><div class="line"><span class="number">73</span>:                      <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line"><span class="number">74</span>:         <span class="keyword">this</span>.maxBufferSize = maxBufferSize;</div><div class="line"><span class="number">75</span>:         <span class="keyword">this</span>.maxBatchingSize = maxBatchingSize;</div><div class="line"><span class="number">76</span>:         <span class="keyword">this</span>.maxBatchingDelay = maxBatchingDelay;</div><div class="line"><span class="number">77</span>: </div><div class="line"><span class="number">78</span>:         <span class="comment">// 创建 网络通信整形器</span></div><div class="line"><span class="number">79</span>:         <span class="keyword">this</span>.trafficShaper = <span class="keyword">new</span> TrafficShaper(congestionRetryDelayMs, networkFailureRetryMs);</div><div class="line"><span class="number">80</span>: </div><div class="line"><span class="number">81</span>:         <span class="comment">// 创建 接收任务线程</span></div><div class="line"><span class="number">82</span>:         ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line"><span class="number">83</span>:         <span class="keyword">this</span>.acceptorThread = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> AcceptorRunner(), <span class="string">"TaskAcceptor-"</span> + id);</div><div class="line"><span class="number">84</span>:         <span class="keyword">this</span>.acceptorThread.setDaemon(<span class="keyword">true</span>);</div><div class="line"><span class="number">85</span>:         <span class="keyword">this</span>.acceptorThread.start();</div><div class="line"><span class="number">86</span>: </div><div class="line"><span class="number">87</span>:         <span class="comment">// TODO （省略代码）芋艿：监控相关，暂时无视</span></div><div class="line"><span class="number">88</span>:     &#125;</div><div class="line"><span class="number">89</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 61 行 ：属性。比较多哈，请耐心理解。<ul><li>眼尖如你，会发现 AcceptorExecutor 即存在单任务工作队列( <code>singleItemWorkQueue</code> )，又存在批量任务工作队列( <code>batchWorkQueue</code> ) ，在 <a href="#">「9. 任务接收线程【调度任务】」</a> 会解答这个疑惑。</li></ul></li><li>第 78 至 79 行 ：创建网络通信整形器。在 <a href="#">「7. 网络通信整形器」</a> 详细解析。</li><li>第 81 至 85 行 ：<strong>创建接收任务线程</strong>。</li></ul><h1 id="6-创建任务执行器"><a href="#6-创建任务执行器" class="headerlink" title="6. 创建任务执行器"></a>6. 创建任务执行器</h1><p><code>com.netflix.eureka.util.batcher.TaskExecutors</code> ，任务执行器。<strong>其内部提供创建单任务和批量任务执行器的两种方法</strong>。TaskExecutors 构造方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutors</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TaskExecutors.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 工作线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; workerThreads;</div><div class="line"></div><div class="line">    TaskExecutors(WorkerRunnableFactory&lt;ID, T&gt; workerRunnableFactory, <span class="keyword">int</span> workerCount, AtomicBoolean isShutdown) &#123;</div><div class="line">        <span class="keyword">this</span>.isShutdown = isShutdown;</div><div class="line">        <span class="keyword">this</span>.workerThreads = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 创建 工作线程池</span></div><div class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) &#123;</div><div class="line">            WorkerRunnable&lt;ID, T&gt; runnable = workerRunnableFactory.create(i);</div><div class="line">            Thread workerThread = <span class="keyword">new</span> Thread(threadGroup, runnable, runnable.getWorkerName());</div><div class="line">            workerThreads.add(workerThread);</div><div class="line">            workerThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">            workerThread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建工作线程工厂</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 批量任务执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">WorkerRunnableFactory</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function">WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>workerThreads</code> 属性，工作线程<strong>池</strong>。<strong>工作任务队列会被工作线程池并发拉取，并发执行</strong>。</li><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnableFactory</code> ，创建工作线程工厂<strong>接口</strong>。单任务和批量任务执行器的工作线程实现不同，通过自定义工厂实现类创建。</li></ul><h2 id="6-1-创建批量任务执行器"><a href="#6-1-创建批量任务执行器" class="headerlink" title="6.1 创建批量任务执行器"></a>6.1 创建批量任务执行器</h2><p>调用 <code>TaskExecutors#batchExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建批量任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 批量任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">batchExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建批量任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 批量任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> BatchWorkerRunnable&lt;&gt;(<span class="string">"TaskBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.BatchWorkerRunnable</code> ，批量任务工作线程。</li></ul><h2 id="6-2-创建单任务执行器"><a href="#6-2-创建单任务执行器" class="headerlink" title="6.2 创建单任务执行器"></a>6.2 创建单任务执行器</h2><p>调用 <code>TaskExecutors#singleItemExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建单任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 单任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">singleItemExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建单任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 单任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SingleTaskWorkerRunnable&lt;&gt;(<span class="string">"TaskNonBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.SingleTaskWorkerRunnable</code> ，单任务工作线程。</li></ul><h2 id="6-3-工作线程抽象类"><a href="#6-3-工作线程抽象类" class="headerlink" title="6.3 工作线程抽象类"></a>6.3 工作线程抽象类</h2><p><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable</code> ，任务工作线程抽象类。BatchWorkerRunnable 和 SingleTaskWorkerRunnable 都实现该类，差异在 <code>#run()</code> 的自定义实现。WorkerRunnable 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 线程名</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> String workerName;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 是否关闭</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务处理器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务接收执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; taskDispatcher;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略构造方法和 getting 方法。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="7-网络通信整形器"><a href="#7-网络通信整形器" class="headerlink" title="7. 网络通信整形器"></a>7. 网络通信整形器</h1><p><code>com.netflix.eureka.util.batcher.TrafficShaper</code> ，网络通信整形器。当任务执行发生请求限流，或是请求网络失败的情况，则延时 AcceptorRunner 将任务提交到工作任务队列，从而避免任务很快去执行，再次发生上述情况。TrafficShaper 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrafficShaper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Upper bound on delay provided by configuration.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DELAY = <span class="number">30</span> * <span class="number">1000</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> congestionRetryDelayMs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> networkFailureRetryMs;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后请求限流时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastCongestionError;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后网络失败时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastNetworkFailure;</div><div class="line"></div><div class="line">    TrafficShaper(<span class="keyword">long</span> congestionRetryDelayMs, <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line">        <span class="keyword">this</span>.congestionRetryDelayMs = Math.min(MAX_DELAY, congestionRetryDelayMs);</div><div class="line">        <span class="keyword">this</span>.networkFailureRetryMs = Math.min(MAX_DELAY, networkFailureRetryMs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFailure</span><span class="params">(ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (processingResult == ProcessingResult.Congestion) &#123;</div><div class="line">            lastCongestionError = System.currentTimeMillis();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processingResult == ProcessingResult.TransientError) &#123;</div><div class="line">            lastNetworkFailure = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 计算提交延迟，单位：毫秒</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">transmissionDelay</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError == -<span class="number">1</span> &amp;&amp; lastNetworkFailure == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后请求限流带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> congestionDelay = now - lastCongestionError;</div><div class="line">            <span class="keyword">if</span> (congestionDelay &gt;= <span class="number">0</span> &amp;&amp; congestionDelay &lt; congestionRetryDelayMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> congestionRetryDelayMs - congestionDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastCongestionError = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后网络失败带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastNetworkFailure != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> failureDelay = now - lastNetworkFailure;</div><div class="line">            <span class="keyword">if</span> (failureDelay &gt;= <span class="number">0</span> &amp;&amp; failureDelay &lt; networkFailureRetryMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> networkFailureRetryMs - failureDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastNetworkFailure = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#registerFailure(...)</code> ，在任务执行失败时，提交任务结果给 TrafficShaper ，记录发生时间。在 <a href="#">「10. 任务执行器【执行任务】」</a> 会看到调用该方法。</li><li><code>#transmissionDelay(...)</code> ，计算提交延迟，单位：毫秒。<a href="#">「9. 任务接收线程【调度任务】」</a> 会看到调用该方法。</li></ul><h1 id="8-任务接收执行器【处理任务】"><a href="#8-任务接收执行器【处理任务】" class="headerlink" title="8. 任务接收执行器【处理任务】"></a>8. 任务接收执行器【处理任务】</h1><p>调用 <code>AcceptorExecutor#process(...)</code> 方法，添加任务到接收任务队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line">   acceptorQueue.add(<span class="keyword">new</span> TaskHolder&lt;ID, T&gt;(id, task, expiryTime));</div><div class="line">   acceptedTasks++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.eureka.util.batcher.TaskHolder</code> ，任务持有者，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskHolder</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ID id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务过期时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> expiryTime;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务提交时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> submitTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="9-任务接收线程【调度任务】"><a href="#9-任务接收线程【调度任务】" class="headerlink" title="9. 任务接收线程【调度任务】"></a>9. 任务接收线程【调度任务】</h1><p>后台线程执行 <code>AcceptorRunner#run(...)</code> 方法，调度任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> scheduleTime = <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:             <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"> <span class="number">7</span>:             drainInputQueues();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:             <span class="comment">// 待执行任务数量</span></div><div class="line"><span class="number">10</span>:             <span class="keyword">int</span> totalItems = processingOrder.size();</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:             <span class="comment">// 计算调度时间</span></div><div class="line"><span class="number">13</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"><span class="number">14</span>:             <span class="keyword">if</span> (scheduleTime &lt; now) &#123;</div><div class="line"><span class="number">15</span>:                 scheduleTime = now + trafficShaper.transmissionDelay();</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:             <span class="comment">// 调度</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (scheduleTime &lt;= now) &#123;</div><div class="line"><span class="number">20</span>:                 <span class="comment">// 调度批量任务</span></div><div class="line"><span class="number">21</span>:                 assignBatchWork();</div><div class="line"><span class="number">22</span>:                 <span class="comment">// 调度单任务</span></div><div class="line"><span class="number">23</span>:                 assignSingleItemWork();</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             <span class="comment">// 1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// If no worker is requesting data or there is a delay injected by the traffic shaper,</span></div><div class="line"><span class="number">28</span>:             <span class="comment">// sleep for some time to avoid tight loop.</span></div><div class="line"><span class="number">29</span>:             <span class="keyword">if</span> (totalItems == processingOrder.size()) &#123;</div><div class="line"><span class="number">30</span>:                 Thread.sleep(<span class="number">10</span>);</div><div class="line"><span class="number">31</span>:             &#125;</div><div class="line"><span class="number">32</span>:         &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line"><span class="number">33</span>:             <span class="comment">// Ignore</span></div><div class="line"><span class="number">34</span>:         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">35</span>:             <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"><span class="number">36</span>:             logger.warn(<span class="string">"Discovery AcceptorThread error"</span>, e);</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：无限循环执行调度，直到关闭。</li><li><p>第 6 至 7 行 ：调用 <code>#drainInputQueues()</code> 方法，<strong>循环</strong>处理完输入队列( 接收队列 + 重新执行队列 )，<strong>直到</strong>有待执行的任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainInputQueues</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 处理完重新执行队列</span></div><div class="line"> <span class="number">4</span>:         drainReprocessQueue();</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 处理完接收队列</span></div><div class="line"> <span class="number">6</span>:         drainAcceptorQueue();</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:         <span class="comment">// 所有队列为空，等待 10 ms，看接收队列是否有新任务</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (!isShutdown.get()) &#123;</div><div class="line"><span class="number">10</span>:             <span class="comment">// If all queues are empty, block for a while on the acceptor queue</span></div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (reprocessQueue.isEmpty() &amp;&amp; acceptorQueue.isEmpty() &amp;&amp; pendingTasks.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:                 TaskHolder&lt;ID, T&gt; taskHolder = acceptorQueue.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:                     appendTaskHolder(taskHolder);</div><div class="line"><span class="number">15</span>:                 &#125;</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125; <span class="keyword">while</span> (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty()); <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 &amp;&amp; 第 18 行 ：<strong>循环</strong>，直到<strong>同时</strong>满足如下全部条件：<ul><li>重新执行队列( <code>reprocessQueue</code> ) 和接收队列( <code>acceptorQueue</code> )为空</li><li>待执行任务映射( <code>pendingTasks</code> )<strong>不为空</strong></li></ul></li><li><p>第 3 至 4 行 ：处理完重新执行队列( <code>reprocessQueue</code> )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainReprocessQueue</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">3</span>:     <span class="keyword">while</span> (!reprocessQueue.isEmpty() &amp;&amp; !isFull()) &#123;</div><div class="line"> <span class="number">4</span>:         TaskHolder&lt;ID, T&gt; taskHolder = reprocessQueue.pollLast(); <span class="comment">// 优先拿较新的任务</span></div><div class="line"> <span class="number">5</span>:         ID id = taskHolder.getId();</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (taskHolder.getExpiryTime() &lt;= now) &#123; <span class="comment">// 过期</span></div><div class="line"> <span class="number">7</span>:             expiredTasks++;</div><div class="line"> <span class="number">8</span>:         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pendingTasks.containsKey(id)) &#123; <span class="comment">// 已存在</span></div><div class="line"> <span class="number">9</span>:             overriddenTasks++;</div><div class="line"><span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">11</span>:             pendingTasks.put(id, taskHolder);</div><div class="line"><span class="number">12</span>:             processingOrder.addFirst(id); <span class="comment">// 提交到队头</span></div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="comment">// 如果待执行队列已满，清空重新执行队列，放弃较早的任务</span></div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (isFull()) &#123;</div><div class="line"><span class="number">17</span>:         queueOverflows += reprocessQueue.size();</div><div class="line"><span class="number">18</span>:         reprocessQueue.clear();</div><div class="line"><span class="number">19</span>:     &#125;</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：优先从重新执行任务的队尾拿较新的任务，从而实现保留更新的任务在待执行任务映射( <code>pendingTasks</code> ) 里。</li><li>第 12 行 ：添加任务编号到待执行队列( <code>processingOrder</code> ) 的头部。效果如下图：<img src="http://www.iocoder.cn/images/Eureka/2018_07_17/03.png" alt=""></li><li>第 15 至 18 行 ：如果待执行队列( <code>pendingTasks</code> )已满，清空重新执行队列( <code>processingOrder</code> )，放弃较早的任务。</li></ul></li><li><p>第 5 至 6 行 ：处理完接收队列( <code>acceptorQueue</code> )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainAcceptorQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (!acceptorQueue.isEmpty()) &#123; <span class="comment">// 循环，直到接收队列为空</span></div><div class="line">      appendTaskHolder(acceptorQueue.poll());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTaskHolder</span><span class="params">(TaskHolder&lt;ID, T&gt; taskHolder)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果待执行队列已满，移除待处理队列，放弃较早的任务</span></div><div class="line">  <span class="keyword">if</span> (isFull()) &#123;</div><div class="line">      pendingTasks.remove(processingOrder.poll());</div><div class="line">      queueOverflows++;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加到待执行队列</span></div><div class="line">  TaskHolder&lt;ID, T&gt; previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);</div><div class="line">  <span class="keyword">if</span> (previousTask == <span class="keyword">null</span>) &#123;</div><div class="line">      processingOrder.add(taskHolder.getId());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      overriddenTasks++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 8 至 17 行 ：当所有队列为空，阻塞从接收队列( <code>acceptorQueue</code> ) 拉取任务 10 ms。若拉取到，添加到待执行队列( <code>processingOrder</code> )。</p></li></ul></li><li><p>第 12 至 16 行 ：计算可调度任务的最小时间( <code>scheduleTime</code> )。</p><ul><li>当 <code>scheduleTime</code> 小于当前时间，不重新计算，即此时需要延迟等待调度。</li><li>当 <code>scheduleTime</code> 大于等于当前时间，配合 <code>TrafficShaper#transmissionDelay(...)</code> 重新计算。</li></ul></li><li>第 19 行 ：当 <code>scheduleTime</code> 小于当前时间，执行任务的调度。</li><li><p>第 21 行 ：调用 <code>#assignBatchWork()</code> 方法，调度批量任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">assignBatchWork</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (hasEnoughTasksForNextBatch()) &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 获取 批量任务工作请求信号量</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">if</span> (batchWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line"> <span class="number">6</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">7</span>:             <span class="keyword">int</span> len = Math.min(maxBatchingSize, processingOrder.size());</div><div class="line"> <span class="number">8</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = <span class="keyword">new</span> ArrayList&lt;&gt;(len);</div><div class="line"> <span class="number">9</span>:             <span class="keyword">while</span> (holders.size() &lt; len &amp;&amp; !processingOrder.isEmpty()) &#123;</div><div class="line"><span class="number">10</span>:                 ID id = processingOrder.poll();</div><div class="line"><span class="number">11</span>:                 TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line"><span class="number">12</span>:                 <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">13</span>:                     holders.add(holder);</div><div class="line"><span class="number">14</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                     expiredTasks++;</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>:             <span class="comment">//</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (holders.isEmpty()) &#123; <span class="comment">// 未调度到批量任务，释放请求信号量</span></div><div class="line"><span class="number">20</span>:                 batchWorkRequests.release();</div><div class="line"><span class="number">21</span>:             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加批量任务到批量任务工作队列</span></div><div class="line"><span class="number">22</span>:                 batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">23</span>:                 batchWorkQueue.add(holders);</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:     &#125;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 2 行 ：调用 <code>#hasEnoughTasksForNextBatch()</code> 方法，判断是否有足够任务进行下一次批量任务调度：1）待执行任务( <code>processingOrder</code> )映射已满；或者 2）到达批量任务处理最大等待延迟。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEnoughTasksForNextBatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 待执行队列为空</span></div><div class="line">    <span class="keyword">if</span> (processingOrder.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 待执行任务映射已满</span></div><div class="line">    <span class="keyword">if</span> (pendingTasks.size() &gt;= maxBufferSize) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 到达批量任务处理最大等待延迟( 通过待处理队列的头部任务判断 )</span></div><div class="line">    TaskHolder&lt;ID, T&gt; nextHolder = pendingTasks.get(processingOrder.peek());</div><div class="line">    <span class="keyword">long</span> delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();</div><div class="line">    <span class="keyword">return</span> delay &gt;= maxBatchingDelay;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 5 至 17 行 ：获取批量任务( <code>holders</code> )。😈 你会发现，本文说了半天的批量任务，实际是 <code>List&lt;TaskHolder&lt;ID, T&gt;&gt;</code> 哈。</p></li><li>第 4 行 ：获取批量任务工作请求信号量( <code>batchWorkRequests</code> ) 。在任务执行器的批量任务执行器，每次执行时，发出 <code>batchWorkRequests</code> 。<strong>每一个信号量需要保证获取到一个批量任务</strong>。</li><li>第 19 至 20 行 ：未调度到批量任务，释放请求信号量，<strong>代表请求实际未完成，每一个信号量需要保证获取到一个批量任务</strong>。</li><li>第 21 至 24 行 ：添加批量任务到批量任务工作队列。</li><li>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务。</li></ul></li><li><p>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务，和 <code>#assignBatchWork()</code> 方法<strong>类似</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignSingleItemWork</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!processingOrder.isEmpty()) &#123; <span class="comment">// 待执行任队列不为空</span></div><div class="line">      <span class="comment">// 获取 单任务工作请求信号量</span></div><div class="line">      <span class="keyword">if</span> (singleItemWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line">          <span class="comment">// 【循环】获取单任务</span></div><div class="line">          <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">          <span class="keyword">while</span> (!processingOrder.isEmpty()) &#123;</div><div class="line">              ID id = processingOrder.poll(); <span class="comment">// 一定不为空</span></div><div class="line">              TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line">              <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123;</div><div class="line">                  singleItemWorkQueue.add(holder);</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">              expiredTasks++;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 获取不到单任务，释放请求信号量</span></div><div class="line">          singleItemWorkRequests.release();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 26 至 31 行 ：当调度任务前的待执行任务数( <code>totalItems</code> )等于当前待执行队列( <code>processingOrder</code> )的任务数，意味着：1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</p></li></ul><h1 id="10-任务执行器【执行任务】"><a href="#10-任务执行器【执行任务】" class="headerlink" title="10. 任务执行器【执行任务】"></a>10. 任务执行器【执行任务】</h1><h2 id="10-1-批量任务工作线程"><a href="#10-1-批量任务工作线程" class="headerlink" title="10.1 批量任务工作线程"></a>10.1 批量任务工作线程</h2><p>批量任务工作后台线程( BatchWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">4</span>:         <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">  <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line">  <span class="number">6</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = getWork();</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">  <span class="number">9</span>:             metrics.registerExpiryTimes(holders);</div><div class="line"> <span class="number">10</span>: </div><div class="line"> <span class="number">11</span>:             <span class="comment">// 获得实际批量任务</span></div><div class="line"> <span class="number">12</span>:             List&lt;T&gt; tasks = getTasksOf(holders);</div><div class="line"> <span class="number">13</span>:             <span class="comment">// 调用处理器执行任务</span></div><div class="line"> <span class="number">14</span>:             ProcessingResult result = processor.process(tasks);</div><div class="line"> <span class="number">15</span>:             <span class="keyword">switch</span> (result) &#123;</div><div class="line"> <span class="number">16</span>:                 <span class="keyword">case</span> Success:</div><div class="line"> <span class="number">17</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">18</span>:                 <span class="keyword">case</span> Congestion:</div><div class="line"> <span class="number">19</span>:                 <span class="keyword">case</span> TransientError:</div><div class="line"> <span class="number">20</span>:                     taskDispatcher.reprocess(holders, result); <span class="comment">// 提交重新处理</span></div><div class="line"> <span class="number">21</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">22</span>:                 <span class="keyword">case</span> PermanentError:</div><div class="line"> <span class="number">23</span>:                     logger.warn(<span class="string">"Discarding &#123;&#125; tasks of &#123;&#125; due to permanent error"</span>, holders.size(), workerName);</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line"> <span class="number">27</span>:             metrics.registerTaskResult(result, tasks.size());</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>:     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"> <span class="number">30</span>:         <span class="comment">// Ignore</span></div><div class="line"> <span class="number">31</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">32</span>:         <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"> <span class="number">33</span>:         logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line"> <span class="number">34</span>:     &#125;</div><div class="line"> <span class="number">35</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：无限循环执行调度，直到关闭。</li><li><p>第 6 行 ：调用 <code>getWork()</code> 方法，获取<strong>一个</strong>批量任务直到成功。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> List&lt;TaskHolder&lt;ID, T&gt;&gt; getWork() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 发起请求信号量，并获得批量任务的工作队列</span></div><div class="line"> <span class="number">3</span>:     BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; workQueue = taskDispatcher.requestWorkItems();</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 【循环】获取批量任务，直到成功</span></div><div class="line"> <span class="number">5</span>:     List&lt;TaskHolder&lt;ID, T&gt;&gt; result;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">7</span>:         result = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">while</span> (!isShutdown.get() &amp;&amp; result == <span class="keyword">null</span>);</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 3 行 ：调用 <code>TaskDispatcher#requestWorkItems()</code> 方法，发起请求信号量，并获得批量任务的工作队列。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatcher.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作请求信号量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; requestWorkItems() &#123;</div><div class="line">   batchWorkRequests.release();</div><div class="line">   <span class="keyword">return</span> batchWorkQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，批量任务工作队列( <code>batchWorkQueue</code> ) 和单任务工作队列( <code>singleItemWorkQueue</code> ) 是<strong>不同的队列</strong>。</li></ul></li><li><p>第 5 至 8 行 ：<strong>循环</strong>获取<strong>一个</strong>批量任务，直到成功。</p></li></ul></li><li><p>第 12 行 ：调用 <code>#getTasksOf(...)</code> 方法，获得<strong>实际</strong>批量任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">getTasksOf</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders)</span> </span>&#123;</div><div class="line">    List&lt;T&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(holders.size());</div><div class="line">    <span class="keyword">for</span> (TaskHolder&lt;ID, T&gt; holder : holders) &#123;</div><div class="line">        tasks.add(holder.getTask());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 14 至 24 行 ：调用处理器( TaskProcessor ) 执行任务。当任务执行结果为 <code>Congestion</code> 或 <code>TransientError</code> ，调用 <code>AcceptorExecutor#reprocess(...)</code> 提交<strong>整个批量任务</strong>重新处理，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprocess</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders, ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 重新执行队列</span></div><div class="line">   reprocessQueue.addAll(holders);</div><div class="line"></div><div class="line">   <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">   replayedTasks += holders.size();</div><div class="line">   </div><div class="line">   <span class="comment">// 提交任务结果给 TrafficShaper</span></div><div class="line">   trafficShaper.registerFailure(processingResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="10-2-单任务工作线程"><a href="#10-2-单任务工作线程" class="headerlink" title="10.2 单任务工作线程"></a>10.2 单任务工作线程</h2><p>单任务工作后台线程( SingleTaskWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务，和 <code>BatchWorkerRunnable#run(...)</code> 基本类似，就不啰嗦了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// SingleTaskWorkerRunnable.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">          <span class="comment">// 发起请求信号量，并获得单任务的工作队列</span></div><div class="line">          BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; workQueue = taskDispatcher.requestWorkItem();</div><div class="line">          TaskHolder&lt;ID, T&gt; taskHolder;</div><div class="line">          <span class="comment">// 【循环】获取单任务，直到成功</span></div><div class="line">          <span class="keyword">while</span> ((taskHolder = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS)) == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (isShutdown.get()) &#123;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">          metrics.registerExpiryTime(taskHolder);</div><div class="line">          <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">// 调用处理器执行任务</span></div><div class="line">              ProcessingResult result = processor.process(taskHolder.getTask());</div><div class="line">              <span class="keyword">switch</span> (result) &#123;</div><div class="line">                  <span class="keyword">case</span> Success:</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> Congestion:</div><div class="line">                  <span class="keyword">case</span> TransientError:</div><div class="line">                      taskDispatcher.reprocess(taskHolder, result); <span class="comment">// 提交重新处理</span></div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> PermanentError:</div><div class="line">                      logger.warn(<span class="string">"Discarding a task of &#123;&#125; due to permanent error"</span>, workerName);</div><div class="line">              &#125;</div><div class="line">              <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">              metrics.registerTaskResult(result, <span class="number">1</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      <span class="comment">// Ignore</span></div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">      <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line">      logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 又是一篇长文。建议边看代码，边对照着整体流程图，理解实际不难。</p><p>当然，欢迎你有任何疑问，在我的公众号( <strong>芋道源码</strong> ) 留言。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/batch-tasks/&quot;&gt;http://www.iocoder.cn/Eureka/batch-tasks/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-override-status/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-override-status/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">http://www.iocoder.cn/Eureka/instance-registry-override-status/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">2. 应用实例覆盖状态变更接口</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">2.1 更新应用实例覆盖状态</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">3. 应用实例覆盖状态删除接口</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">3.1 删除应用实例覆盖状态</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4. 应用实例覆盖状态映射</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.1 应用实例状态覆盖规则</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.2 注册场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.3 续租场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.4 下线场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.5 过期场景</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">5. 客户端调用接口</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>应用实例的覆盖状态属性</strong>。</p><p>这里要注意下，不是应用实例的状态( <code>status</code> )，而是覆盖状态( <code>overridestatus</code> ) 。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> InstanceStatus overriddenstatus = InstanceStatus.UNKNOWN;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略属性和方法</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用 Eureka-Server HTTP Restful 接口 <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code> 对应用实例覆盖状态的变更，从而达到<strong>主动</strong>的、<strong>强制</strong>的变更应用实例状态。注意，<strong>实际不会真的修改 Eureka-Client 应用实例的状态，而是修改在 Eureka-Server 注册的应用实例的状态</strong>。</p><p>通过这样的方式，Eureka-Client 在获取到注册信息时，并且配置 <code>eureka.shouldFilterOnlyUpInstances = true</code>，过滤掉非 <code>InstanceStatus.UP</code> 的应用实例，从而避免调动该实例，以达到应用实例的<strong>暂停服务( <code>InstanceStatus.OUT_OF_SERVICE</code> )，而无需关闭应用实例</strong>。</p><p>因此，大多数情况下，调用该接口的目的，将应用实例状态在 ( <code>InstanceStatus.UP</code> ) 和  ( <code>InstanceStatus.OUT_OF_SERVICE</code> ) 之间切换。引用官方代码上的注释如下：</p><blockquote><p><code>AbstractInstanceRegistry#statusUpdate</code> 方法注释<br>Updates the status of an instance.<br>Normally happens to put an instance between {@link InstanceStatus#OUT_OF_SERVICE} and {@link InstanceStatus#UP} to put the instance in and out of traffic.</p></blockquote><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><hr><p>接口 <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code> 实际是两个：</p><ul><li>PUT <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code></li><li>DELETE <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code></li></ul><p>下面，我们逐节分享这两接口的代码实现。</p><h1 id="2-应用实例覆盖状态变更接口"><a href="#2-应用实例覆盖状态变更接口" class="headerlink" title="2. 应用实例覆盖状态变更接口"></a>2. 应用实例覆盖状态变更接口</h1><p>应用实例覆盖状态变更接口，映射 <code>InstanceResource#statusUpdate()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"status"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">statusUpdate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @QueryParam(<span class="string">"value"</span>)</span> String newStatus,</span></div><div class="line"><span class="function">       @<span class="title">HeaderParam</span><span class="params">(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 应用实例不存在</span></div><div class="line">       <span class="keyword">if</span> (registry.getInstanceByAppAndId(app.getName(), id) == <span class="keyword">null</span>) &#123;</div><div class="line">           logger.warn(<span class="string">"Instance not found: &#123;&#125;/&#123;&#125;"</span>, app.getName(), id);</div><div class="line">           <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 覆盖状态更新</span></div><div class="line">       <span class="keyword">boolean</span> isSuccess = registry.statusUpdate(app.getName(), id,</div><div class="line">               InstanceStatus.valueOf(newStatus), lastDirtyTimestamp,</div><div class="line">               <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">       <span class="comment">// 返回结果</span></div><div class="line">       <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">           logger.info(<span class="string">"Status updated: "</span> + app.getName() + <span class="string">" - "</span> + id</div><div class="line">                   + <span class="string">" - "</span> + newStatus);</div><div class="line">           <span class="keyword">return</span> Response.ok().build();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unable to update status: "</span> + app.getName() + <span class="string">" - "</span></div><div class="line">                   + id + <span class="string">" - "</span> + newStatus);</div><div class="line">           <span class="keyword">return</span> Response.serverError().build();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Error updating instance &#123;&#125; for status &#123;&#125;"</span>, id,</div><div class="line">               newStatus);</div><div class="line">       <span class="keyword">return</span> Response.serverError().build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>PeerAwareInstanceRegistryImpl#statusUpdate(...)</code> 方法，更新应用实例覆盖状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> InstanceStatus newStatus, String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) &#123;</div><div class="line">       <span class="comment">// Eureka-Server 集群同步</span></div><div class="line">       replicateToPeers(Action.StatusUpdate, appName, id, <span class="keyword">null</span>, newStatus, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#statusUpdate(...)</code> 方法，更新应用实例覆盖状态。</li></ul></li></ul><h2 id="2-1-更新应用实例覆盖状态"><a href="#2-1-更新应用实例覆盖状态" class="headerlink" title="2.1 更新应用实例覆盖状态"></a>2.1 更新应用实例覆盖状态</h2><p>调用 <code>AbstractInstanceRegistry#statusUpdate(...)</code> 方法，更新应用实例覆盖状态，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                             InstanceStatus newStatus, String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:                             <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// TODO  为什么是读锁</span></div><div class="line"> <span class="number">7</span>:         read.lock();</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 添加 覆盖状态变更次数 到 监控</span></div><div class="line"> <span class="number">9</span>:         STATUS_UPDATE.increment(isReplication);</div><div class="line"><span class="number">10</span>:         <span class="comment">// 获得 租约</span></div><div class="line"><span class="number">11</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">12</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">null</span>;</div><div class="line"><span class="number">13</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:             lease = gMap.get(id);</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (lease == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">21</span>:             lease.renew();</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:             <span class="comment">// 应用实例信息不存在( 防御型编程 )</span></div><div class="line"><span class="number">24</span>:             InstanceInfo info = lease.getHolder();</div><div class="line"><span class="number">25</span>:             <span class="comment">// Lease is always created with its instance info object.</span></div><div class="line"><span class="number">26</span>:             <span class="comment">// This log statement is provided as a safeguard, in case this invariant is violated.</span></div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>:                 logger.error(<span class="string">"Found Lease without a holder for instance id &#123;&#125;"</span>, id);</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:             <span class="comment">//</span></div><div class="line"><span class="number">31</span>:             <span class="keyword">if</span> ((info != <span class="keyword">null</span>) &amp;&amp; !(info.getStatus().equals(newStatus))) &#123;</div><div class="line"><span class="number">32</span>:                 <span class="comment">// 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"><span class="number">33</span>:                 <span class="comment">// Mark service as UP if needed</span></div><div class="line"><span class="number">34</span>:                 <span class="keyword">if</span> (InstanceStatus.UP.equals(newStatus)) &#123;</div><div class="line"><span class="number">35</span>:                     lease.serviceUp();</div><div class="line"><span class="number">36</span>:                 &#125;</div><div class="line"><span class="number">37</span>:                 <span class="comment">// 添加到 应用实例覆盖状态映射</span></div><div class="line"><span class="number">38</span>:                 <span class="comment">// This is NAC overridden status</span></div><div class="line"><span class="number">39</span>:                 overriddenInstanceStatusMap.put(id, newStatus);</div><div class="line"><span class="number">40</span>:                 <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"><span class="number">41</span>:                 <span class="comment">// Set it for transfer of overridden status to replica on</span></div><div class="line"><span class="number">42</span>:                 <span class="comment">// replica start up</span></div><div class="line"><span class="number">43</span>:                 info.setOverriddenStatus(newStatus);</div><div class="line"><span class="number">44</span>:                 <span class="comment">// 设置 应用实例信息 数据不一致时间</span></div><div class="line"><span class="number">45</span>:                 <span class="keyword">long</span> replicaDirtyTimestamp = <span class="number">0</span>;</div><div class="line"><span class="number">46</span>:                 <span class="comment">// 设置 应用实例状态</span></div><div class="line"><span class="number">47</span>:                 info.setStatusWithoutDirty(newStatus);</div><div class="line"><span class="number">48</span>:                 <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">49</span>:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</div><div class="line"><span class="number">50</span>:                 &#125;</div><div class="line"><span class="number">51</span>:                 <span class="comment">// If the replication's dirty timestamp is more than the existing one, just update</span></div><div class="line"><span class="number">52</span>:                 <span class="comment">// it to the replica's.</span></div><div class="line"><span class="number">53</span>:                 <span class="keyword">if</span> (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) &#123;</div><div class="line"><span class="number">54</span>:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);</div><div class="line"><span class="number">55</span>:                 &#125;</div><div class="line"><span class="number">56</span>:                 <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">57</span>:                 info.setActionType(ActionType.MODIFIED);</div><div class="line"><span class="number">58</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">59</span>:                 <span class="comment">// 设置 最后更新时间</span></div><div class="line"><span class="number">60</span>:                 info.setLastUpdatedTimestamp();</div><div class="line"><span class="number">61</span>:                 <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">62</span>:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());</div><div class="line"><span class="number">63</span>:             &#125;</div><div class="line"><span class="number">64</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">65</span>:         &#125;</div><div class="line"><span class="number">66</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">67</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">68</span>:         read.unlock();</div><div class="line"><span class="number">69</span>:     &#125;</div><div class="line"><span class="number">70</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 至 7 行 ：TODO[0026] ：读锁</li><li>第 8 至 9 行 ：添加覆盖状态变更次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 10 至 15 行 ：获得租约。</li><li>第 16 至 18 行 ：租约不存在，返回更新失败。</li><li>第 20 至 21 行 ：设置租约最后更新时间( 续租 )。</li><li>第 23 至 29 行 ：持有租约的应用实例不存在，理论来说不会出现，防御性编程。</li><li>第 31 行 ：<strong>应用实例当前状态和覆该状态不一致时才更新覆盖状态</strong>。</li><li>第 32 至 36 行 ：当覆盖状态是 <code>InstanceStatus.UP</code>，设置租约的开始服务的时间戳（只有第一次有效）。</li><li><p>第 37 至 39 行 ：添加到应用实例覆盖状态映射( <code>overriddenInstanceStatusMap</code> )。此处英文 <code>&quot;NAC&quot;</code> 可能是 <code>&quot;Network Access Control&quot;</code> 的缩写，感兴趣的可以看看 <a href="https://en.wikipedia.org/wiki/Network_Access_Control" rel="external nofollow noopener noreferrer" target="_blank">《Network Access Control》</a> 。<code>overriddenInstanceStatusMap</code> 属性代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 应用实例覆盖状态映射</span></div><div class="line"><span class="comment">* key：应用实例编号</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String, InstanceStatus&gt; overriddenInstanceStatusMap = CacheBuilder</div><div class="line">      .newBuilder().initialCapacity(<span class="number">500</span>)</div><div class="line">      .expireAfterAccess(<span class="number">1</span>, TimeUnit.HOURS)</div><div class="line">      .&lt;String, InstanceStatus&gt;build().asMap();</div></pre></td></tr></table></figure><ul><li>有效期 1 小时。每次访问后会刷新有效期，在后文你会看到对其的访问。</li></ul></li><li><p>第 40 至 43 行 ：设置应用实例的覆盖状态。用于 Eureka-Server 集群同步。</p></li><li>第 46 至 47 行 ：<strong>设置应用实例状态</strong>。设置后，Eureka-Client 拉取注册信息，被更新覆盖状态的应用实例就是设置的状态。</li><li>第 48 至 55 行 ：设置应用实例的数据不一致时间。用于 Eureka-Server 集群同步。</li><li>第 56 至 58 行 ：添加应用实例到最近租约变更记录队列。</li><li>第 59 至 60 行 ：设置应用实例的最后更新时间( <code>lastUpdatedTimestamp</code> )。<code>lastUpdatedTimestamp</code> 主要用于记录最后更新时间，无实际业务用途。</li><li>第 61 至 62 行 ：设置响应缓存过期。</li><li>第 64 行 ：返回更新成功。</li><li>第 68 行 ：释放读锁。</li></ul><h1 id="3-应用实例覆盖状态删除接口"><a href="#3-应用实例覆盖状态删除接口" class="headerlink" title="3. 应用实例覆盖状态删除接口"></a>3. 应用实例覆盖状态删除接口</h1><p>当我们不需要应用实例的覆盖状态时，调度接口接口进行删除。关联官方 <code>issue#89</code> ：<a href="https://github.com/Netflix/eureka/issues/89" rel="external nofollow noopener noreferrer" target="_blank">Provide an API to remove all overridden status</a>。</p><p>应用实例覆盖状态删除接口，映射 <code>InstanceResource#deleteStatusUpdate()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"status"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">deleteStatusUpdate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"value"</span>)</span> String newStatusValue,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 应用实例不存在</span></div><div class="line">       <span class="keyword">if</span> (registry.getInstanceByAppAndId(app.getName(), id) == <span class="keyword">null</span>) &#123;</div><div class="line">           logger.warn(<span class="string">"Instance not found: &#123;&#125;/&#123;&#125;"</span>, app.getName(), id);</div><div class="line">           <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 覆盖状态删除</span></div><div class="line">       InstanceStatus newStatus = newStatusValue == <span class="keyword">null</span> ? InstanceStatus.UNKNOWN : InstanceStatus.valueOf(newStatusValue);</div><div class="line">       <span class="keyword">boolean</span> isSuccess = registry.deleteStatusOverride(app.getName(), id,</div><div class="line">               newStatus, lastDirtyTimestamp, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">       <span class="comment">// 返回结果</span></div><div class="line">       <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">           logger.info(<span class="string">"Status override removed: "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">           <span class="keyword">return</span> Response.ok().build();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unable to remove status override: "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">           <span class="keyword">return</span> Response.serverError().build();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Error removing instance's &#123;&#125; status override"</span>, id);</div><div class="line">       <span class="keyword">return</span> Response.serverError().build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>请求参数 <code>newStatusValue</code> ，设置应用实例的状态。大多数情况下，<code>newStatusValue</code> 要和应用实例实际的状态一致，因为该应用实例的 Eureka-Client 不会从 Eureka-Server 拉取到该应用状态 <code>newStatusValue</code> 。另外一种方式，不传递该参数，相当于 <code>UNKNOWN</code> 状态，这样，Eureka-Client 会主动向 Eureka-Server 再次发起注册，具体原因在 [「4.3 续租场景」] 详细解析，更加推荐的方式。</li><li><p>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params">                                   InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                   String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) &#123;</div><div class="line">       <span class="comment">// Eureka-Server 集群同步</span></div><div class="line">       replicateToPeers(Action.DeleteStatusOverride, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。</li></ul></li></ul><h2 id="3-1-删除应用实例覆盖状态"><a href="#3-1-删除应用实例覆盖状态" class="headerlink" title="3.1 删除应用实例覆盖状态"></a>3.1 删除应用实例覆盖状态</h2><p>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                                     InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:                                     String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">5</span>:                                     <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// TODO  为什么是读锁</span></div><div class="line"> <span class="number">8</span>:         read.lock();</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 添加 覆盖状态删除次数 到 监控</span></div><div class="line"><span class="number">10</span>:         STATUS_OVERRIDE_DELETE.increment(isReplication);</div><div class="line"><span class="number">11</span>:         <span class="comment">// 获得 租约</span></div><div class="line"><span class="number">12</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">13</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">null</span>;</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">15</span>:             lease = gMap.get(id);</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (lease == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">20</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">21</span>:             <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">22</span>:             lease.renew();</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:             <span class="comment">// 应用实例信息不存在( 防御型编程 )</span></div><div class="line"><span class="number">25</span>:             InstanceInfo info = lease.getHolder();</div><div class="line"><span class="number">26</span>:             <span class="comment">// Lease is always created with its instance info object.</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// This log statement is provided as a safeguard, in case this invariant is violated.</span></div><div class="line"><span class="number">28</span>:             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:                 logger.error(<span class="string">"Found Lease without a holder for instance id &#123;&#125;"</span>, id);</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:             <span class="comment">// 移除 应用实例覆盖状态</span></div><div class="line"><span class="number">33</span>:             InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);</div><div class="line"><span class="number">34</span>:             <span class="keyword">if</span> (currentOverride != <span class="keyword">null</span> &amp;&amp; info != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>:                 <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"><span class="number">36</span>:                 info.setOverriddenStatus(InstanceStatus.UNKNOWN);</div><div class="line"><span class="number">37</span>:                 <span class="comment">// 设置 应用实例状态</span></div><div class="line"><span class="number">38</span>:                 info.setStatusWithoutDirty(newStatus);</div><div class="line"><span class="number">39</span>:                 <span class="comment">// 设置 应用实例信息 数据不一致时间</span></div><div class="line"><span class="number">40</span>:                 <span class="keyword">long</span> replicaDirtyTimestamp = <span class="number">0</span>;</div><div class="line"><span class="number">41</span>:                 <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">42</span>:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</div><div class="line"><span class="number">43</span>:                 &#125;</div><div class="line"><span class="number">44</span>:                 <span class="comment">// If the replication's dirty timestamp is more than the existing one, just update</span></div><div class="line"><span class="number">45</span>:                 <span class="comment">// it to the replica's.</span></div><div class="line"><span class="number">46</span>:                 <span class="keyword">if</span> (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) &#123;</div><div class="line"><span class="number">47</span>:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);</div><div class="line"><span class="number">48</span>:                 &#125;</div><div class="line"><span class="number">49</span>:                 <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">50</span>:                 info.setActionType(ActionType.MODIFIED);</div><div class="line"><span class="number">51</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">52</span>:                 <span class="comment">// 设置 最后更新时间</span></div><div class="line"><span class="number">53</span>:                 info.setLastUpdatedTimestamp();</div><div class="line"><span class="number">54</span>:                 <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">55</span>:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());</div><div class="line"><span class="number">56</span>:             &#125;</div><div class="line"><span class="number">57</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">60</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">61</span>:         read.unlock();</div><div class="line"><span class="number">62</span>:     &#125;</div><div class="line"><span class="number">63</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 8 行 ：TODO[0026] ：写锁</li><li>第 9 至 10 行 ：添加覆盖状态删除次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 11 至 16 行 ：获得租约。</li><li>第 17 至 19 行 ：租约不存在，返回更新失败。</li><li>第 21 至 22 行 ：设置租约最后更新时间( 续租 )。</li><li>第 24 至 30 行 ：持有租约的应用实例不存在，理论来说不会出现，防御性编程。</li><li>第 32 至 33 行 ：移除出应用实例覆盖状态映射( <code>overriddenInstanceStatusMap</code> )。</li><li>第 34 行 ：<strong>应用实例的覆盖状态存在才设置状态</strong>。</li><li>第 35 至 36 行 ：设置应用实例的覆盖状态为 InstanceStatus.UNKNOWN。用于 Eureka-Server 集群同步。</li><li>第 37 至 38 行 ：设置应用实例的状态为 <code>newStatus</code>。设置后，Eureka-Client 拉取注册信息，被更新覆盖状态的应用实例就是设置的状态。</li><li>第 39 至 48 行 ：设置应用实例的数据不一致时间。用于 Eureka-Server 集群同步。</li><li>第 49 至 51 行 ：添加应用实例到最近租约变更记录队列。</li><li>第 52 至 53 行 ：设置应用实例的最后更新时间( <code>lastUpdatedTimestamp</code> )。<code>lastUpdatedTimestamp</code> 主要用于记录最后更新时间，无实际业务用途。</li><li>第 54 至 55 行 ：设置响应缓存过期。</li><li>第 57 行 ：返回更新成功。</li><li>第 61 行 ：释放读锁。</li></ul><h1 id="4-应用实例覆盖状态映射"><a href="#4-应用实例覆盖状态映射" class="headerlink" title="4. 应用实例覆盖状态映射"></a>4. 应用实例覆盖状态映射</h1><p>虽然我们在上面代码，使用覆盖状态( <code>overridestatus</code> )设置到应用实例的状态( <code>status</code> )，<strong>实际调用 <code>AbstractInstanceRegistry#getOverriddenInstanceStatus(...)</code> 方法，根据应用实例状态覆盖规则( InstanceStatusOverrideRule )进行计算最终应用实例的状态</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="keyword">protected</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getOverriddenInstanceStatus</span><span class="params">(InstanceInfo r,</span></span></div><div class="line"><span class="function"><span class="params">                                                               Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                                               <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   InstanceStatusOverrideRule rule = getInstanceInfoOverrideRule();</div><div class="line">   logger.debug(<span class="string">"Processing override status using rule: &#123;&#125;"</span>, rule);</div><div class="line">   <span class="keyword">return</span> rule.apply(r, existingLease, isReplication).status();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> InstanceStatusOverrideRule <span class="title">getInstanceInfoOverrideRule</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getInstanceInfoOverrideRule()</code> 方法，获取应用实例状态覆盖规则( InstanceStatusOverrideRule )。在 PeerAwareInstanceRegistryImpl 里该方法实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule instanceStatusOverrideRule;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PeerAwareInstanceRegistryImpl</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClient eurekaClient</span></span></div><div class="line"><span class="function"><span class="params">    )</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其它方法</span></div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.instanceStatusOverrideRule = <span class="keyword">new</span> FirstMatchWinsCompositeRule(</div><div class="line">        <span class="keyword">new</span> DownOrStartingRule(),</div><div class="line">        <span class="keyword">new</span> OverrideExistsRule(overriddenInstanceStatusMap), </div><div class="line">        <span class="keyword">new</span> LeaseExistsRule());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> InstanceStatusOverrideRule <span class="title">getInstanceInfoOverrideRule</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.instanceStatusOverrideRule;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="4-1-应用实例状态覆盖规则"><a href="#4-1-应用实例状态覆盖规则" class="headerlink" title="4.1 应用实例状态覆盖规则"></a>4.1 应用实例状态覆盖规则</h2><p><code>com.netflix.eureka.registry.rule.InstanceStatusOverrideRule</code> ，应用实例状态覆盖规则<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceStatusOverrideRule.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">     * Match this rule.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> instanceInfo The instance info whose status we care about. 关注状态的应用实例对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> existingLease Does the instance have an existing lease already? If so let's consider that. 已存在的租约</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> isReplication When overriding consider if we are under a replication mode from other servers. 是否是 Eureka-Server 发起的请求</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> A result with whether we matched and what we propose the status to be overriden to.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function">StatusOverrideResult <span class="title">apply</span><span class="params">(<span class="keyword">final</span> InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// StatusOverrideResult.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusOverrideResult</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StatusOverrideResult NO_MATCH = <span class="keyword">new</span> StatusOverrideResult(<span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StatusOverrideResult <span class="title">matchingStatus</span><span class="params">(InstanceInfo.InstanceStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatusOverrideResult(<span class="keyword">true</span>, status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Does the rule match?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> matches;</div><div class="line"></div><div class="line">    <span class="comment">// The status computed by the rule.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo.InstanceStatus status;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StatusOverrideResult</span><span class="params">(<span class="keyword">boolean</span> matches, InstanceInfo.InstanceStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.matches = matches;</div><div class="line">        <span class="keyword">this</span>.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> matches;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">status</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#apply(...)</code> 方法参数 <code>instanceInfo</code> 代表的是<strong>关注状态</strong>的应用实例，和方法参数 <code>existingLease</code> 里的应用实例不一定是同一个，在 <a href="#">「4.1.6 总结」</a> 详细解析。</li><li><code>com.netflix.eureka.registry.rule.StatusOverrideResult</code> ，状态覆盖结果。当匹配成功，返回 <code>matches = true</code> ；否则，返回 <code>matches = false</code> 。</li></ul><p><strong>实现类关系如下</strong>：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_10/01.png" alt=""></p><ul><li>AsgEnabledRule ，亚马逊 AWS 专用，跳过。</li></ul><h3 id="4-1-1-FirstMatchWinsCompositeRule"><a href="#4-1-1-FirstMatchWinsCompositeRule" class="headerlink" title="4.1.1 FirstMatchWinsCompositeRule"></a>4.1.1 FirstMatchWinsCompositeRule</h3><p><code>com.netflix.eureka.registry.rule.FirstMatchWinsCompositeRule</code> ，<strong>复合</strong>规则，以第一个匹配成功为准。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMatchWinsCompositeRule</span> <span class="keyword">implements</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 复合规则集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule[] rules;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认规则</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule defaultRule;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String compositeRuleName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstMatchWinsCompositeRule</span><span class="params">(InstanceStatusOverrideRule... rules)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.rules = rules;</div><div class="line">        <span class="keyword">this</span>.defaultRule = <span class="keyword">new</span> AlwaysMatchInstanceStatusRule();</div><div class="line">        <span class="comment">// Let's build up and "cache" the rule name to be used by toString();</span></div><div class="line">        List&lt;String&gt; ruleNames = <span class="keyword">new</span> ArrayList&lt;&gt;(rules.length+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rules.length; ++i) &#123;</div><div class="line">            ruleNames.add(rules[i].toString());</div><div class="line">        &#125;</div><div class="line">        ruleNames.add(defaultRule.toString());</div><div class="line">        compositeRuleName = ruleNames.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                      Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                      <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        <span class="comment">// 使用复合规则，顺序匹配，直到匹配成功</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rules.length; ++i) &#123;</div><div class="line">            StatusOverrideResult result = <span class="keyword">this</span>.rules[i].apply(instanceInfo, existingLease, isReplication);</div><div class="line">            <span class="keyword">if</span> (result.matches()) &#123;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 使用默认规则</span></div><div class="line">        <span class="keyword">return</span> defaultRule.apply(instanceInfo, existingLease, isReplication);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.compositeRuleName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>rules</code> 属性，<strong>复合</strong>规则集合。在 PeerAwareInstanceRegistryImpl 里，我们可以看到该属性为 [ DownOrStartingRule , OverrideExistsRule , LeaseExistsRule ] 。</li><li><code>defaultRule</code> 属性，默认规则，值为 AlwaysMatchInstanceStatusRule 。</li><li><code>#apply()</code> 方法，优先使用<strong>复合</strong>规则( <code>rules</code> )，顺序匹配，直到匹配成功 。当未匹配成功，使用默认规则( <code>defaultRule</code> ) 。</li></ul><h3 id="4-1-2-DownOrStartingRule"><a href="#4-1-2-DownOrStartingRule" class="headerlink" title="4.1.2 DownOrStartingRule"></a>4.1.2 DownOrStartingRule</h3><p><code>com.netflix.eureka.registry.rule.DownOrStartingRule</code> ，匹配 <code>InstanceInfo.InstanceStatus.DOWN</code> 或者 <code>InstanceInfo.InstanceStatus.STARTING</code> 状态。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that</span></div><div class="line">   <span class="comment">// The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what</span></div><div class="line">   <span class="comment">// the client says. The same is the case with replica as well.</span></div><div class="line">   <span class="comment">// The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be</span></div><div class="line">   <span class="comment">// currently in SERVICE</span></div><div class="line">   <span class="keyword">if</span> ((!InstanceInfo.InstanceStatus.UP.equals(instanceInfo.getStatus()))</div><div class="line">           &amp;&amp; (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(instanceInfo.getStatus()))) &#123;</div><div class="line">       logger.debug(<span class="string">"Trusting the instance status &#123;&#125; from replica or instance for instance &#123;&#125;"</span>,</div><div class="line">               instanceInfo.getStatus(), instanceInfo.getId());</div><div class="line">       <span class="keyword">return</span> StatusOverrideResult.matchingStatus(instanceInfo.getStatus());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，使用的是 <code>instanceInfo</code> 。</li></ul><h3 id="4-1-3-OverrideExistsRule"><a href="#4-1-3-OverrideExistsRule" class="headerlink" title="4.1.3 OverrideExistsRule"></a>4.1.3 OverrideExistsRule</h3><p><code>com.netflix.eureka.registry.rule.OverrideExistsRule</code> ，匹配应用实例覆盖状态映射( <code>statusOverrides</code> ) 。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideExistsRule</span> <span class="keyword">implements</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> Map&lt;String, InstanceInfo.InstanceStatus&gt; statusOverrides;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo, Lease&lt;InstanceInfo&gt; existingLease, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        InstanceInfo.InstanceStatus overridden = statusOverrides.get(instanceInfo.getId());</div><div class="line">        <span class="comment">// If there are instance specific overrides, then they win - otherwise the ASG status</span></div><div class="line">        <span class="keyword">if</span> (overridden != <span class="keyword">null</span>) &#123;</div><div class="line">            logger.debug(<span class="string">"The instance specific override for instance &#123;&#125; and the value is &#123;&#125;"</span>,</div><div class="line">                    instanceInfo.getId(), overridden.name());</div><div class="line">            <span class="keyword">return</span> StatusOverrideResult.matchingStatus(overridden);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>statusOverrides</code> 属性，应用实例覆盖状态映射。在 PeerAwareInstanceRegistryImpl 里，使用 <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> 属性赋值。</li><li>上文我们提到 <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code>  每次访问刷新有效期，如果调用到 OverrideExistsRule ，则会不断刷新。从 DownOrStartingRule 看到，<code>instanceInfo</code> 处于 <code>InstanceInfo.InstanceStatus.DOWN</code> 或者 <code>InstanceInfo.InstanceStatus.STARTING</code> 才不会继续调用 OverrideExistsRule 匹配，<code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> 才有可能过期。</li></ul><h3 id="4-1-4-LeaseExistsRule"><a href="#4-1-4-LeaseExistsRule" class="headerlink" title="4.1.4 LeaseExistsRule"></a>4.1.4 LeaseExistsRule</h3><p><code>com.netflix.eureka.registry.rule.LeaseExistsRule</code> ，匹配已存在租约的应用实例的 <code>nstanceStatus.OUT_OF_SERVICE</code> 或者 <code>InstanceInfo.InstanceStatus.UP</code> 状态。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// This is for backward compatibility until all applications have ASG</span></div><div class="line">   <span class="comment">// names, otherwise while starting up</span></div><div class="line">   <span class="comment">// the client status may override status replicated from other servers</span></div><div class="line">   <span class="keyword">if</span> (!isReplication) &#123; <span class="comment">// 非 Eureka-Server 请求</span></div><div class="line">       InstanceInfo.InstanceStatus existingStatus = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</div><div class="line">           existingStatus = existingLease.getHolder().getStatus();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Allow server to have its way when the status is UP or OUT_OF_SERVICE</span></div><div class="line">       <span class="keyword">if</span> ((existingStatus != <span class="keyword">null</span>)</div><div class="line">               &amp;&amp; (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)</div><div class="line">               || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) &#123;</div><div class="line">           logger.debug(<span class="string">"There is already an existing lease with status &#123;&#125;  for instance &#123;&#125;"</span>,</div><div class="line">                   existingLease.getHolder().getStatus().name(),</div><div class="line">                   existingLease.getHolder().getId());</div><div class="line">           <span class="keyword">return</span> StatusOverrideResult.matchingStatus(existingLease.getHolder().getStatus());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，使用的是 <code>existingLease</code> ，并且非 Eureka-Server 请求。</li></ul><h3 id="4-1-5-AlwaysMatchInstanceStatusRule"><a href="#4-1-5-AlwaysMatchInstanceStatusRule" class="headerlink" title="4.1.5 AlwaysMatchInstanceStatusRule"></a>4.1.5 AlwaysMatchInstanceStatusRule</h3><p><code>com.netflix.eureka.registry.rule.AlwaysMatchInstanceStatusRule</code> ，总是匹配<strong>关注状态的实例对象</strong>( <code>instanceInfo</code> )的状态。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   logger.debug(<span class="string">"Returning the default instance status &#123;&#125; for instance &#123;&#125;"</span>, instanceInfo.getStatus(),</div><div class="line">           instanceInfo.getId());</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.matchingStatus(instanceInfo.getStatus());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，使用的是 <code>instanceInfo</code> 。</li></ul><h3 id="4-1-6-总结"><a href="#4-1-6-总结" class="headerlink" title="4.1.6 总结"></a>4.1.6 总结</h3><p>我们将 PeerAwareInstanceRegistryImpl 的应用实例覆盖状态规则梳理如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_10/02.png" alt=""></p><ul><li>应用实例状态是<strong>最重要</strong>的属性，没有之一，因而在最终实例状态的计算，以<strong>可信赖</strong>为主。</li><li>DownOrStartingRule ，<code>instanceInfo</code> 处于 <code>STARTING</code> 或者 <code>DOWN</code> 状态，应用实例可能不适合提供服务( 被请求 )，考虑<strong>可信赖</strong>，返回 <code>instanceInfo</code> 的状态。</li><li>OverrideExistsRule ，当存在覆盖状态( <code>statusoverrides</code> ) ，使用该状态，比较好理解。</li><li>LeaseExistsRule ，来自 Eureka-Client 的请求( 非 Eureka-Server 集群请求)，当 Eureka-Server 的实例状态<strong>存在</strong>，并且处于 <code>UP</code> 或则 <code>OUT_OF_SERVICE</code> ，保留当前状态。原因，<strong>禁止 Eureka-Client 主动在这两个状态之间切换。如果要切换，使用应用实例覆盖状态变更与删除接口</strong>。</li><li>AlwaysMatchInstanceStatusRule ，使用 <code>instanceInfo</code> 的状态返回，以保证能匹配到状态。</li><li>在下文中，你会看到，<code>#getOverriddenInstanceStatus()</code> 方法会在<strong>注册</strong>和<strong>续租</strong>使用到。结合上图，我们在 <a href="#">「4.2 注册场景」</a> 和 <a href="#">「4.3 续租场景」</a> 也会详细解析。</li></ul><ul><li>在下文中，你会看到，<code>#getOverriddenInstanceStatus()</code> 方法会在<strong>注册</strong>和<strong>续租</strong>使用到，方法参数 <code>instanceInfo</code> 情况如下：<ul><li><strong>注册时</strong> ：请求参数 <code>instanceInfo</code> ，和 <code>existingLease</code> 的应用实例属性不相等( 如果考虑 Eureka-Server 的 <code>LastDirtyTimestamp</code> 更大的情况，则类似 <strong>续租时的情况</strong> ) 。</li><li><strong>续租时</strong> ：使用 Eureka-Server 的 <code>existingLease</code> 的应用实例，两者相等。</li><li><strong>总的来说，可以将 <code>instanceInfo</code> 理解成请求方的状态</strong>。</li></ul></li><li>DownOrStartingRule ，</li></ul><h2 id="4-2-注册场景"><a href="#4-2-注册场景" class="headerlink" title="4.2 注册场景"></a>4.2 注册场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// （(省略代码) ）获取锁</span></div><div class="line">  <span class="number">4</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</div><div class="line">  <span class="number">5</span>:         <span class="comment">// (省略代码) 增加 注册次数 到 监控</span></div><div class="line">  <span class="number">6</span>:         <span class="comment">// (省略代码) 获得 应用实例信息 对应的 租约</span></div><div class="line">  <span class="number">7</span>:         Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</div><div class="line">  <span class="number">8</span>:         <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></div><div class="line">  <span class="number">9</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123; <span class="comment">// (省略代码) 已存在时，使用数据不一致的时间大的应用注册信息为有效的</span></div><div class="line"> <span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">11</span>:             <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line"> <span class="number">12</span>:             <span class="comment">// (省略代码) 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"> <span class="number">13</span>:         &#125;</div><div class="line"> <span class="number">14</span>:         <span class="comment">// 创建 租约</span></div><div class="line"> <span class="number">15</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</div><div class="line"> <span class="number">16</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123; <span class="comment">// 若租约已存在，设置 租约的开始服务的时间戳</span></div><div class="line"> <span class="number">17</span>:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</div><div class="line"> <span class="number">18</span>:         &#125;</div><div class="line"> <span class="number">19</span>:         <span class="comment">// 添加到 租约映射</span></div><div class="line"> <span class="number">20</span>:         gMap.put(registrant.getId(), lease);</div><div class="line"> <span class="number">21</span>:         <span class="comment">// (省略代码) 添加到 最近注册的调试队列</span></div><div class="line"> <span class="number">22</span>:         <span class="comment">// (省略代码) 添加到 应用实例覆盖状态映射（Eureka-Server 初始化使用）</span></div><div class="line"> <span class="number">23</span>:         <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"> <span class="number">24</span>:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">26</span>:             logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</div><div class="line"> <span class="number">27</span>:             registrant.setOverriddenStatus(overriddenStatusFromMap);</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:         <span class="comment">// 获得 应用实例状态</span></div><div class="line"> <span class="number">31</span>:         <span class="comment">// Set the status based on the overridden status rules</span></div><div class="line"> <span class="number">32</span>:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</div><div class="line"> <span class="number">33</span>:         <span class="comment">// 设置 应用实例状态</span></div><div class="line"> <span class="number">34</span>:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"> <span class="number">35</span>: </div><div class="line"> <span class="number">36</span>:         <span class="comment">// (省略代码) 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"> <span class="number">37</span>:         <span class="comment">// (省略代码) 设置 应用实例信息的操作类型 为 添加</span></div><div class="line"> <span class="number">38</span>:         <span class="comment">// (省略代码) 添加到 最近租约变更记录队列</span></div><div class="line"> <span class="number">39</span>:         <span class="comment">// (省略代码) 设置 租约的最后更新时间戳</span></div><div class="line"> <span class="number">40</span>:         <span class="comment">// (省略代码) 设置 响应缓存 过期</span></div><div class="line"> <span class="number">41</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">42</span>:         <span class="comment">// (省略代码) 释放锁</span></div><div class="line"> <span class="number">43</span>:     &#125;</div><div class="line"> <span class="number">44</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 行 ：获得<strong>已存在</strong>的租约( <code>existingLease</code> ) 。</li><li>第 15 行 ：创建<strong>新的</strong>租约( <code>lease</code> )。</li><li>第 24 至 28 行 ：设置应用实例的覆盖状态( <code>overridestatus</code> )，避免注册应用实例后，丢失覆盖状态。</li><li>第 30 至 32 行 ：<strong>获得应用实例最终状态</strong>。注意下，不考虑第 9 行代码的情况，<code>registrant</code> 和 <code>existingLease</code> 的应用实例不是同一个对象。</li><li>第 33 只 34 行 ：设置应用实例的状态。</li></ul><h2 id="4-3-续租场景"><a href="#4-3-续租场景" class="headerlink" title="4.3 续租场景"></a>4.3 续租场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// （省略代码）增加 续租次数 到 监控</span></div><div class="line">  <span class="number">3</span>:     <span class="comment">// 获得 租约</span></div><div class="line">  <span class="number">4</span>:     Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line">  <span class="number">5</span>:     Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line">  <span class="number">6</span>:     <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:         leaseToRenew = gMap.get(id);</div><div class="line">  <span class="number">8</span>:     &#125;</div><div class="line">  <span class="number">9</span>:     <span class="comment">// （省略代码）租约不存在</span></div><div class="line"> <span class="number">10</span>:     <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">11</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">12</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">13</span>:         InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line"> <span class="number">14</span>:         <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">15</span>:             <span class="comment">// 获得 应用实例状态</span></div><div class="line"> <span class="number">16</span>:             InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line"> <span class="number">17</span>:                     instanceInfo, leaseToRenew, isReplication);</div><div class="line"> <span class="number">18</span>:             <span class="comment">// 应用实例状态未知，无法续约</span></div><div class="line"> <span class="number">19</span>:             <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line"> <span class="number">20</span>:                 logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line"> <span class="number">21</span>:                         + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line"> <span class="number">22</span>:                 RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"> <span class="number">23</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>:             <span class="comment">// 设置 应用实例状态</span></div><div class="line"> <span class="number">26</span>:             <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line"> <span class="number">27</span>:                 Object[] args = &#123;</div><div class="line"> <span class="number">28</span>:                         instanceInfo.getStatus().name(),</div><div class="line"> <span class="number">29</span>:                         instanceInfo.getOverriddenStatus().name(),</div><div class="line"> <span class="number">30</span>:                         instanceInfo.getId()</div><div class="line"> <span class="number">31</span>:                 &#125;;</div><div class="line"> <span class="number">32</span>:                 logger.info(</div><div class="line"> <span class="number">33</span>:                         <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line"> <span class="number">34</span>:                                 + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line"> <span class="number">35</span>:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"> <span class="number">36</span>:             &#125;</div><div class="line"> <span class="number">37</span>:         &#125;</div><div class="line"> <span class="number">38</span>:         <span class="comment">// （省略代码）新增 续租每分钟次数</span></div><div class="line"> <span class="number">39</span>:         <span class="comment">// （省略代码）设置 租约最后更新时间（续租）</span></div><div class="line"> <span class="number">40</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> <span class="number">41</span>:     &#125;</div><div class="line"> <span class="number">42</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 15 至 17 行 ：获得应用实例的<strong>最终状态</strong>。</li><li>第 18 至 24 行 ：应用实例的<strong>最终状态</strong>为 <code>UNKNOWN</code>，无法续约 。返回 <code>false</code> 后，请求方( Eureka-Client 或者 Eureka-Server 集群其他节点 )会发起注册，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析。<strong>为什么会是 <code>UNKNOWN</code> 呢</strong>？在 <a href="#">「3. 应用实例覆盖状态删除接口」</a> 传递应用实例状态为 <code>UNKNOWN</code> 。</li><li>第 25 至 36 行 ：应用实例的状态与<strong>最终状态</strong>不相等，使用<strong>最终状态</strong>覆盖应用实例的状态。<strong>为什么会不相等</strong>呢？<code>#renew(...)</code> 和 <code>#statusUpdate(...)</code> 可以无锁，并行执行，如果 <ul><li><code>#renew(...)</code> 执行完第 16 行代码，获取到 <code>overriddenInstanceStatus</code> 后，恰巧 <code>#statusUpdate(...)</code> 执行完更新应用实例状态 <code>newStatus</code>，又恰好两者不相等，使用 <code>overriddenInstanceStatus</code> 覆盖掉应用实例的 <code>newStatus</code> 状态。</li><li><strong>那岂不是覆盖状态( <code>overriddenstatus</code> )反倒被覆盖</strong>？？？不会，在下一次心跳，应用实例的状态会被修正回来。当然，如果应用实例状态如果为 <code>UP</code> 或者 <code>STARTING</code> 不会被修正，也不应该被修正。</li></ul></li></ul><h2 id="4-4-下线场景"><a href="#4-4-下线场景" class="headerlink" title="4.4 下线场景"></a>4.4 下线场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// 移除 应用实例覆盖状态映射</span></div><div class="line">    InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</div><div class="line">    <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</div><div class="line">        logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-5-过期场景"><a href="#4-5-过期场景" class="headerlink" title="4.5 过期场景"></a>4.5 过期场景</h2><p>同 <a href="#">「4.4 下线场景」</a> 相同。</p><h1 id="5-客户端调用接口"><a href="#5-客户端调用接口" class="headerlink" title="5. 客户端调用接口"></a>5. 客户端调用接口</h1><p>对应用实例覆盖状态的变更和删除接口调用，点击如下方法查看，非常易懂，本文就不啰嗦了：</p><ul><li><a href="https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractJerseyEurekaHttpClient#statusUpdate(...)</code></a></li><li><a href="https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractJerseyEurekaHttpClient#deleteStatusOverride(...)</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>猜测覆盖状态的花费了较长时间，梳理应用实例覆盖规则耗费大量脑细胞。</p><p>下一篇，让我鸡鸡动动的，Eureka-Server 集群同步走起！</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-override-status/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-overrid
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（七）之增量获取</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2. 应用集合一致性哈希码</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2.1 计算公式</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2.2 合理性</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3. Eureka-Client 发起增量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.1 合并应用集合</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">4. Eureka-Server 接收全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.1 接收全量获取请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.2 最近租约变更记录队列</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.3 缓存读取</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 获取增量注册信息的过程</strong>。</p><p>前置阅读：<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》</a></p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/01.png" alt=""></p></blockquote><p>Eureka-Client 获取注册信息，分成<strong>全量获取</strong>和<strong>增量获取</strong>。默认配置下，Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，而后每 <strong>30</strong> 秒<strong>增量</strong>获取刷新<strong>本地缓存</strong>( 非“<strong>正常</strong>”情况下会是全量获取 )。</p><p>本文重点在于<strong>增量获取</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-应用集合一致性哈希码"><a href="#2-应用集合一致性哈希码" class="headerlink" title="2. 应用集合一致性哈希码"></a>2. 应用集合一致性哈希码</h1><p><code>Applications.appsHashCode</code> ，应用集合<strong>一致性哈希码</strong>。</p><p><strong>增量</strong>获取注册的应用集合( Applications ) 时，Eureka-Client 会获取到：</p><ol><li>Eureka-Server 近期变化( 注册、下线 )的应用集合</li><li>Eureka-Server 应用集合一致性哈希码</li></ol><p>Eureka-Client 将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并后进行计算本地的应用集合一致性哈希码。若两个<strong>哈希码</strong>相等，意味着增量获取成功；若不相等，意味着增量获取失败，Eureka-Client 重新和 Eureka-Server <strong>全量</strong>获取应用集合。</p><p>Eureka 比较应用集合一致性哈希码，和日常我们通过哈希码比较两个对象是否相等类似。</p><h2 id="2-1-计算公式"><a href="#2-1-计算公式" class="headerlink" title="2.1 计算公式"></a>2.1 计算公式</h2><p><code>appsHashCode = ${status}_${count}_</code></p><ul><li>使用每个应用实例状态( <code>status</code> ) + 数量( <code>count</code> )拼接出一致性哈希码。若数量为 0 ，该应用实例状态不进行拼接。<strong>状态以字符串大小排序</strong>。</li><li>举个例子，8 个 UP ，0 个 DOWN ，则 <code>appsHashCode = UP_8_</code> 。8 个 UP ，2 个 DOWN ，则 <code>appsHashCode = DOWN_2_UP_8_</code> 。</li><li><p>实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getReconcileHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 计数集合 key：应用实例状态</span></div><div class="line">   TreeMap&lt;String, AtomicInteger&gt; instanceCountMap = <span class="keyword">new</span> TreeMap&lt;String, AtomicInteger&gt;();</div><div class="line">   populateInstanceCountMap(instanceCountMap);</div><div class="line">   <span class="comment">// 计算 hashcode</span></div><div class="line">   <span class="keyword">return</span> getReconcileHashCode(instanceCountMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#populateInstanceCountMap()</code> 方法，计算每个应用实例状态的数量。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateInstanceCountMap</span><span class="params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Application app : <span class="keyword">this</span>.getRegisteredApplications()) &#123;</div><div class="line">       <span class="keyword">for</span> (InstanceInfo info : app.getInstancesAsIsFromEureka()) &#123;</div><div class="line">           <span class="comment">// 计数</span></div><div class="line">           AtomicInteger instanceCount = instanceCountMap.computeIfAbsent(info.getStatus().name(),</div><div class="line">                   k -&gt; <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>));</div><div class="line">           instanceCount.incrementAndGet();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Application&gt; <span class="title">getRegisteredApplications</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Application&gt;(<span class="keyword">this</span>.applications);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;InstanceInfo&gt; <span class="title">getInstancesAsIsFromEureka</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;InstanceInfo&gt;(<span class="keyword">this</span>.instances);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>计数那块代码，使用 Integer 即可，无需使用 AtomicInteger 。</li></ul></li></ul></li><li><p>调用 <code>#getReconcileHashCode()</code> 方法，计算 <code>hashcode</code> 。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getReconcileHashCode</span><span class="params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>&#123;</div><div class="line">   StringBuilder reconcileHashCode = <span class="keyword">new</span> StringBuilder(<span class="number">75</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, AtomicInteger&gt; mapEntry : instanceCountMap.entrySet()) &#123;</div><div class="line">       reconcileHashCode.append(mapEntry.getKey()).append(STATUS_DELIMITER) <span class="comment">// status</span></div><div class="line">               .append(mapEntry.getValue().get()).append(STATUS_DELIMITER); <span class="comment">// count</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> reconcileHashCode.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="2-2-合理性"><a href="#2-2-合理性" class="headerlink" title="2.2 合理性"></a>2.2 合理性</h2><p><strong>本小节，建议你理解完全文后，再回到此处</strong><br><strong>本小节，建议你理解完全文后，再回到此处</strong><br><strong>本小节，建议你理解完全文后，再回到此处</strong>  </p><p>笔者刚看完应用集合一致性哈希算法的计算公式，处于一脸懵逼的状态。这么精简的方式真的能够校验出数据的一致性么？不晓得有多少读者跟笔者有一样的疑惑。下面我们来论证该算法的合理性( 一本正经的胡说八道 )。</p><p>一致性哈希值通过<strong>状态 + 数量</strong>来计算，那么是不是可能状态总数是一样多，实际分布在不同的应用？那么我们列举模型如下：</p><table><thead><tr><th></th><th>UP</th></tr></thead><tbody><tr><td>应用A</td><td>m</td></tr><tr><td>应用B</td><td>n</td></tr></tbody></table><p>如果此时应用A 下线了 c 个原应用实例，应用B 注册了 c 个信应用实例，那么处于 UP 状态的数量仍然是 m + n 个。</p><ul><li>正常情况下，Eureka-Client 从 Eureka-Server 获取到<strong>完整的增量变化</strong>并合并，此时应用情况如下表格所示，两者是一致的，一致性哈希算法<strong>合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m - c</td></tr><tr><td>应用B</td><td>n + c</td><td>n + c</td></tr></tbody></table><ul><li>异常情况下【1】，变更记录队列全部过期。那 Eureka-Client 从 Eureka-Server 获取到<strong>空的增量变化</strong>并合并，此时应用情况如下表格所示，两者应用是不相同的， 一致性哈希值却是相等的，一致性哈希算法<strong>不合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m</td></tr><tr><td>应用B</td><td>n + c</td><td>n</td></tr></tbody></table><ul><li>异常情况下【2】，变更记录队列部分过期，例如应用A 和 应用B 都剩余 w 条变更记录。那 Eureka-Client 从 Eureka-Server 获取到<strong>部分的增量变化</strong>并合并，两者应用是不相同的，此时应用情况如下表格所示，一致性哈希值却是相等的，一致性哈希算法<strong>不合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m - w</td></tr><tr><td>应用B</td><td>n + c</td><td>n + w</td></tr></tbody></table><p>What ？ 从异常情况【1】【2】可以看到，一致性哈希算法竟然是<strong>不合理</strong>的，那么我们手动来做一次最精简的实验。实验如下：</p><ul><li>模拟场景：异常情况【1】，m = n = c = 1 。简单粗暴。</li><li>特别配置<ul><li><code>eureka.retentionTimeInMSInDeltaQueue = 1</code> ，变更记录队列每条记录存活时长 1 ms。用以实现 Eureka-Client 请求不到完整的增量变化。</li><li><code>eureka.deltaRetentionTimerIntervalInMs = 1</code> ，变更记录队列每条记录过期定时任务执行频率 1 ms。用以实现 Eureka-Client 请求不到完整的增量变化。</li><li><code>eureka.shouldUseReadOnlyResponseCache = false</code> ，禁用响应缓存的只读缓存。用以避免等待缓存刷新。</li><li><code>eureka.waitTimeInMsWhenSyncEmpty = 1</code> ，</li></ul></li><li>实验过程<ol><li>00:00 启动 Eureka-Server</li><li>00:30 启动应用A ，向 Eureka-Server 注册</li><li>01:00 启动 Eureka-Client ，向 Eureka-Server 获取注册信息，等待获取到应用A</li><li>01:30 关闭应用A 。立即启动应用B ，向 Eureka-Server 注册</li><li>等待 5 分钟，Eureka-Client 无法获取到应用B </li><li>此时应用情况如下表格所示，两者应用是不相同的，一致性哈希值却是相等的，一致性哈希算法<strong>不合理。</strong></li></ol></li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>0</td><td>1</td></tr><tr><td>应用B</td><td>1</td><td>0</td></tr></tbody></table><p>🙂<strong>结论</strong>🙂</p><p>当然排除掉特别极端的场景，Eureka-Client 从 Eureka-Server 因为网络异常导致一直同步不到增量变化，又恰好应用关闭和开启满足状态统计数量。另外，变更记录队列记录过期时长为 300 秒，增量获取频率为 30 秒，获取的次数有 10 次左右。<strong>所以，应用集合一致性哈希码在绝大多数场景是合理的</strong>。<strong>笔者的YY</strong>，解决这个极小场景有如下方式：</p><ul><li>第一种，修改计算公式 <code>appsHashCode = MD5(${app_name}_${instance_id}_${status}_${count}_)</code> ，增加对应用名和应用实例编号敏感。</li><li>第二种，每 N 分钟进行一次全量获取注册信息。</li></ul><p>ps ：笔者怀着忐忑的心写完了这个小节，如果有不合理的地方，又或者有不同观点的胖友，欢迎一起探讨。谢谢。</p><p>TODO[0027][反思]：应用集合一致性哈希算法。</p><h1 id="3-Eureka-Client-发起增量获取"><a href="#3-Eureka-Client-发起增量获取" class="headerlink" title="3. Eureka-Client 发起增量获取"></a>3. Eureka-Client 发起增量获取</h1><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「2.4 发起获取注册信息」</a> 里，调用 <code>DiscoveryClient#getAndUpdateDelta(...)</code> 方法，<strong>增量</strong>获取注册信息，并<strong>刷新</strong>本地缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndUpdateDelta</span><span class="params">(Applications applications)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="comment">// 增量获取注册信息</span></div><div class="line"> <span class="number">5</span>:     Applications delta = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());</div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</div><div class="line"> <span class="number">8</span>:         delta = httpResponse.getEntity();</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (delta == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 增量获取为空，全量获取</span></div><div class="line"><span class="number">13</span>:         logger.warn(<span class="string">"The server does not allow the delta revision to be applied because it is not safe. "</span></div><div class="line"><span class="number">14</span>:                 + <span class="string">"Hence got the full registry."</span>);</div><div class="line"><span class="number">15</span>:         getAndStoreFullRegistry();</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">17</span>:         logger.debug(<span class="string">"Got delta update with apps hashcode &#123;&#125;"</span>, delta.getAppsHashCode());</div><div class="line"><span class="number">18</span>:         String reconcileHashCode = <span class="string">""</span>;</div><div class="line"><span class="number">19</span>:         <span class="keyword">if</span> (fetchRegistryUpdateLock.tryLock()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                 <span class="comment">// 将变化的应用集合和本地缓存的应用集合进行合并</span></div><div class="line"><span class="number">22</span>:                 updateDelta(delta);</div><div class="line"><span class="number">23</span>:                 <span class="comment">// 计算本地的应用集合一致性哈希码</span></div><div class="line"><span class="number">24</span>:                 reconcileHashCode = getReconcileHashCode(applications);</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">26</span>:                 fetchRegistryUpdateLock.unlock();</div><div class="line"><span class="number">27</span>:             &#125;</div><div class="line"><span class="number">28</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">29</span>:             logger.warn(<span class="string">"Cannot acquire update lock, aborting getAndUpdateDelta"</span>);</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:         <span class="comment">// There is a diff in number of instances for some reason</span></div><div class="line"><span class="number">32</span>:         <span class="keyword">if</span> (!reconcileHashCode.equals(delta.getAppsHashCode()) <span class="comment">// 一致性哈希值不相等</span></div><div class="line"><span class="number">33</span>:                 || clientConfig.shouldLogDeltaDiff()) &#123; <span class="comment">//</span></div><div class="line"><span class="number">34</span>:             reconcileAndLogDifference(delta, reconcileHashCode);  <span class="comment">// this makes a remoteCall</span></div><div class="line"><span class="number">35</span>:         &#125;</div><div class="line"><span class="number">36</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">37</span>:         logger.warn(<span class="string">"Not updating application delta as another thread is updating it already"</span>);</div><div class="line"><span class="number">38</span>:         logger.debug(<span class="string">"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already"</span>, delta.getAppsHashCode());</div><div class="line"><span class="number">39</span>:     &#125;</div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 4 至 9 行 ：请求<strong>增量</strong>获取注册信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getDelta</span><span class="params">(String... regions)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> getApplicationsInternal(<span class="string">"apps/delta"</span>, regions);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#getApplicationsInternal(...)</code> 方法，GET 请求 Eureka-Server 的 <code>apps/detla</code> 接口，参数为 <code>regions</code> ，返回格式为 JSON ，实现增量获取注册信息。</li></ul></li><li><p>第 11 至 15 行 ：<strong>增量</strong>获取失败，调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。该方法在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「2.4.1 全量获取注册信息，并设置到本地缓存」</a> 有详细解析。</p></li><li>第 16 至 35 行 ：处理<strong>增量</strong>获取的结果。<ul><li>第 16 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 19 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 21 行 ：调用 <code>#updateDelta(...)</code> 方法，将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并。</li><li>第 31 至 35 行 ：一致性哈希值不相等，调用 <code>#reconcileAndLogDifference()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存，和 <code>#getAndStoreFullRegistry()</code> 基本类似。<ul><li>第 33 行 ：配置 <code>eureka.printDeltaFullDiff</code> ，是否打印增量和全量差异。默认值 ：<code>false</code> 。从目前代码实现上来看，暂时没有生效。<strong>注意</strong> ：开启该参数会导致每次<strong>增量</strong>获取后又发起<strong>全量</strong>获取，不要开启。</li></ul></li></ul></li></ul><h2 id="3-1-合并应用集合"><a href="#3-1-合并应用集合" class="headerlink" title="3.1 合并应用集合"></a>3.1 合并应用集合</h2><p>调用 <code>#updateDelta(...)</code> 方法，将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDelta</span><span class="params">(Applications delta)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">int</span> deltaCount = <span class="number">0</span>;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">for</span> (Application app : delta.getRegisteredApplications()) &#123; <span class="comment">// 循环增量（变化）应用集合</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"> <span class="number">5</span>:             Applications applications = getApplications();</div><div class="line"> <span class="number">6</span>:             <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">7</span>:             String instanceRegion = instanceRegionChecker.getInstanceRegion(instance);</div><div class="line"> <span class="number">8</span>:             <span class="keyword">if</span> (!instanceRegionChecker.isLocalRegion(instanceRegion)) &#123;</div><div class="line"> <span class="number">9</span>:                 Applications remoteApps = remoteRegionVsApps.get(instanceRegion);</div><div class="line"><span class="number">10</span>:                 <span class="keyword">if</span> (<span class="keyword">null</span> == remoteApps) &#123;</div><div class="line"><span class="number">11</span>:                     remoteApps = <span class="keyword">new</span> Applications();</div><div class="line"><span class="number">12</span>:                     remoteRegionVsApps.put(instanceRegion, remoteApps);</div><div class="line"><span class="number">13</span>:                 &#125;</div><div class="line"><span class="number">14</span>:                 applications = remoteApps;</div><div class="line"><span class="number">15</span>:             &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:             ++deltaCount;</div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (ActionType.ADDED.equals(instance.getActionType())) &#123; <span class="comment">// 添加</span></div><div class="line"><span class="number">19</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 logger.debug(<span class="string">"Added instance &#123;&#125; to the existing apps in region &#123;&#125;"</span>, instance.getId(), instanceRegion);</div><div class="line"><span class="number">24</span>:                 applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActionType.MODIFIED.equals(instance.getActionType())) &#123; <span class="comment">// 修改</span></div><div class="line"><span class="number">26</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">27</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">29</span>:                 &#125;</div><div class="line"><span class="number">30</span>:                 logger.debug(<span class="string">"Modified instance &#123;&#125; to the existing apps "</span>, instance.getId());</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:                 applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);</div><div class="line"><span class="number">33</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActionType.DELETED.equals(instance.getActionType())) &#123; <span class="comment">// 删除</span></div><div class="line"><span class="number">34</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">36</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">37</span>:                 &#125;</div><div class="line"><span class="number">38</span>:                 logger.debug(<span class="string">"Deleted instance &#123;&#125; to the existing apps "</span>, instance.getId());</div><div class="line"><span class="number">39</span>:                 applications.getRegisteredApplications(instance.getAppName()).removeInstance(instance);</div><div class="line"><span class="number">40</span>:             &#125;</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:     &#125;</div><div class="line"><span class="number">43</span>:     logger.debug(<span class="string">"The total number of instances fetched by the delta processor : &#123;&#125;"</span>, deltaCount);</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     getApplications().setVersion(delta.getVersion());</div><div class="line"><span class="number">46</span>:     <span class="comment">// 过滤、打乱应用集合</span></div><div class="line"><span class="number">47</span>:     getApplications().shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">50</span>:     <span class="keyword">for</span> (Applications applications : remoteRegionVsApps.values()) &#123;</div><div class="line"><span class="number">51</span>:         applications.setVersion(delta.getVersion());</div><div class="line"><span class="number">52</span>:         applications.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());</div><div class="line"><span class="number">53</span>:     &#125;</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 至 15 行 ：TODO[0009]：RemoteRegionRegistry</li><li><p>第 18 至 24 行 ：添加( ADDED )应用实例时，调用 <code>Application#addInstance(...)</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Application.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(InstanceInfo i)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 应用实例映射</span></div><div class="line">   instancesMap.put(i.getId(), i);</div><div class="line">   <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">       <span class="comment">// 移除原有实例</span></div><div class="line">       instances.remove(i);</div><div class="line">       <span class="comment">// 添加新实例</span></div><div class="line">       instances.add(i);</div><div class="line">       <span class="comment">// 设置 isDirty ，目前只用于 `#toString()` 方法打印，无业务逻辑</span></div><div class="line">       isDirty = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="comment">// 只使用 ID 计算 hashcode</span></div><div class="line">   String id = getId();</div><div class="line">   <span class="keyword">return</span> (id == <span class="keyword">null</span>) ? <span class="number">31</span> : (id.hashCode() + <span class="number">31</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; <span class="comment">// 只对比 ID</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   InstanceInfo other = (InstanceInfo) obj;</div><div class="line">   String id = getId();</div><div class="line">   <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">if</span> (other.getId() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!id.equals(other.getId())) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 25 至 32 行 ：修改( MODIFIED )应用实例时，<strong>同样</strong>调用 <code>Application#addInstance(...)</code> 方法。</p></li><li><p>第 33 至 40 行 ：删除( DELETED )应用实例时，调用 <code>Application#removeInstance(...)</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeInstance</span><span class="params">(InstanceInfo i)</span> </span>&#123;</div><div class="line">    removeInstance(i, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeInstance</span><span class="params">(InstanceInfo i, <span class="keyword">boolean</span> markAsDirty)</span> </span>&#123;</div><div class="line">    <span class="comment">// 移除 应用实例映射</span></div><div class="line">    instancesMap.remove(i.getId());</div><div class="line">    <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">        <span class="comment">// 移除 应用实例</span></div><div class="line">        instances.remove(i);</div><div class="line">        <span class="keyword">if</span> (markAsDirty) &#123;</div><div class="line">            <span class="comment">// 设置 isDirty ，目前只用于 `#toString()` 方法打印，无业务逻辑</span></div><div class="line">            isDirty = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 47 行 ：调用 <code>Applications#shuffleInstances(...)</code> 方法，根据配置 <code>eureka.shouldFilterOnlyUpInstances = true</code> ( 默认值 ：<code>true</code> ) 过滤只保留状态为开启( UP )的应用实例，并<strong>随机打乱</strong>应用实例顺序。打乱后，实现调用应用服务的随机性。代码比较易懂，点击<a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java#L286" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看方法实现。</p></li><li>第 49 至 53 行 ：TODO[0009]：RemoteRegionRegistry</li></ul><h1 id="4-Eureka-Server-接收全量获取"><a href="#4-Eureka-Server-接收全量获取" class="headerlink" title="4. Eureka-Server 接收全量获取"></a>4. Eureka-Server 接收全量获取</h1><h2 id="3-1-接收全量获取请求"><a href="#3-1-接收全量获取请求" class="headerlink" title="3.1 接收全量获取请求"></a>3.1 接收全量获取请求</h2><p><code>com.netflix.eureka.resources.ApplicationsResource</code>，处理<strong>所有</strong>应用的请求操作的 Resource ( Controller )。</p><p>接收增量获取请求，映射 <code>ApplicationsResource#getContainers()</code> 方法。</p><ul><li>和 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.1 接收全量获取请求」</a> 类似，就不重复啰嗦啦。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/225a81d9818d355503ad802363448eb29c374b6f/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java#L190" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的<strong>带中文注释</strong>代码。</li></ul><h2 id="3-2-最近租约变更记录队列"><a href="#3-2-最近租约变更记录队列" class="headerlink" title="3.2 最近租约变更记录队列"></a>3.2 最近租约变更记录队列</h2><p><code>AbstractInstanceRegistry.recentlyChangedQueue</code>，最近租约变更记录队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentlyChangedItem</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 最后更新时间戳</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 租约</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> Lease&lt;InstanceInfo&gt; leaseInfo;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RecentlyChangedItem</span><span class="params">(Lease&lt;InstanceInfo&gt; lease)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.leaseInfo = lease;</div><div class="line">       lastUpdateTime = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastUpdateTime;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Lease&lt;InstanceInfo&gt; <span class="title">getLeaseInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.leaseInfo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当应用实例注册、下线、状态变更时，创建最近租约变更记录( RecentlyChangedItem ) 到队列。</li><li><p>后台任务定时<strong>顺序</strong>扫描队列，当 <code>lastUpdateTime</code> 超过一定时长后进行移除。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="keyword">this</span>.deltaRetentionTimer.schedule(getDeltaRetentionTask(),</div><div class="line">                serverConfig.getDeltaRetentionTimerIntervalInMs(),</div><div class="line">                serverConfig.getDeltaRetentionTimerIntervalInMs());</div><div class="line">                </div><div class="line"><span class="function"><span class="keyword">private</span> TimerTask <span class="title">getDeltaRetentionTask</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           Iterator&lt;RecentlyChangedItem&gt; it = recentlyChangedQueue.iterator();</div><div class="line">           <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">               <span class="keyword">if</span> (it.next().getLastUpdateTime() &lt; System.currentTimeMillis() - serverConfig.getRetentionTimeInMSInDeltaQueue()) &#123;</div><div class="line">                   it.remove();</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.deltaRetentionTimerIntervalInMs</code>， 移除队列里过期的租约变更记录的定时任务执行频率，单位：毫秒。默认值 ：30 * 1000 毫秒。</li><li>配置 <code>eureka.retentionTimeInMSInDeltaQueue</code>，租约变更记录过期时长，单位：毫秒。默认值 ： 3 <em> 60 </em> 1000 毫秒。</li></ul></li></ul><h2 id="3-3-缓存读取"><a href="#3-3-缓存读取" class="headerlink" title="3.3 缓存读取"></a>3.3 缓存读取</h2><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.3 缓存读取」</a> 里，在 <code>#generatePayload()</code> 方法里，调用 <code>AbstractInstanceRegistry#getApplicationDeltas(...)</code> 方法，获取近期变化的应用集合，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltas</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 添加 增量获取次数 到 监控</span></div><div class="line">  <span class="number">3</span>:     GET_ALL_CACHE_MISS_DELTA.increment();</div><div class="line">  <span class="number">4</span>:     <span class="comment">// 初始化 变化的应用集合</span></div><div class="line">  <span class="number">5</span>:     Applications apps = <span class="keyword">new</span> Applications();</div><div class="line">  <span class="number">6</span>:     apps.setVersion(responseCache.getVersionDelta().get());</div><div class="line">  <span class="number">7</span>:     Map&lt;String, Application&gt; applicationInstancesMap = <span class="keyword">new</span> HashMap&lt;String, Application&gt;();</div><div class="line">  <span class="number">8</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">9</span>:         <span class="comment">// 获取写锁 TODO why？</span></div><div class="line"> <span class="number">10</span>:         write.lock();</div><div class="line"> <span class="number">11</span>:         <span class="comment">// 获取 最近租约变更记录队列</span></div><div class="line"> <span class="number">12</span>:         Iterator&lt;RecentlyChangedItem&gt; iter = <span class="keyword">this</span>.recentlyChangedQueue.iterator();</div><div class="line"> <span class="number">13</span>:         logger.debug(<span class="string">"The number of elements in the delta queue is :"</span> + <span class="keyword">this</span>.recentlyChangedQueue.size());</div><div class="line"> <span class="number">14</span>:         <span class="comment">// 拼装 变化的应用集合</span></div><div class="line"> <span class="number">15</span>:         <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line"> <span class="number">16</span>:             Lease&lt;InstanceInfo&gt; lease = iter.next().getLeaseInfo();</div><div class="line"> <span class="number">17</span>:             InstanceInfo instanceInfo = lease.getHolder();</div><div class="line"> <span class="number">18</span>:             Object[] args = &#123;instanceInfo.getId(), instanceInfo.getStatus().name(), instanceInfo.getActionType().name()&#125;;</div><div class="line"> <span class="number">19</span>:             logger.debug(<span class="string">"The instance id %s is found with status %s and actiontype %s"</span>, args);</div><div class="line"> <span class="number">20</span>:             Application app = applicationInstancesMap.get(instanceInfo.getAppName());</div><div class="line"> <span class="number">21</span>:             <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">22</span>:                 app = <span class="keyword">new</span> Application(instanceInfo.getAppName());</div><div class="line"> <span class="number">23</span>:                 applicationInstancesMap.put(instanceInfo.getAppName(), app);</div><div class="line"> <span class="number">24</span>:                 apps.addApplication(app);</div><div class="line"> <span class="number">25</span>:             &#125;</div><div class="line"> <span class="number">26</span>:             app.addInstance(decorateInstanceInfo(lease));</div><div class="line"> <span class="number">27</span>:         &#125;</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:         <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">30</span>:         <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</div><div class="line"> <span class="number">31</span>:         <span class="keyword">if</span> (!disableTransparentFallback) &#123;</div><div class="line"> <span class="number">32</span>:             Applications allAppsInLocalRegion = getApplications(<span class="keyword">false</span>);</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:             <span class="keyword">for</span> (RemoteRegionRegistry remoteRegistry : <span class="keyword">this</span>.regionNameVSRemoteRegistry.values()) &#123;</div><div class="line"> <span class="number">35</span>:                 Applications applications = remoteRegistry.getApplicationDeltas();</div><div class="line"> <span class="number">36</span>:                 <span class="keyword">for</span> (Application application : applications.getRegisteredApplications()) &#123;</div><div class="line"> <span class="number">37</span>:                     Application appInLocalRegistry =</div><div class="line"> <span class="number">38</span>:                             allAppsInLocalRegion.getRegisteredApplications(application.getName());</div><div class="line"> <span class="number">39</span>:                     <span class="keyword">if</span> (appInLocalRegistry == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">40</span>:                         apps.addApplication(application);</div><div class="line"> <span class="number">41</span>:                     &#125;</div><div class="line"> <span class="number">42</span>:                 &#125;</div><div class="line"> <span class="number">43</span>:             &#125;</div><div class="line"> <span class="number">44</span>:         &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:         <span class="comment">// 获取全量应用集合，通过它计算一致性哈希值</span></div><div class="line"> <span class="number">47</span>:         Applications allApps = getApplications(!disableTransparentFallback);</div><div class="line"> <span class="number">48</span>:         apps.setAppsHashCode(allApps.getReconcileHashCode());</div><div class="line"> <span class="number">49</span>:         <span class="keyword">return</span> apps;</div><div class="line"> <span class="number">50</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">51</span>:         write.unlock();</div><div class="line"> <span class="number">52</span>:     &#125;</div><div class="line"> <span class="number">53</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 3 行 ：添加增量获取次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 4 行 ：初始化变化( 增量 )的应用集合( <code>apps</code> )。</li><li>第 9 行 ：TODO[0026] ：写锁</li><li>第 11 至 13 行 ：获取最近租约变更记录队列( <code>最近租约变更记录队列</code> )。</li><li>第 14 至 27 行 ：拼装变化的应用集合( <code>apps</code> )。</li><li>第 29 至 44 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 46 至 48 行 ：调用 <code>#getApplications(...)</code> 方法，获取<strong>全量</strong>应用集合( <code>allApps</code> )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.3.1 获得注册的应用集合」</a> 有详细解析。后通过 <code>allApps</code> 计算一致性哈希值。通过这个全量应用集合的哈希值，Eureka-Client 获取到增量应用集合并合并后，就可以比对啦。</li><li>第 51 行 ：释放写锁。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>在汉堡王写完这篇热情的博客。为什么用“热情”这个字眼呢？大夏天的，竟然不开空调的！对的，没有开空调，简直是个小火炉。恩，不过静心写完这篇文章，让我还是挺嗨皮的。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-fetch-delta
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（六）之全量获取</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-fetch-all/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2017-10-17T14:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">http://www.iocoder.cn/Eureka/instance-registry-fetch-all/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2. Eureka-Client 发起全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.1 初始化全量获取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.2 定时获取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.3 刷新注册信息缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.4 发起获取注册信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3. Eureka-Server 接收全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.1 接收全量获取请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.2 响应缓存 ResponseCache</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.3 缓存读取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.4 主动过期读写缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.5 被动过期读写缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.6 定时刷新只读缓存</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 获取全量注册信息的过程</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/01.png" alt=""></p></blockquote><p>Eureka-Client 获取注册信息，分成<strong>全量获取</strong>和<strong>增量获取</strong>。默认配置下，Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，而后每 <strong>30</strong> 秒<strong>增量</strong>获取刷新<strong>本地缓存</strong>( 非“<strong>正常</strong>”情况下会是全量获取 )。</p><p>本文重点在于<strong>全量获取</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-Eureka-Client-发起全量获取"><a href="#2-Eureka-Client-发起全量获取" class="headerlink" title="2. Eureka-Client 发起全量获取"></a>2. Eureka-Client 发起全量获取</h1><p>本小节调用关系如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/03.png" alt=""></p><h2 id="2-1-初始化全量获取"><a href="#2-1-初始化全量获取" class="headerlink" title="2.1 初始化全量获取"></a>2.1 初始化全量获取</h2><p>Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，首先代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Applications 在本地的缓存</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</div><div class="line"></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">                    </div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">     </div><div class="line">    <span class="comment">// 【3.2.5】初始化应用集合在本地的缓存</span></div><div class="line">    localRegionApps.set(<span class="keyword">new</span> Applications());</div><div class="line">     </div><div class="line">    <span class="comment">// ... 省略无关代码     </span></div><div class="line">     </div><div class="line">    <span class="comment">// 【3.2.12】从 Eureka-Server 拉取注册信息</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">        fetchRegistryFromBackup();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// ... 省略无关代码       </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.discovery.shared.Applications</code>，注册的应用集合。较为容易理解，点击 <a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 链接查看带中文注释的类，这里就不啰嗦了。Applications 与 InstanceInfo 类关系如下：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_06_29/02.png" alt=""></p></li><li><p>配置 <code>eureka.shouldFetchRegistry = true</code>，开启从 Eureka-Server 获取注册信息。默认值：<code>true</code> 。</p></li><li>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server <strong>全量</strong>获取注册信息，在 <a href="#">「2.4 发起获取注册信息」</a> 详细解析。</li></ul><h2 id="2-2-定时获取"><a href="#2-2-定时获取" class="headerlink" title="2.2 定时获取"></a>2.2 定时获取</h2><p>Eureka-Client 在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">初始化</a>过程中，创建<strong>获取注册信息</strong>线程，<strong>固定间隔</strong>向 Eureka-Server 发起<strong>获取注册信息</strong>( fetch )，<strong>刷新</strong>本地注册信息<strong>缓存</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">               Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">               </div><div class="line">    <span class="comment">// 【3.2.9】初始化线程池</span></div><div class="line">    <span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></div><div class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">         <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                 .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">                 .setDaemon(<span class="keyword">true</span>)</div><div class="line">                 .build());</div><div class="line">    </div><div class="line">    cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">         <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">         <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">         <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                 .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</div><div class="line">                 .setDaemon(<span class="keyword">true</span>)</div><div class="line">                 .build()</div><div class="line">     );  <span class="comment">// use direct handoff</span></div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// 【3.2.14】初始化定时任务</span></div><div class="line">    initScheduledTasks();</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line">       <span class="comment">// registry cache refresh timer</span></div><div class="line">       <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"cacheRefresh"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       cacheRefreshExecutor,</div><div class="line">                       registryFetchIntervalSeconds,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> CacheRefreshThread()</div><div class="line">               ),</div><div class="line">               registryFetchIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>初始化定时任务代码，和<strong>续租</strong>的定时任务代码类似，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租<br>》</a> 有详细解析，这里不重复分享。</li><li><p><code>com.netflix.discovery.DiscoveryClient.CacheRefreshThread</code>，注册信息缓存刷新任务，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheRefreshThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        refreshRegistry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#refreshRegistry(false)</code> 方法，刷新注册信息缓存，在 <a href="#">「2.3 刷新注册信息缓存」</a> 详细解析。</li></ul></li></ul><h2 id="2-3-刷新注册信息缓存"><a href="#2-3-刷新注册信息缓存" class="headerlink" title="2.3 刷新注册信息缓存"></a>2.3 刷新注册信息缓存</h2><p>调用 <code>#refreshRegistry(false)</code> 方法，刷新注册信息缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">refreshRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// TODO 芋艿：TODO[0009]：RemoteRegionRegistry</span></div><div class="line">  <span class="number">4</span>:         <span class="keyword">boolean</span> isFetchingRemoteRegionRegistries = isFetchingRemoteRegionRegistries();</div><div class="line">  <span class="number">5</span>: </div><div class="line">  <span class="number">6</span>:         <span class="keyword">boolean</span> remoteRegionsModified = <span class="keyword">false</span>;</div><div class="line">  <span class="number">7</span>:         <span class="comment">// This makes sure that a dynamic change to remote regions to fetch is honored.</span></div><div class="line">  <span class="number">8</span>:         String latestRemoteRegions = clientConfig.fetchRegistryForRemoteRegions();</div><div class="line">  <span class="number">9</span>:         <span class="keyword">if</span> (<span class="keyword">null</span> != latestRemoteRegions) &#123;</div><div class="line"> <span class="number">10</span>:             String currentRemoteRegions = remoteRegionsToFetch.get();</div><div class="line"> <span class="number">11</span>:             <span class="keyword">if</span> (!latestRemoteRegions.equals(currentRemoteRegions)) &#123;</div><div class="line"> <span class="number">12</span>:                 <span class="comment">// Both remoteRegionsToFetch and AzToRegionMapper.regionsToFetch need to be in sync</span></div><div class="line"> <span class="number">13</span>:                 <span class="keyword">synchronized</span> (instanceRegionChecker.getAzToRegionMapper()) &#123;</div><div class="line"> <span class="number">14</span>:                     <span class="keyword">if</span> (remoteRegionsToFetch.compareAndSet(currentRemoteRegions, latestRemoteRegions)) &#123;</div><div class="line"> <span class="number">15</span>:                         String[] remoteRegions = latestRemoteRegions.split(<span class="string">","</span>);</div><div class="line"> <span class="number">16</span>:                         remoteRegionsRef.set(remoteRegions);</div><div class="line"> <span class="number">17</span>:                         instanceRegionChecker.getAzToRegionMapper().setRegionsToFetch(remoteRegions);</div><div class="line"> <span class="number">18</span>:                         remoteRegionsModified = <span class="keyword">true</span>;</div><div class="line"> <span class="number">19</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">20</span>:                         logger.info(<span class="string">"Remote regions to fetch modified concurrently,"</span> +</div><div class="line"> <span class="number">21</span>:                                 <span class="string">" ignoring change from &#123;&#125; to &#123;&#125;"</span>, currentRemoteRegions, latestRemoteRegions);</div><div class="line"> <span class="number">22</span>:                     &#125;</div><div class="line"> <span class="number">23</span>:                 &#125;</div><div class="line"> <span class="number">24</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">25</span>:                 <span class="comment">// Just refresh mapping to reflect any DNS/Property change</span></div><div class="line"> <span class="number">26</span>:                 instanceRegionChecker.getAzToRegionMapper().refreshMapping();</div><div class="line"> <span class="number">27</span>:             &#125;</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:         <span class="keyword">boolean</span> success = fetchRegistry(remoteRegionsModified);</div><div class="line"> <span class="number">31</span>:         <span class="keyword">if</span> (success) &#123;</div><div class="line"> <span class="number">32</span>:             <span class="comment">// 设置 注册信息的应用实例数</span></div><div class="line"> <span class="number">33</span>:             registrySize = localRegionApps.get().size();</div><div class="line"> <span class="number">34</span>:             <span class="comment">// 设置 最后获取注册信息时间</span></div><div class="line"> <span class="number">35</span>:             lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();</div><div class="line"> <span class="number">36</span>:         &#125;</div><div class="line"> <span class="number">37</span>: </div><div class="line"> <span class="number">38</span>:         <span class="comment">// 打印日志</span></div><div class="line"> <span class="number">39</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"> <span class="number">40</span>:             StringBuilder allAppsHashCodes = <span class="keyword">new</span> StringBuilder();</div><div class="line"> <span class="number">41</span>:             allAppsHashCodes.append(<span class="string">"Local region apps hashcode: "</span>);</div><div class="line"> <span class="number">42</span>:             allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());</div><div class="line"> <span class="number">43</span>:             allAppsHashCodes.append(<span class="string">", is fetching remote regions? "</span>);</div><div class="line"> <span class="number">44</span>:             allAppsHashCodes.append(isFetchingRemoteRegionRegistries);</div><div class="line"> <span class="number">45</span>:             <span class="keyword">for</span> (Map.Entry&lt;String, Applications&gt; entry : remoteRegionVsApps.entrySet()) &#123;</div><div class="line"> <span class="number">46</span>:                 allAppsHashCodes.append(<span class="string">", Remote region: "</span>);</div><div class="line"> <span class="number">47</span>:                 allAppsHashCodes.append(entry.getKey());</div><div class="line"> <span class="number">48</span>:                 allAppsHashCodes.append(<span class="string">" , apps hashcode: "</span>);</div><div class="line"> <span class="number">49</span>:                 allAppsHashCodes.append(entry.getValue().getAppsHashCode());</div><div class="line"> <span class="number">50</span>:             &#125;</div><div class="line"> <span class="number">51</span>:             logger.debug(<span class="string">"Completed cache refresh task for discovery. All Apps hash code is &#123;&#125; "</span>,</div><div class="line"> <span class="number">52</span>:                     allAppsHashCodes.toString());</div><div class="line"> <span class="number">53</span>:         &#125;</div><div class="line"> <span class="number">54</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">55</span>:         logger.error(<span class="string">"Cannot fetch registry from server"</span>, e);</div><div class="line"> <span class="number">56</span>:     &#125;        </div><div class="line"> <span class="number">57</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 至 28 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 30 行 ：调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server 获取注册信息，在 <a href="#">「2.4 发起获取注册信息」</a> 详细解析。</li><li><p>第 31 至 36 行 ：获取注册信息成功，设置注册信息的应用实例数，最后获取注册信息时间。变量代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册信息的应用实例数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> registrySize = <span class="number">0</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功从 Eureka-Server 拉取注册信息时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulRegistryFetchTimestamp = -<span class="number">1</span>;</div></pre></td></tr></table></figure></li><li><p>第 38 至 53 行 ：打印调试日志。</p></li><li>第 54 至 56 行 ：打印<strong>异常</strong>日志。</li></ul><h2 id="2-4-发起获取注册信息"><a href="#2-4-发起获取注册信息" class="headerlink" title="2.4 发起获取注册信息"></a>2.4 发起获取注册信息</h2><p>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server 获取注册信息( 根据条件判断，可能是<strong>全量</strong>，也可能是<strong>增量</strong> )，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 获取 本地缓存的注册的应用实例集合</span></div><div class="line"> <span class="number">6</span>:         <span class="comment">// If the delta is disabled or if it is the first time, get all</span></div><div class="line"> <span class="number">7</span>:         <span class="comment">// applications</span></div><div class="line"> <span class="number">8</span>:         Applications applications = getApplications();</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// 全量获取</span></div><div class="line"><span class="number">11</span>:         <span class="keyword">if</span> (clientConfig.shouldDisableDelta() <span class="comment">// 禁用增量获取</span></div><div class="line"><span class="number">12</span>:                 || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</div><div class="line"><span class="number">13</span>:                 || forceFullRegistryFetch</div><div class="line"><span class="number">14</span>:                 || (applications == <span class="keyword">null</span>) <span class="comment">// 空</span></div><div class="line"><span class="number">15</span>:                 || (applications.getRegisteredApplications().size() == <span class="number">0</span>) <span class="comment">// 空</span></div><div class="line"><span class="number">16</span>:                 || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></div><div class="line"><span class="number">17</span>:         &#123;</div><div class="line"><span class="number">18</span>:             logger.info(<span class="string">"Disable delta property : &#123;&#125;"</span>, clientConfig.shouldDisableDelta());</div><div class="line"><span class="number">19</span>:             logger.info(<span class="string">"Single vip registry refresh property : &#123;&#125;"</span>, clientConfig.getRegistryRefreshSingleVipAddress());</div><div class="line"><span class="number">20</span>:             logger.info(<span class="string">"Force full registry fetch : &#123;&#125;"</span>, forceFullRegistryFetch);</div><div class="line"><span class="number">21</span>:             logger.info(<span class="string">"Application is null : &#123;&#125;"</span>, (applications == <span class="keyword">null</span>));</div><div class="line"><span class="number">22</span>:             logger.info(<span class="string">"Registered Applications size is zero : &#123;&#125;"</span>,</div><div class="line"><span class="number">23</span>:                     (applications.getRegisteredApplications().size() == <span class="number">0</span>));</div><div class="line"><span class="number">24</span>:             logger.info(<span class="string">"Application version is -1: &#123;&#125;"</span>, (applications.getVersion() == -<span class="number">1</span>));</div><div class="line"><span class="number">25</span>:             <span class="comment">// 执行 全量获取</span></div><div class="line"><span class="number">26</span>:             getAndStoreFullRegistry();</div><div class="line"><span class="number">27</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">28</span>:             <span class="comment">// 执行 增量获取</span></div><div class="line"><span class="number">29</span>:             getAndUpdateDelta(applications);</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:         <span class="comment">// 设置 应用集合 hashcode</span></div><div class="line"><span class="number">32</span>:         applications.setAppsHashCode(applications.getReconcileHashCode());</div><div class="line"><span class="number">33</span>:         <span class="comment">// 打印 本地缓存的注册的应用实例数量</span></div><div class="line"><span class="number">34</span>:         logTotalInstances();</div><div class="line"><span class="number">35</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">36</span>:         logger.error(PREFIX + appPathIdentifier + <span class="string">" - was unable to refresh its cache! status = "</span> + e.getMessage(), e);</div><div class="line"><span class="number">37</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">38</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">39</span>:         <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">40</span>:             tracer.stop();</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:     &#125;</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>:     <span class="comment">// Notify about cache refresh before updating the instance remote status</span></div><div class="line"><span class="number">45</span>:     onCacheRefreshed();</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>:     <span class="comment">// Update remote status based on refreshed data held in the cache</span></div><div class="line"><span class="number">48</span>:     updateInstanceRemoteStatus();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:     <span class="comment">// registry was fetched successfully, so return true</span></div><div class="line"><span class="number">51</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">52</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 5 至 8 行 ：获取本地缓存的注册的应用实例集合，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> localRegionApps.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 10 至 26 行 ：<strong>全量</strong>获取注册信息。</p><ul><li>第 11 行 ：配置 <code>eureka.disableDelta = true</code> ，禁用<strong>增量</strong>获取注册信息。默认值：<code>false</code> 。</li><li>第 12 行 ：TODO[0010]：getRegistryRefreshSingleVipAddress</li><li>第 13 行 ：方法参数 <code>forceFullRegistryFetch</code> 强制<strong>全量</strong>获取注册信息。</li><li>第 14 至 15 行 ：本地缓存为空。</li><li>第 25 至 26 行 ：调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。下文详细解析。</li></ul></li><li>第 27 至 30 行 ：<strong>增量</strong>获取注册信息，并刷新本地缓存，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li><li>第 31 至 32 行 ：计算应用集合 <code>hashcode</code> 。该变量用于校验<strong>增量</strong>获取的注册信息和 Eureka-Server <strong>全量</strong>的注册信息是否一致( 完整 )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li><li><p>第 33 至 34 行 ：打印调试日志，输出本地缓存的注册的应用实例数量。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logTotalInstances</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">       <span class="keyword">int</span> totInstances = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Application application : getApplications().getRegisteredApplications()) &#123;</div><div class="line">           totInstances += application.getInstancesAsIsFromEureka().size();</div><div class="line">       &#125;</div><div class="line">       logger.debug(<span class="string">"The total number of all instances in the client now is &#123;&#125;"</span>, totInstances);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 44 至 45 行 ：触发 CacheRefreshedEvent 事件，事件监听器执行。目前 Eureka 未提供默认的该事件监听器。</p><ul><li><p><code>#onCacheRefreshed()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Eureka 事件监听器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;EurekaEventListener&gt; eventListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCacheRefreshed</span><span class="params">()</span> </span>&#123;</div><div class="line">    fireEvent(<span class="keyword">new</span> CacheRefreshedEvent());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">(<span class="keyword">final</span> EurekaEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (EurekaEventListener listener : eventListeners) &#123;</div><div class="line">        listener.onEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p><strong>笔者的YY</strong> ：你可以实现自定义的事件监听器监听 CacheRefreshedEvent 事件，以达到<strong>持久化</strong>最新的注册信息到存储器( 例如，本地文件 )，通过这样的方式，配合实现 BackupRegistry 接口读取存储器。BackupRegistry 接口调用如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 【3.2.12】从 Eureka-Server 拉取注册信息</span></div><div class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">    fetchRegistryFromBackup();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>第47 至 48 行 ：更新<strong>本地缓存</strong>的当前应用实例在 Eureka-Server 的状态。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> InstanceInfo.InstanceStatus lastRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN; </div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateInstanceRemoteStatus</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="comment">// Determine this instance's status for this app and set to UNKNOWN if not found</span></div><div class="line"> <span class="number">5</span>:     InstanceInfo.InstanceStatus currentRemoteInstanceStatus = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (instanceInfo.getAppName() != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>:         Application app = getApplication(instanceInfo.getAppName());</div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">9</span>:             InstanceInfo remoteInstanceInfo = app.getByInstanceId(instanceInfo.getId());</div><div class="line"><span class="number">10</span>:             <span class="keyword">if</span> (remoteInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">11</span>:                 currentRemoteInstanceStatus = remoteInstanceInfo.getStatus();</div><div class="line"><span class="number">12</span>:             &#125;</div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (currentRemoteInstanceStatus == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">16</span>:         currentRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// Notify if status changed</span></div><div class="line"><span class="number">20</span>:     <span class="keyword">if</span> (lastRemoteInstanceStatus != currentRemoteInstanceStatus) &#123;</div><div class="line"><span class="number">21</span>:         onRemoteStatusChanged(lastRemoteInstanceStatus, currentRemoteInstanceStatus);</div><div class="line"><span class="number">22</span>:         lastRemoteInstanceStatus = currentRemoteInstanceStatus;</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 至 14 行 ：从注册信息中获取当前应用在 Eureka-Server 的状态。</li><li><p>第 19 至 23 行 ：对比<strong>本地缓存</strong>和<strong>最新的</strong>的当前应用实例在 Eureka-Server 的状态，若不同，更新<strong>本地缓存</strong>( <strong>注意，只更新该缓存变量，不更新本地当前应用实例的状态( <code>instanceInfo.status</code> )</strong> )，触发 StatusChangeEvent 事件，事件监听器执行。目前 Eureka 未提供默认的该事件监听器。<code>#onRemoteStatusChanged(...)</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoteStatusChanged</span><span class="params">(InstanceInfo.InstanceStatus oldStatus, InstanceInfo.InstanceStatus newStatus)</span> </span>&#123;</div><div class="line">   fireEvent(<span class="keyword">new</span> StatusChangeEvent(oldStatus, newStatus));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Eureka-Client 本地应用实例与 Eureka-Server 的该应用实例状态不同的原因，因为应用实例的覆盖状态，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现 （八）之覆盖状态》</a> 有详细解析。</li></ul></li></ul></li></ul><h3 id="2-4-1-全量获取注册信息，并设置到本地缓存"><a href="#2-4-1-全量获取注册信息，并设置到本地缓存" class="headerlink" title="2.4.1 全量获取注册信息，并设置到本地缓存"></a>2.4.1 全量获取注册信息，并设置到本地缓存</h3><p>调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。下实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     logger.info(<span class="string">"Getting all instance registry info from the eureka server"</span>);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// 全量获取注册信息</span></div><div class="line"> <span class="number">7</span>:     Applications apps = <span class="keyword">null</span>;</div><div class="line"> <span class="number">8</span>:     EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></div><div class="line"> <span class="number">9</span>:             ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</div><div class="line"><span class="number">10</span>:             : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</div><div class="line"><span class="number">12</span>:         apps = httpResponse.getEntity();</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>:     logger.info(<span class="string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:     <span class="comment">// 设置到本地缓存</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">if</span> (apps == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"The application is null for some reason. Not storing this information"</span>);</div><div class="line"><span class="number">19</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">20</span>:         localRegionApps.set(<span class="keyword">this</span>.filterAndShuffle(apps));</div><div class="line"><span class="number">21</span>:         logger.debug(<span class="string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:         logger.warn(<span class="string">"Not updating applications as another thread is updating it already"</span>);</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 6 至 14 行 ：<strong>全量</strong>获取注册信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getApplications</span><span class="params">(String... regions)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> getApplicationsInternal(<span class="string">"apps/"</span>, regions);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getApplicationsInternal</span><span class="params">(String urlPath, String[] regions)</span> </span>&#123;</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   String regionsParamValue = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       WebResource webResource = jerseyClient.resource(serviceUrl).path(urlPath);</div><div class="line">       <span class="keyword">if</span> (regions != <span class="keyword">null</span> &amp;&amp; regions.length &gt; <span class="number">0</span>) &#123;</div><div class="line">           regionsParamValue = StringUtil.join(regions);</div><div class="line">           webResource = webResource.queryParam(<span class="string">"regions"</span>, regionsParamValue);</div><div class="line">       &#125;</div><div class="line">       Builder requestBuilder = webResource.getRequestBuilder();</div><div class="line">       addExtraHeaders(requestBuilder);</div><div class="line">       response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class); <span class="comment">// JSON</span></div><div class="line"></div><div class="line">       Applications applications = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (response.getStatus() == Status.OK.getStatusCode() &amp;&amp; response.hasEntity()) &#123;</div><div class="line">           applications = response.getEntity(Applications.class);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus(), Applications.class)</div><div class="line">               .headers(headersOf(response))</div><div class="line">               .entity(applications)</div><div class="line">               .build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP GET &#123;&#125;/&#123;&#125;?&#123;&#125;; statusCode=&#123;&#125;"</span>,</div><div class="line">                   serviceUrl, urlPath,</div><div class="line">                   regionsParamValue == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"regions="</span> + regionsParamValue,</div><div class="line">                   response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus()</div><div class="line">           );</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#getApplications(...)</code> 方法，GET 请求 Eureka-Server 的 <code>apps/</code> 接口，参数为 <code>regions</code> ，返回格式为 JSON ，实现<strong>全量获取注册信息</strong>。</li></ul></li><li><p>第 16 至 24 行 ：设置到本地注册信息<strong>缓存</strong>。</p><ul><li>第 19 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 20 行 ：调用 <code>#filterAndShuffle(...)</code> 方法，根据配置 <code>eureka.shouldFilterOnlyUpInstances = true</code> ( 默认值 ：<code>true</code> ) 过滤只保留状态为开启( UP )的应用实例，并<strong>随机打乱</strong>应用实例顺序。打乱后，实现调用应用服务的随机性。代码比较易懂，点击<a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L1603" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看方法实现。</li></ul></li></ul><h1 id="3-Eureka-Server-接收全量获取"><a href="#3-Eureka-Server-接收全量获取" class="headerlink" title="3. Eureka-Server 接收全量获取"></a>3. Eureka-Server 接收全量获取</h1><h2 id="3-1-接收全量获取请求"><a href="#3-1-接收全量获取请求" class="headerlink" title="3.1 接收全量获取请求"></a>3.1 接收全量获取请求</h2><p><code>com.netflix.eureka.resources.ApplicationsResource</code>，处理<strong>所有</strong>应用的请求操作的 Resource ( Controller )。</p><p>接收全量获取请求，映射 <code>ApplicationsResource#getContainers()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@GET</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">getContainers</span><span class="params">(@PathParam(<span class="string">"version"</span>)</span> String version,</span></div><div class="line"><span class="function"> 3:                               @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT)</span> String acceptHeader,</span></div><div class="line"><span class="function"> 4:                               @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT_ENCODING)</span> String acceptEncoding,</span></div><div class="line"><span class="function"> 5:                               @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept,</span></div><div class="line"><span class="function"> 6:                               @Context UriInfo uriInfo,</span></div><div class="line"><span class="function"> 7:                               @Nullable @<span class="title">QueryParam</span><span class="params">(<span class="string">"regions"</span>)</span> String regionsStr) </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">boolean</span> isRemoteRegionRequested = <span class="keyword">null</span> != regionsStr &amp;&amp; !regionsStr.isEmpty();</div><div class="line"><span class="number">10</span>:     String[] regions = <span class="keyword">null</span>;</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (!isRemoteRegionRequested) &#123;</div><div class="line"><span class="number">12</span>:         EurekaMonitors.GET_ALL.increment();</div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:         regions = regionsStr.toLowerCase().split(<span class="string">","</span>);</div><div class="line"><span class="number">15</span>:         Arrays.sort(regions); <span class="comment">// So we don't have different caches for same regions queried in different order.</span></div><div class="line"><span class="number">16</span>:         EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 判断是否可以访问</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Check if the server allows the access to the registry. The server can</span></div><div class="line"><span class="number">21</span>:     <span class="comment">// restrict access if it is not</span></div><div class="line"><span class="number">22</span>:     <span class="comment">// ready to serve traffic depending on various reasons.</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">if</span> (!registry.shouldAllowAccess(isRemoteRegionRequested)) &#123;</div><div class="line"><span class="number">24</span>:         <span class="keyword">return</span> Response.status(Status.FORBIDDEN).build();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     <span class="comment">// API 版本</span></div><div class="line"><span class="number">28</span>:     CurrentRequestVersion.set(Version.toEnum(version));</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>:     <span class="comment">// 返回数据格式</span></div><div class="line"><span class="number">31</span>:     KeyType keyType = Key.KeyType.JSON;</div><div class="line"><span class="number">32</span>:     String returnMediaType = MediaType.APPLICATION_JSON;</div><div class="line"><span class="number">33</span>:     <span class="keyword">if</span> (acceptHeader == <span class="keyword">null</span> || !acceptHeader.contains(HEADER_JSON_VALUE)) &#123;</div><div class="line"><span class="number">34</span>:         keyType = Key.KeyType.XML;</div><div class="line"><span class="number">35</span>:         returnMediaType = MediaType.APPLICATION_XML;</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:     <span class="comment">// 响应缓存键( KEY )</span></div><div class="line"><span class="number">39</span>:     Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</div><div class="line"><span class="number">40</span>:             ResponseCacheImpl.ALL_APPS,</div><div class="line"><span class="number">41</span>:             keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</div><div class="line"><span class="number">42</span>:     );</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>:     <span class="comment">//</span></div><div class="line"><span class="number">45</span>:     Response response;</div><div class="line"><span class="number">46</span>:     <span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</div><div class="line"><span class="number">47</span>:         response = Response.ok(responseCache.getGZIP(cacheKey))</div><div class="line"><span class="number">48</span>:                 .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</div><div class="line"><span class="number">49</span>:                 .header(HEADER_CONTENT_TYPE, returnMediaType)</div><div class="line"><span class="number">50</span>:                 .build();</div><div class="line"><span class="number">51</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">52</span>:         response = Response.ok(responseCache.get(cacheKey))</div><div class="line"><span class="number">53</span>:                 .build();</div><div class="line"><span class="number">54</span>:     &#125;</div><div class="line"><span class="number">55</span>:     <span class="keyword">return</span> response;</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 8 至 17 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 19 至 25 行 ：Eureka-Server 启动完成，但是未处于就绪( Ready )状态，不接受请求全量应用注册信息的请求，例如，Eureka-Server 启动时，未能从其他 Eureka-Server 集群的节点获取到应用注册信息。</li><li><p>第 27 至 28 行 ：设置 API 版本号。<strong>默认</strong>最新 API 版本为 V2。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Version &#123;</div><div class="line">    V1, V2;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Version <span class="title">toEnum</span><span class="params">(String v)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Version version : Version.values()) &#123;</div><div class="line">            <span class="keyword">if</span> (version.name().equalsIgnoreCase(v)) &#123;</div><div class="line">                <span class="keyword">return</span> version;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//Defaults to v2</span></div><div class="line">        <span class="keyword">return</span> V2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 30 至 36 行 ：设置返回数据格式，默认 JSON 。</p></li><li>第 38 至 42 行 ：创建响应缓存( ResponseCache ) 的键( KEY )，在 <a href="#">「3.2.1 缓存键」</a>详细解析。 </li><li>第 44 至 55 行 ：从响应缓存读取<strong>全量</strong>注册信息，在 <a href="#">「3.3 缓存读取」</a>详细解析。 </li></ul><h2 id="3-2-响应缓存-ResponseCache"><a href="#3-2-响应缓存-ResponseCache" class="headerlink" title="3.2 响应缓存 ResponseCache"></a>3.2 响应缓存 ResponseCache</h2><p><code>com.netflix.eureka.registry.ResponseCache</code>，响应缓存<strong>接口</strong>，接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">get</span><span class="params">(Key key)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">byte</span>[] getGZIP(Key key);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">AtomicLong <span class="title">getVersionDelta</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">AtomicLong <span class="title">getVersionDeltaWithRegions</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>其中，<code>#getVersionDelta()</code> 和 <code>#getVersionDeltaWithRegions()</code> 已经废弃。这里保留的原因主要是考虑兼容性。判断依据来自如下代码：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVersion</span><span class="params">(Long version)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.versionDelta = version;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltas</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其它无关代码</span></div><div class="line">    apps.setVersion(responseCache.getVersionDelta().get()); <span class="comment">// 唯一调用到 ResponseCache#getVersionDelta() 方法的地方</span></div><div class="line">    <span class="comment">// ... 省略其它无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>#get()</code> ：获得缓存。</p></li><li><code>#getGZIP()</code> ：获得缓存，并 GZIP 。</li><li><code>#invalidate()</code> ：过期缓存。</li></ul><h3 id="3-2-1-缓存键"><a href="#3-2-1-缓存键" class="headerlink" title="3.2.1 缓存键"></a>3.2.1 缓存键</h3><p><code>com.netflix.eureka.registry.Key</code>，缓存键。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> KeyType &#123;</div><div class="line">        JSON, XML</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * An enum to define the entity that is stored in this cache for this key.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> EntityType &#123;</div><div class="line">        Application, VIP, SVIP</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String entityName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] regions;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求参数类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KeyType requestType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求 API 版本号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Version requestVersion;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * hashKey</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hashKey;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体类型</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EntityType&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EntityType entityType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EurekaAccept&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaAccept eurekaAccept;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regions = regions;</div><div class="line">        <span class="keyword">this</span>.entityType = entityType;</div><div class="line">        <span class="keyword">this</span>.entityName = entityName;</div><div class="line">        <span class="keyword">this</span>.requestType = type;</div><div class="line">        <span class="keyword">this</span>.requestVersion = v;</div><div class="line">        <span class="keyword">this</span>.eurekaAccept = eurekaAccept;</div><div class="line">        hashKey = <span class="keyword">this</span>.entityType + <span class="keyword">this</span>.entityName + (<span class="keyword">null</span> != <span class="keyword">this</span>.regions ? Arrays.toString(<span class="keyword">this</span>.regions) : <span class="string">""</span>)</div><div class="line">                + requestType.name() + requestVersion.name() + <span class="keyword">this</span>.eurekaAccept.name();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regions = regions;</div><div class="line">        <span class="keyword">this</span>.entityType = entityType;</div><div class="line">        <span class="keyword">this</span>.entityName = entityName;</div><div class="line">        <span class="keyword">this</span>.requestType = type;</div><div class="line">        <span class="keyword">this</span>.requestVersion = v;</div><div class="line">        <span class="keyword">this</span>.eurekaAccept = eurekaAccept;</div><div class="line">        hashKey = <span class="keyword">this</span>.entityType + <span class="keyword">this</span>.entityName + (<span class="keyword">null</span> != <span class="keyword">this</span>.regions ? Arrays.toString(<span class="keyword">this</span>.regions) : <span class="string">""</span>)</div><div class="line">                + requestType.name() + requestVersion.name() + <span class="keyword">this</span>.eurekaAccept.name();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        String hashKey = getHashKey();</div><div class="line">        <span class="keyword">return</span> hashKey.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Key) &#123;</div><div class="line">            <span class="keyword">return</span> getHashKey().equals(((Key) other).getHashKey());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-2-响应缓存实现类"><a href="#3-2-2-响应缓存实现类" class="headerlink" title="3.2.2 响应缓存实现类"></a>3.2.2 响应缓存实现类</h3><p><code>com.netflix.eureka.registry.ResponseCacheImpl</code>，响应缓存实现类。</p><p>在 ResponseCacheImpl 里，将缓存拆分成两层 ：</p><ul><li><strong>只读缓存</strong>( <code>readOnlyCacheMap</code> )</li><li><strong>固定过期</strong> + <strong>固定大小</strong>的<strong>读写缓存</strong>( <code>readWriteCacheMap</code> )</li></ul><p>默认配置下，<strong>缓存读取策略</strong>如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/04.png" alt=""></p><p><strong>缓存过期策略</strong>如下：</p><ul><li>应用实例注册、下线、过期时，<strong>只只只</strong>过期 <code>readWriteCacheMap</code> 。</li><li><code>readWriteCacheMap</code> 写入一段时间( 可配置 )后自动过期。</li><li><strong>定时</strong>任务对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。</li></ul><p><strong>注意</strong>：应用实例注册、下线、过期时，不会很快刷新到 <code>readWriteCacheMap</code> 缓存里。默认配置下，最大延迟在 30 秒。</p><p><strong>为什么可以使用缓存？</strong></p><p>在 <a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" rel="external nofollow noopener noreferrer" target="_blank">CAP</a> 的选择上，Eureka 选择了 AP ，不同于 Zookeeper 选择了 CP 。</p><p>推荐阅读：</p><ul><li><a href="http://dockone.io/article/78" rel="external nofollow noopener noreferrer" target="_blank">《为什么不应该使用ZooKeeper做服务发现》</a></li><li><a href="http://blog.spring-cloud.io/blog/sc-eureka.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix Eureka源码导读与原理分析》「4. 作为服务注册中心，Eureka比Zookeeper好在哪里」</a></li></ul><h2 id="3-3-缓存读取"><a href="#3-3-缓存读取" class="headerlink" title="3.3 缓存读取"></a>3.3 缓存读取</h2><p>调用 <code>ResponseCacheImpl#get(...)</code> 方法( <code>#getGzip(...)</code> 类似 )，读取缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Key, Value&gt; readOnlyCacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Key, Value&gt;();</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> LoadingCache&lt;Key, Value&gt; readWriteCacheMap;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">return</span> get(key, shouldUseReadOnlyResponseCache);</div><div class="line"> <span class="number">7</span>: &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>: <span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</div><div class="line"><span class="number">10</span>:     Value payload = getValue(key, useReadOnlyCache);</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (payload == <span class="keyword">null</span> || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="keyword">return</span> payload.getPayload();</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>: &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>: <span class="function">Value <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</div><div class="line"><span class="number">19</span>:     Value payload = <span class="keyword">null</span>;</div><div class="line"><span class="number">20</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:         <span class="keyword">if</span> (useReadOnlyCache) &#123;</div><div class="line"><span class="number">22</span>:             <span class="keyword">final</span> Value currentPayload = readOnlyCacheMap.get(key);</div><div class="line"><span class="number">23</span>:             <span class="keyword">if</span> (currentPayload != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">24</span>:                 payload = currentPayload;</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>:                 payload = readWriteCacheMap.get(key);</div><div class="line"><span class="number">27</span>:                 readOnlyCacheMap.put(key, payload);</div><div class="line"><span class="number">28</span>:             &#125;</div><div class="line"><span class="number">29</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">30</span>:             payload = readWriteCacheMap.get(key);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>:     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">33</span>:         logger.error(<span class="string">"Cannot get value for key :"</span> + key, t);</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>:     <span class="keyword">return</span> payload;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 7 行 ：调用 <code>#get(key, useReadOnlyCache)</code> 方法，读取缓存。其中 <code>shouldUseReadOnlyResponseCache</code> 通过配置 <code>eureka.shouldUseReadOnlyResponseCache = true</code> (默认值 ：<code>true</code> ) 开启只读缓存。如果你对数据的一致性有相对高的要求，可以关闭这个开关，当然因为少了 <code>readOnlyCacheMap</code> ，性能会有一定的下降。</li><li><p>第 9 至 16 行 ：调用 <code>getValue(key, useReadOnlyCache)</code> 方法，读取缓存。从 <code>readOnlyCacheMap</code> 和 <code>readWriteCacheMap</code> 变量可以看到缓存值的类为 <code>com.netflix.eureka.registry.ResponseCacheImpl.Value</code> ，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 原始值</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String payload;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * GZIP 压缩后的值</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] gzipped;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String payload)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.payload = payload;</div><div class="line">       <span class="keyword">if</span> (!EMPTY_PAYLOAD.equals(payload)) &#123;</div><div class="line">           <span class="comment">// ... 省略 GZIP 压缩代码</span></div><div class="line">           gzipped = bos.toByteArray();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           gzipped = <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getPayload</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> payload;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] getGzipped() &#123;</div><div class="line">       <span class="keyword">return</span> gzipped;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 21 至 31 行 ：读取缓存。</p><ul><li>第 21 至 28 行 ：先读取 <code>readOnlyCacheMap</code> 。读取不到，读取 <code>readWriteCacheMap</code> ，并设置到 <code>readOnlyCacheMap</code> 。</li><li>第 29 至 31 行 ：读取 <code>readWriteCacheMap</code> 。</li><li><p><code>readWriteCacheMap</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.readWriteCacheMap =</div><div class="line">      CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>)</div><div class="line">              .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</div><div class="line">              .removalListener(<span class="keyword">new</span> RemovalListener&lt;Key, Value&gt;() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Key, Value&gt; notification)</span> </span>&#123;</div><div class="line">                      <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line">                      Key removedKey = notification.getKey();</div><div class="line">                      <span class="keyword">if</span> (removedKey.hasRegions()) &#123;</div><div class="line">                          Key cloneWithNoRegions = removedKey.cloneWithoutRegions();</div><div class="line">                          regionSpecificKeys.remove(cloneWithNoRegions, removedKey);</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;)</div><div class="line">              .build(<span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> Value <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                      <span class="comment">// // TODO[0009]：RemoteRegionRegistry</span></div><div class="line">                      <span class="keyword">if</span> (key.hasRegions()) &#123;</div><div class="line">                          Key cloneWithNoRegions = key.cloneWithoutRegions();</div><div class="line">                          regionSpecificKeys.put(cloneWithNoRegions, key);</div><div class="line">                      &#125;</div><div class="line">                      Value value = generatePayload(key);</div><div class="line">                      <span class="keyword">return</span> value;</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure><ul><li><code>readWriteCacheMap</code> 最大缓存数量为 1000 。</li><li>调用 <code>#generatePayload(key)</code> 方法，生成缓存值。</li></ul></li></ul></li><li><p><code>#generatePayload(key)</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Value <span class="title">generatePayload</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Stopwatch tracer = <span class="keyword">null</span>;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">4</span>:         String payload;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">switch</span> (key.getEntityType()) &#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">case</span> Application:</div><div class="line"> <span class="number">7</span>:                 <span class="keyword">boolean</span> isRemoteRegionRequested = key.hasRegions();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:                 <span class="keyword">if</span> (ALL_APPS.equals(key.getName())) &#123;</div><div class="line"><span class="number">10</span>:                     <span class="keyword">if</span> (isRemoteRegionRequested) &#123; <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">11</span>:                         tracer = serializeAllAppsWithRemoteRegionTimer.start();</div><div class="line"><span class="number">12</span>:                         payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));</div><div class="line"><span class="number">13</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:                         tracer = serializeAllAppsTimer.start();</div><div class="line"><span class="number">15</span>:                         payload = getPayLoad(key, registry.getApplications());</div><div class="line"><span class="number">16</span>:                     &#125;</div><div class="line"><span class="number">17</span>:                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ALL_APPS_DELTA.equals(key.getName())) &#123;</div><div class="line"><span class="number">18</span>:                     <span class="comment">// ... 省略增量获取相关的代码</span></div><div class="line"><span class="number">19</span>:                  &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:                     tracer = serializeOneApptimer.start();</div><div class="line"><span class="number">21</span>:                     payload = getPayLoad(key, registry.getApplication(key.getName()));</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>:             <span class="comment">// ... 省略部分代码 </span></div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">return</span> <span class="keyword">new</span> Value(payload);</div><div class="line"><span class="number">27</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             tracer.stop();</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 至 12 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 13 至 16 行 ：调用 <code>AbstractInstanceRegistry#getApplications()</code> 方法，获得注册的应用集合。后调用 <code>#getPayLoad()</code> 方法，将注册的应用集合转换成缓存值。🙂 这两个方法代码较多，下面详细解析。</li><li>第 17 至 18 行 ：获取增量注册信息的缓存值，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li></ul></li></ul><h3 id="3-3-1-获得注册的应用集合"><a href="#3-3-1-获得注册的应用集合" class="headerlink" title="3.3.1 获得注册的应用集合"></a>3.3.1 获得注册的应用集合</h3><p>调用 <code>AbstractInstanceRegistry#getApplications()</code> 方法，获得注册的应用集合，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] EMPTY_STR_ARRAY = <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</div><div class="line"> <span class="number">7</span>:    <span class="keyword">if</span> (disableTransparentFallback) &#123; <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">8</span>:        <span class="keyword">return</span> getApplicationsFromLocalRegionOnly();</div><div class="line"> <span class="number">9</span>:    &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>:        <span class="keyword">return</span> getApplicationsFromAllRemoteRegions();  <span class="comment">// Behavior of falling back to remote region can be disabled.</span></div><div class="line"><span class="number">11</span>:    &#125;</div><div class="line"><span class="number">12</span>: &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromLocalRegionOnly</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">15</span>:    <span class="keyword">return</span> getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 至 8 行 ：TODO[0009]：RemoteRegionRegistry</li><li><p>第 9 至 16 行 ：调用 <code>#getApplicationsFromMultipleRegions(...)</code> 方法，获得注册的应用集合，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">boolean</span> includeRemoteRegion = <span class="keyword">null</span> != remoteRegions &amp;&amp; remoteRegions.length != <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     logger.debug(<span class="string">"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;"</span>,</div><div class="line"> <span class="number">5</span>:             includeRemoteRegion, Arrays.toString(remoteRegions));</div><div class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (includeRemoteRegion) &#123;</div><div class="line"> <span class="number">7</span>:         GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">9</span>:         GET_ALL_CACHE_MISS.increment();</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>:     <span class="comment">// 获得获得注册的应用集合</span></div><div class="line"><span class="number">12</span>:     Applications apps = <span class="keyword">new</span> Applications();</div><div class="line"><span class="number">13</span>:     apps.setVersion(<span class="number">1L</span>);</div><div class="line"><span class="number">14</span>:     <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123;</div><div class="line"><span class="number">15</span>:         Application app = <span class="keyword">null</span>;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (entry.getValue() != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123;</div><div class="line"><span class="number">19</span>:                 Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue();</div><div class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:                     app = <span class="keyword">new</span> Application(lease.getHolder().getAppName());</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 app.addInstance(decorateInstanceInfo(lease));</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">27</span>:             apps.addApplication(app);</div><div class="line"><span class="number">28</span>:         &#125;</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">31</span>:     <span class="keyword">if</span> (includeRemoteRegion) &#123;</div><div class="line"><span class="number">32</span>:         <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</div><div class="line"><span class="number">33</span>:             RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</div><div class="line"><span class="number">34</span>:             <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</div><div class="line"><span class="number">35</span>:                 Applications remoteApps = remoteRegistry.getApplications();</div><div class="line"><span class="number">36</span>:                 <span class="keyword">for</span> (Application application : remoteApps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</div><div class="line"><span class="number">38</span>:                         logger.info(<span class="string">"Application &#123;&#125;  fetched from the remote region &#123;&#125;"</span>,</div><div class="line"><span class="number">39</span>:                                 application.getName(), remoteRegion);</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>:                         Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());</div><div class="line"><span class="number">42</span>:                         <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">43</span>:                             appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</div><div class="line"><span class="number">44</span>:                             apps.addApplication(appInstanceTillNow);</div><div class="line"><span class="number">45</span>:                         &#125;</div><div class="line"><span class="number">46</span>:                         <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</div><div class="line"><span class="number">47</span>:                             appInstanceTillNow.addInstance(instanceInfo);</div><div class="line"><span class="number">48</span>:                         &#125;</div><div class="line"><span class="number">49</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">50</span>:                         logger.debug(<span class="string">"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a "</span></div><div class="line"><span class="number">51</span>:                                         + <span class="string">"whitelist and this app is not in the whitelist."</span>,</div><div class="line"><span class="number">52</span>:                                 application.getName(), remoteRegion);</div><div class="line"><span class="number">53</span>:                     &#125;</div><div class="line"><span class="number">54</span>:                 &#125;</div><div class="line"><span class="number">55</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">56</span>:                 logger.warn(<span class="string">"No remote registry available for the remote region &#123;&#125;"</span>, remoteRegion);</div><div class="line"><span class="number">57</span>:             &#125;</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:     &#125;</div><div class="line"><span class="number">60</span>:     <span class="comment">// 设置 应用集合 hashcode</span></div><div class="line"><span class="number">61</span>:     apps.setAppsHashCode(apps.getReconcileHashCode());</div><div class="line"><span class="number">62</span>:     <span class="keyword">return</span> apps;</div><div class="line"><span class="number">63</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 第 10 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 11 至 29 行 ：获得获得注册的应用集合。</li><li>第 30 至 59 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 61 行 ：计算应用集合 <code>hashcode</code> 。该变量用于校验<strong>增量</strong>获取的注册信息和 Eureka-Server <strong>全量</strong>的注册信息是否一致( 完整 )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li></ul></li></ul><h3 id="3-3-2-转换成缓存值"><a href="#3-3-2-转换成缓存值" class="headerlink" title="3.3.2 转换成缓存值"></a>3.3.2 转换成缓存值</h3><p>调用 <code>#getPayLoad()</code> 方法，将注册的应用集合转换成缓存值，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Generate pay load with both JSON and XML formats for all applications.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getPayLoad</span><span class="params">(Key key, Applications apps)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获得编码器</span></div><div class="line">   EncoderWrapper encoderWrapper = serverCodecs.getEncoder(key.getType(), key.getEurekaAccept());</div><div class="line">   String result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 编码</span></div><div class="line">       result = encoderWrapper.encode(apps);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.error(<span class="string">"Failed to encode the payload for all apps"</span>, e);</div><div class="line">       <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</div><div class="line">       logger.debug(<span class="string">"New application cache entry &#123;&#125; with apps hashcode &#123;&#125;"</span>, key.toStringCompact(), apps.getAppsHashCode());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-4-主动过期读写缓存"><a href="#3-4-主动过期读写缓存" class="headerlink" title="3.4 主动过期读写缓存"></a>3.4 主动过期读写缓存</h2><p>应用实例注册、下线、过期时，调用 <code>ResponseCacheImpl#invalidate()</code> 方法，主动过期读写缓存( <code>readWriteCacheMap</code> )，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Key.KeyType type : Key.KeyType.values()) &#123;</div><div class="line">       <span class="keyword">for</span> (Version v : Version.values()) &#123;</div><div class="line">           invalidate(</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, appName, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, appName, type, v, EurekaAccept.compact),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.compact),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.compact)</div><div class="line">           );</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != vipAddress) &#123;</div><div class="line">               invalidate(<span class="keyword">new</span> Key(Key.EntityType.VIP, vipAddress, type, v, EurekaAccept.full));</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != secureVipAddress) &#123;</div><div class="line">               invalidate(<span class="keyword">new</span> Key(Key.EntityType.SVIP, secureVipAddress, type, v, EurekaAccept.full));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#invalidate(keys)</code> 方法，逐个过期每个缓存键值，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(Key... keys)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Key key : keys) &#123;</div><div class="line">       logger.debug(<span class="string">"Invalidating the response cache key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;, &#123;&#125;"</span>, key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());</div><div class="line">       <span class="comment">// 过期读写缓存</span></div><div class="line">       readWriteCacheMap.invalidate(key);</div><div class="line">       <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line">       Collection&lt;Key&gt; keysWithRegions = regionSpecificKeys.get(key);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != keysWithRegions &amp;&amp; !keysWithRegions.isEmpty()) &#123;</div><div class="line">           <span class="keyword">for</span> (Key keysWithRegion : keysWithRegions) &#123;</div><div class="line">               logger.debug(<span class="string">"Invalidating the response cache key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</div><div class="line">                       key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());</div><div class="line">               readWriteCacheMap.invalidate(keysWithRegion);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-5-被动过期读写缓存"><a href="#3-5-被动过期读写缓存" class="headerlink" title="3.5 被动过期读写缓存"></a>3.5 被动过期读写缓存</h2><p>读写缓存( <code>readWriteCacheMap</code> ) 写入后，一段时间自动过期，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds())</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.responseCacheAutoExpirationInSeconds</code> ，设置写入过期时长。默认值 ：180 秒。</li></ul><h2 id="3-6-定时刷新只读缓存"><a href="#3-6-定时刷新只读缓存" class="headerlink" title="3.6 定时刷新只读缓存"></a>3.6 定时刷新只读缓存</h2><p><strong>定时</strong>任务对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// ... 省略无关代码 </span></div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">long</span> responseCacheUpdateIntervalMs = serverConfig.getResponseCacheUpdateIntervalMs();</div><div class="line"> <span class="number">5</span>:     <span class="comment">// ... 省略无关代码</span></div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (shouldUseReadOnlyResponseCache) &#123;</div><div class="line"> <span class="number">8</span>:         timer.schedule(getCacheUpdateTask(),</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">new</span> Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)</div><div class="line"><span class="number">10</span>:                         + responseCacheUpdateIntervalMs),</div><div class="line"><span class="number">11</span>:                 responseCacheUpdateIntervalMs);</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="comment">// ... 省略无关代码</span></div><div class="line"><span class="number">15</span>: &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="function"><span class="keyword">private</span> TimerTask <span class="title">getCacheUpdateTask</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</div><div class="line"><span class="number">19</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">20</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">21</span>:             logger.debug(<span class="string">"Updating the client cache from response cache"</span>);</div><div class="line"><span class="number">22</span>:             <span class="keyword">for</span> (Key key : readOnlyCacheMap.keySet()) &#123; <span class="comment">// 循环 readOnlyCacheMap 的缓存键</span></div><div class="line"><span class="number">23</span>:                 <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">24</span>:                     Object[] args = &#123;key.getEntityType(), key.getName(), key.getVersion(), key.getType()&#125;;</div><div class="line"><span class="number">25</span>:                     logger.debug(<span class="string">"Updating the client cache from response cache for key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>, args);</div><div class="line"><span class="number">26</span>:                 &#125;</div><div class="line"><span class="number">27</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">28</span>:                     CurrentRequestVersion.set(key.getVersion());</div><div class="line"><span class="number">29</span>:                     Value cacheValue = readWriteCacheMap.get(key);</div><div class="line"><span class="number">30</span>:                     Value currentCacheValue = readOnlyCacheMap.get(key);</div><div class="line"><span class="number">31</span>:                     <span class="keyword">if</span> (cacheValue != currentCacheValue) &#123; <span class="comment">// 不一致时，进行替换</span></div><div class="line"><span class="number">32</span>:                         readOnlyCacheMap.put(key, cacheValue);</div><div class="line"><span class="number">33</span>:                     &#125;</div><div class="line"><span class="number">34</span>:                 &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line"><span class="number">35</span>:                     logger.error(<span class="string">"Error while updating the client cache from response cache for key &#123;&#125;"</span>, key.toStringCompact(), th);</div><div class="line"><span class="number">36</span>:                 &#125;</div><div class="line"><span class="number">37</span>:             &#125;</div><div class="line"><span class="number">38</span>:         &#125;</div><div class="line"><span class="number">39</span>:     &#125;;</div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 12 行 ：初始化定时任务。配置 <code>eureka.responseCacheUpdateIntervalMs</code>，设置任务执行频率，默认值 ：30 * 1000 毫秒。</li><li>第 17 至 39 行 ：创建定时任务。<ul><li>第 22 行 ：循环 <code>readOnlyCacheMap</code> 的缓存键。<strong>为什么不循环 <code>readWriteCacheMap</code> 呢</strong>？ <code>readOnlyCacheMap</code> 的缓存过期依赖  <code>readWriteCacheMap</code>，因此缓存键会更多。</li><li>第 28 行 至 33 行 ：对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>比预期，比想想，长老多老多的一篇文章。细思极恐。</p><p>估计下一篇增量获取会简洁很多。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-fetch-all/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-fetch-all/&lt;/a
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（五）之过期</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-evict/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-evict/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">http://www.iocoder.cn/Eureka/instance-registry-evict/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">2. 为什么需要过期</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">3. EvictionTask</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">4. 过期逻辑</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 过期超时续租的租约</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_22/01.png" alt=""></p></blockquote><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-为什么需要过期"><a href="#2-为什么需要过期" class="headerlink" title="2. 为什么需要过期"></a>2. 为什么需要过期</h1><p>正常情况下，应用实例下线时候会主动向 Eureka-Server 发起下线请求。但实际情况下，应用实例可能异常崩溃，又或者是网络异常等原因，导致下线请求无法被成功提交。</p><p>介于这种情况，通过 Eureka-Client 心跳延长租约，配合 Eureka-Server 清理超时的租约解决上述异常。</p><h1 id="3-EvictionTask"><a href="#3-EvictionTask" class="headerlink" title="3. EvictionTask"></a>3. EvictionTask</h1><p><code>com.netflix.eureka.registry.AbstractInstanceRegistry.EvictionTask</code>，清理租约过期任务。在 Eureka-Server 启动时，初始化 EvictionTask 定时执行，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 清理租约过期任务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EvictionTask&gt; evictionTaskRef = <span class="keyword">new</span> AtomicReference&lt;EvictionTask&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="comment">// 初始化 清理租约过期任务</span></div><div class="line">   <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</div><div class="line">       evictionTaskRef.get().cancel();</div><div class="line">   &#125;</div><div class="line">   evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</div><div class="line">   evictionTimer.schedule(evictionTaskRef.get(),</div><div class="line">           serverConfig.getEvictionIntervalTimerInMs(),</div><div class="line">           serverConfig.getEvictionIntervalTimerInMs());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.evictionIntervalTimerInMs</code> ，清理租约过期任务执行频率，单位：毫秒。默认，60000 毫秒。</li><li><p>EvictionTask 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvictionTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 获取 补偿时间毫秒数</span></div><div class="line">           <span class="keyword">long</span> compensationTimeMs = getCompensationTimeMs();</div><div class="line">           logger.info(<span class="string">"Running the evict task with compensationTime &#123;&#125;ms"</span>, compensationTimeMs);</div><div class="line">           <span class="comment">// 清理过期租约逻辑</span></div><div class="line">           evict(compensationTimeMs);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           logger.error(<span class="string">"Could not run the evict task"</span>, e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#compensationTimeMs()</code> 方法，获得补偿时间毫秒数。计算公式 = 当前时间 - 最后任务执行时间 - 任务执行频率。为什么需要补偿时间毫秒数，在 <a href="#">「4. 过期逻辑」<code>Lease#isisExpired(additionalLeaseMs)</code> 方法</a> 揭晓。<code>#compensationTimeMs()</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后任务执行时间</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastExecutionNanosRef = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> currNanos = getCurrentTimeNano();</div><div class="line">    <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</div><div class="line">    <span class="keyword">if</span> (lastNanos == <span class="number">0L</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</div><div class="line">    <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</div><div class="line">    <span class="keyword">return</span> compensationTime &lt;= <span class="number">0L</span> ? <span class="number">0L</span> : compensationTime;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>由于 JVM GC ，又或是时间偏移( clock skew ) 等原因，定时器执行实际比预期会<strong>略有延迟</strong>。笔者在本机<strong>低负载</strong>运行，大概 10 ms 内。</p><blockquote><p>compute a compensation time defined as the actual time this task was executed since the prev iteration, vs the configured amount of time for execution. This is useful for cases where changes in time (due to clock skew or gc for example) causes the actual eviction task to execute later than the desired time according to the configured cycle.</p></blockquote></li></ul></li><li><p>调用 <code>#evict(compensationTime)</code> 方法，执行清理过期租约逻辑，在 <a href="#">「4. 过期逻辑」</a> 详细解析。</p></li></ul></li></ul><h1 id="4-过期逻辑"><a href="#4-过期逻辑" class="headerlink" title="4. 过期逻辑"></a>4. 过期逻辑</h1><p>调用 <code>#evict(compensationTime)</code> 方法，执行清理过期租约逻辑，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     logger.debug(<span class="string">"Running the evict task"</span>);</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</div><div class="line"> <span class="number">5</span>:         logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</div><div class="line"> <span class="number">6</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>:     &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="comment">// 获得 所有过期的租约</span></div><div class="line"><span class="number">10</span>:     <span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></div><div class="line"><span class="number">11</span>:     <span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// the impact should be evenly distributed across all applications.</span></div><div class="line"><span class="number">13</span>:     List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">14</span>:     <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</div><div class="line"><span class="number">15</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</div><div class="line"><span class="number">16</span>:         <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">17</span>:             <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</div><div class="line"><span class="number">18</span>:                 Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</div><div class="line"><span class="number">19</span>:                 <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">20</span>:                     expiredLeases.add(lease);</div><div class="line"><span class="number">21</span>:                 &#125;</div><div class="line"><span class="number">22</span>:             &#125;</div><div class="line"><span class="number">23</span>:         &#125;</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:     <span class="comment">// 计算 最大允许清理租约数量</span></div><div class="line"><span class="number">27</span>:     <span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></div><div class="line"><span class="number">28</span>:     <span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></div><div class="line"><span class="number">29</span>:     <span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</div><div class="line"><span class="number">30</span>:     <span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">31</span>:     <span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:     <span class="comment">// 计算 清理租约数量</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</div><div class="line"><span class="number">35</span>:     <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:         logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:         <span class="comment">// 逐个过期</span></div><div class="line"><span class="number">39</span>:         Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</div><div class="line"><span class="number">41</span>:             <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></div><div class="line"><span class="number">42</span>:             <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</div><div class="line"><span class="number">43</span>:             Collections.swap(expiredLeases, i, next);</div><div class="line"><span class="number">44</span>:             Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:             String appName = lease.getHolder().getAppName();</div><div class="line"><span class="number">47</span>:             String id = lease.getHolder().getId();</div><div class="line"><span class="number">48</span>:             EXPIRED.increment();</div><div class="line"><span class="number">49</span>:             logger.warn(<span class="string">"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">50</span>:             internalCancel(appName, id, <span class="keyword">false</span>);</div><div class="line"><span class="number">51</span>:         &#125;</div><div class="line"><span class="number">52</span>:     &#125;</div><div class="line"><span class="number">53</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 至 7 行 ：判断允许执行清理过期租约逻辑，主要和<strong>自我保护机制</strong>有关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</li><li><p>第 9 至 24 行 ：获得<strong>所有过期</strong>的租约集合。</p><ul><li><p>第 19 行 ：调用 <code>Lease#isisExpired(additionalLeaseMs)</code> 方法，判断租约是否过期，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lease.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">   lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>😈<strong>注意</strong>：在不考虑 <code>additionalLeaseMs</code> 参数的情况下，租约过期时间比预期多了<strong>一个</strong> <code>duration</code>，原因在于 <code>#renew()</code> 方法错误的设置 <code>lastUpdateTimestamp = System.currentTimeMillis() + duration</code>，正确的设置应该是 <code>lastUpdateTimestamp = System.currentTimeMillis()</code> 。</p><blockquote><p>Note that due to renew() doing the ‘wrong” thing and setting lastUpdateTimestamp to +duration more than what it should be, the expiry will actually be 2 <em> duration. <em>*This is a minor bug and should only affect instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will not be fixed</em></em>. </p></blockquote></li><li><p>TODO[0023]：additionalLeaseMs</p></li></ul></li></ul></li><li><p>第 26 至 34 行 ：计算<strong>最大允许</strong>清理租约的数量，后计算允许清理租约的数量。</p><ul><li><p>😈<strong>注意</strong>：即使 Eureka-Server 关闭<strong>自我保护机制</strong>，如果使用<code>renewalPercentThreshold = 0.85</code> 默认配置，结果会是<strong>分批逐步</strong>过期。举个例子：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 假设 20 个租约，其中有 10 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第一轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">20</span> * <span class="number">0.85</span>) = <span class="number">17</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">20</span> - <span class="number">17</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">10</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第一轮执行结束，剩余 17 个租约，其中有 7 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">17</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">17</span> * <span class="number">0.85</span>) = <span class="number">14</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">17</span> - <span class="number">14</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">7</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第二轮执行结束，剩余 14 个租约，其中有 4 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第三轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">14</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">14</span> * <span class="number">0.85</span>) = <span class="number">11</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">14</span> - <span class="number">11</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">4</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第三轮执行结束，剩余 11 个租约，其中有 1 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第四轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">11</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">11</span> * <span class="number">0.85</span>) = <span class="number">9</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">11</span> - <span class="number">9</span> = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">1</span>;</div><div class="line"><span class="comment">// 第四轮执行结束，剩余 10 个租约，其中有 0 个租约过期。结束。</span></div></pre></td></tr></table></figure><ul><li>结论：是否开启自我保护的差别，在于是否执行清理过期租约逻辑。如果想关闭<strong>分批逐步</strong>过期，设置 <code>renewalPercentThreshold = 0</code> 。</li></ul></li><li><p>由于 JVM GC ，或是本地时间差异原因，可能自我保护机制的阀值 <code>expectedNumberOfRenewsPerMin</code>、<code>numberOfRenewsPerMinThreshold</code> 不够正确，在<strong>过期</strong>这个相对“危险”的操作，<strong>重新计算自我保护</strong>的阀值。</p></li></ul></li><li><p>第 35 至 51 行 ：<strong>随机</strong>清理过期的租约。由于租约是按照<strong>应用顺序</strong>添加到数组，通过随机的方式，<strong>尽量避免单个应用被全部过期</strong>。</p><ul><li>第 39 行 ：传入当前时间为种子生成随机，避免 Java 的伪随机情况。在 <a href="http://www.cnblogs.com/greatfish/p/5845924.html" rel="external nofollow noopener noreferrer" target="_blank">《为什么说Java中的随机数都是伪随机数？》</a> 有详细解析。</li><li>第 41 至 43 行 ：随机调换后面的元素到当前位置( <code>i</code> )。</li></ul></li><li>第 50 行 ：调用 <code>#internalCancel()</code> 方法，下线已过期的租约，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》「3.2 下线应用实例信息」</a> 有详细解析。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😫 原本觉得比较容易的一篇文章，结果消耗了比想象中的时间，可能有四个小时。主要卡在补偿时间，目前也没弄懂。如果有知道的胖友，麻烦告知下。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-evict/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-evict/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-self-preservation/</id>
    <published>2018-06-14T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">http://www.iocoder.cn/Eureka/instance-registry-self-preservation/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">2. 定义</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3. 实现</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3.1 触发条件</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3.2 计算公式</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3.3 计算时机</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>自我保护机制</strong>，为应用实例过期下线做铺垫。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h1><p>自我保护机制定义如下：</p><blockquote><p>FROM <a href="http://www.itmuch.com/spring-cloud-sum/understanding-eureka-self-preservation/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立 —— 《理解Eureka的自我保护模式》</a><br>当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p></blockquote><p><strong>为什么使用自动保护机制</strong> ？你也可以从周立兄的<strong>这篇文章得到答案</strong>，这里笔者就不一本正经的胡说八道了。</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>首先，我们来看下在自动保护机制里扮演<strong>重要</strong>角色的两个变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 期望最小每分钟续租次数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> numberOfRenewsPerMinThreshold;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 期望最大每分钟续租次数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> expectedNumberOfRenewsPerMin;</div></pre></td></tr></table></figure><ul><li><code>expectedNumberOfRenewsPerMin</code> ，期望<strong>最大</strong>每分钟<strong>续租</strong>次数。</li><li><code>numberOfRenewsPerMinThreshold</code> ，期望<strong>最小</strong>每分钟<strong>续租</strong>次数。</li></ul><h2 id="3-1-触发条件"><a href="#3-1-触发条件" class="headerlink" title="3.1 触发条件"></a>3.1 触发条件</h2><p>当每分钟心跳次数( <code>renewsLastMin</code> ) <strong>小于</strong> <code>numberOfRenewsPerMinThreshold</code> 时，并且开启自动保护模式开关( <code>eureka.enableSelfPreservation = true</code> ) 时，<strong>触发自动保护机制，不再自动过期租约</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</div><div class="line">       logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略过期租约逻辑</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</div><div class="line">       <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-计算公式"><a href="#3-2-计算公式" class="headerlink" title="3.2 计算公式"></a>3.2 计算公式</h2><p>计算公式如下：</p><ul><li><code>expectedNumberOfRenewsPerMin</code> = 当前注册的应用实例数 <code>x</code> 2 </li><li><code>numberOfRenewsPerMinThreshold</code> = <code>expectedNumberOfRenewsPerMin</code> <code>*</code> 续租百分比( <code>eureka.renewalPercentThreshold</code> )</li></ul><p><strong>为什么乘以 2</strong></p><p>默认情况下，注册的应用实例每半分钟续租一次，那么一分钟心跳<strong>两次</strong>，因此 x 2 。</p><p>这块会有一些硬编码的情况，<strong>因此不太建议修改应用实例的续租频率</strong>。</p><p><strong>为什么乘以续租百分比</strong></p><p>低于这个百分比，意味着开启自我保护机制。</p><p>默认情况下，<code>eureka.renewalPercentThreshold = 0.85</code> 。</p><p>如果你真的调整了<strong>续租频率</strong>，可以等比去续租百分比，以保证合适的触发自我保护机制的阀值。另外，你需要注意，续租频率是 Client 级别，续租百分比是 Server 级别。</p><h2 id="3-3-计算时机"><a href="#3-3-计算时机" class="headerlink" title="3.3 计算时机"></a>3.3 计算时机</h2><p>目前有<strong>四</strong>个地方会计算 <code>numberOfRenewsPerMinThreshold</code> 、 <code>expectedNumberOfRenewsPerMin</code>，我们逐小节来看。</p><h3 id="3-3-1-Eureka-Server-初始化"><a href="#3-3-1-Eureka-Server-初始化" class="headerlink" title="3.3.1 Eureka-Server 初始化"></a>3.3.1 Eureka-Server 初始化</h3><p>Eureka-Server 在启动时，从 Eureka-Server 集群获取注册信息，并<strong>首次</strong>初始化 <code>numberOfRenewsPerMinThreshold</code> 、 <code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaBootStrap.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略其它代码</span></div><div class="line"></div><div class="line">    <span class="comment">// 【2.2.10】从其他 Eureka-Server 拉取注册信息</span></div><div class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></div><div class="line">    <span class="keyword">int</span> registryCount = registry.syncUp();</div><div class="line">    registry.openForTraffic(applicationInfoManager, registryCount);</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">   <span class="comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span></div><div class="line">   <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</div><div class="line">   <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line">           (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">           </div><div class="line">   <span class="comment">// ... 省略其它代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-2-定时重置"><a href="#3-3-2-定时重置" class="headerlink" title="3.3.2 定时重置"></a>3.3.2 定时重置</h3><p>Eureka-Server <strong>定时</strong>重新计算 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</div><div class="line">   timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">                      <span class="meta">@Override</span></div><div class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                          updateRenewalThreshold();</div><div class="line">                      &#125;</div><div class="line">                  &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</div><div class="line">           serverConfig.getRenewalThresholdUpdateIntervalMs());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 自我保护机锁</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* 当计算如下参数时使用：</span></div><div class="line"><span class="comment">*  1. &#123;<span class="doctag">@link</span> #numberOfRenewsPerMinThreshold&#125;</span></div><div class="line"><span class="comment">*  2. &#123;<span class="doctag">@link</span> #expectedNumberOfRenewsPerMin&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRenewalThreshold</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 计算 应用实例数</span></div><div class="line">       Applications apps = eurekaClient.getApplications();</div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</div><div class="line">           <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.isRegisterable(instance)) &#123;</div><div class="line">                   ++count;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 计算 expectedNumberOfRenewsPerMin 、 numberOfRenewsPerMinThreshold 参数</span></div><div class="line">       <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">           <span class="comment">// Update threshold only if the threshold is greater than the</span></div><div class="line">           <span class="comment">// current expected threshold of if the self preservation is disabled.</span></div><div class="line">           <span class="keyword">if</span> ((count * <span class="number">2</span>) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</div><div class="line">                   || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</div><div class="line">               <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</div><div class="line">               <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) ((count * <span class="number">2</span>) * serverConfig.getRenewalPercentThreshold());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       logger.info(<span class="string">"Current renewal threshold is : &#123;&#125;"</span>, numberOfRenewsPerMinThreshold);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot update renewal threshold"</span>, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.renewalThresholdUpdateIntervalMs</code> 参数，定时重新计算。默认，15 分钟。</li><li><strong>代码块</strong> <code>!this.isSelfPreservationModeEnabled()</code> ：当<strong>未开启</strong>自我保护机制时，每次都进行重新计算。事实上，这两个参数不仅仅自我保护机制会使用到，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集 <code>numberOfRenewsPerMinThreshold</code>、<code>expectedNumberOfRenewsPerMin</code>。</li><li><strong>代码块</strong> <code>(count * 2) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</code> ：当<strong>开启</strong>自我保护机制时，应用实例每分钟最大心跳数( <code>count * 2</code> ) 小于期望<strong>最小</strong>每分钟<strong>续租</strong>次数( <code>serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold</code> )，不重新计算。<strong>如果重新计算，自动保护机制会每次定时执行后失效</strong>。</li></ul><h3 id="3-3-3-应用实例注册"><a href="#3-3-3-应用实例注册" class="headerlink" title="3.3.3 应用实例注册"></a>3.3.3 应用实例注册</h3><p>应用实例注册时，增加 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line">    <span class="comment">// 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></div><div class="line">             <span class="comment">// (1</span></div><div class="line">             <span class="comment">// for 30 seconds, 2 for a minute)</span></div><div class="line">             <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</div><div class="line">             <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line">                     (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-4-应用实例下线"><a href="#3-3-4-应用实例下线" class="headerlink" title="3.3.4 应用实例下线"></a>3.3.4 应用实例下线</h3><p>应用实例下线时，减少 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params">                     <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">                     </div><div class="line">   <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line">               <span class="comment">// Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute)</span></div><div class="line">               <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin - <span class="number">2</span>;</div><div class="line">               <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 终于完整理解 Eureka-Server 自我保护机制，满足。噶<del>~</del>~</p><p>推荐另一篇 Eureka-Server 自我保护机制源码分析文章：<a href="https://segmentfault.com/a/1190000009795944" rel="external nofollow noopener noreferrer" target="_blank">《理解eureka的自我保护机制》</a> 。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-self-preservation/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-self-
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（三）之下线</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-cancel/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-cancel/</id>
    <published>2018-06-07T16:00:00.000Z</published>
    <updated>2017-10-17T14:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">http://www.iocoder.cn/Eureka/instance-registry-cancel/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">2. Eureka-Client 发起下线</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">3. Eureka-Server 接收下线</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">3.1 接收下线请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">3.2 下线应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 下线应用实例的过程</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="../../../images/Eureka/2018_06_08/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1 id="2-Eureka-Client-发起下线"><a href="#2-Eureka-Client-发起下线" class="headerlink" title="2. Eureka-Client 发起下线"></a>2. Eureka-Client 发起下线</h1><p>应用实例关闭时，Eureka-Client 向 Eureka-Server 发起下线应用实例。需要满足如下条件才可发起：</p><ul><li>配置 <code>eureka.registration.enabled = true</code> ，应用实例开启注册开关。默认为 <code>false</code> 。</li><li>配置 <code>eureka.shouldUnregisterOnShutdown = true</code> ，应用实例开启关闭时下线开关。默认为 <code>true</code> 。</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="comment">// If APPINFO was registered</span></div><div class="line">    <span class="keyword">if</span> (applicationInfoManager != <span class="keyword">null</span></div><div class="line">         &amp;&amp; clientConfig.shouldRegisterWithEureka() <span class="comment">// eureka.registration.enabled = true</span></div><div class="line">         &amp;&amp; clientConfig.shouldUnregisterOnShutdown()) &#123; <span class="comment">// eureka.shouldUnregisterOnShutdown = true</span></div><div class="line">        applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);</div><div class="line">        unregister();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法，设置应用实例为关闭( DOWN )。</li><li><p>调用 <code>#unregister()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// It can be null if shouldRegisterWithEureka == false</span></div><div class="line">   <span class="keyword">if</span>(eurekaTransport != <span class="keyword">null</span> &amp;&amp; eurekaTransport.registrationClient != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           logger.info(<span class="string">"Unregistering ..."</span>);</div><div class="line">           EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());</div><div class="line">           logger.info(PREFIX + appPathIdentifier + <span class="string">" - deregister  status: "</span> + httpResponse.getStatusCode());</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           logger.error(PREFIX + appPathIdentifier + <span class="string">" - de-registration failed"</span> + e.getMessage(), e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">cancel</span><span class="params">(String appName, String id)</span> </span>&#123;</div><div class="line">    String urlPath = <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">    ClientResponse response = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line">        addExtraHeaders(resourceBuilder);</div><div class="line">        response = resourceBuilder.delete(ClientResponse.class);</div><div class="line">        <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"Jersey HTTP DELETE &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">            response.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#cancel(...)</code> 方法，<code>DELETE</code> 请求 Eureka-Server 的 <code>apps/${APP_NAME}/${INSTANCE_INFO_ID}</code> 接口，实现应用实例信息的下线。</li></ul></li></ul><h1 id="3-Eureka-Server-接收下线"><a href="#3-Eureka-Server-接收下线" class="headerlink" title="3. Eureka-Server 接收下线"></a>3. Eureka-Server 接收下线</h1><h2 id="3-1-接收下线请求"><a href="#3-1-接收下线请求" class="headerlink" title="3.1 接收下线请求"></a>3.1 接收下线请求</h2><p><code>com.netflix.eureka.resources.InstanceResource</code>，处理<strong>单个</strong>应用实例信息的请求操作的 Resource ( Controller )。</p><p>下线应用实例信息的请求，映射 <code>InstanceResource#cancelLease()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">cancelLease</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</div><div class="line">   <span class="comment">// 下线</span></div><div class="line">   <span class="keyword">boolean</span> isSuccess = registry.cancel(app.getName(), id, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (isSuccess) &#123; <span class="comment">// 下线成功</span></div><div class="line">       logger.debug(<span class="string">"Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">       <span class="keyword">return</span> Response.ok().build();</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 下线成功</span></div><div class="line">       logger.info(<span class="string">"Not Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">       <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>PeerAwareInstanceRegistryImpl#cancel(...)</code> 方法，下线应用实例。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                       <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (<span class="keyword">super</span>.cancel(appName, id, isReplication)) &#123; <span class="comment">// 下线</span></div><div class="line"> <span class="number">5</span>:         <span class="comment">// Eureka-Server 复制</span></div><div class="line"> <span class="number">6</span>:         replicateToPeers(Action.Cancel, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 减少 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">10</span>:                 <span class="comment">// Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute)</span></div><div class="line"><span class="number">11</span>:                 <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin - <span class="number">2</span>;</div><div class="line"><span class="number">12</span>:                 <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">13</span>:             &#125;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">18</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：调用父类 <code>AbstractInstanceRegistry#cancel(...)</code> 方法，下线应用实例信息。</li><li>第 6 行 ：Eureka-Server 复制下线操作，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</li><li>第 7 至 14 行 ：减少 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code>，自我保护机制相关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</li></ul></li></ul><h2 id="3-2-下线应用实例信息"><a href="#3-2-下线应用实例信息" class="headerlink" title="3.2 下线应用实例信息"></a>3.2 下线应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#cancel(...)</code> 方法，下线应用实例信息，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">return</span> internalCancel(appName, id, isReplication);</div><div class="line"> <span class="number">4</span>: &#125;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 获得锁 TODO 芋艿：疑问</span></div><div class="line"> <span class="number">9</span>:         read.lock();</div><div class="line"><span class="number">10</span>:         <span class="comment">// 增加 取消注册次数 到 监控</span></div><div class="line"><span class="number">11</span>:         CANCEL.increment(isReplication);</div><div class="line"><span class="number">12</span>:         <span class="comment">// 移除 租约映射</span></div><div class="line"><span class="number">13</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">14</span>:         Lease&lt;InstanceInfo&gt; leaseToCancel = <span class="keyword">null</span>;</div><div class="line"><span class="number">15</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">16</span>:             leaseToCancel = gMap.remove(id);</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:         <span class="comment">// 添加到 最近取消注册的调试队列</span></div><div class="line"><span class="number">19</span>:         <span class="keyword">synchronized</span> (recentCanceledQueue) &#123;</div><div class="line"><span class="number">20</span>:             recentCanceledQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + <span class="string">"("</span> + id + <span class="string">")"</span>));</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:         <span class="comment">// 移除 应用实例覆盖状态映射</span></div><div class="line"><span class="number">23</span>:         InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</div><div class="line"><span class="number">24</span>:         <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">25</span>:             logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</div><div class="line"><span class="number">26</span>:         &#125;</div><div class="line"><span class="number">27</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (leaseToCancel == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             CANCEL_NOT_FOUND.increment(isReplication); <span class="comment">// 添加 取消注册不存在 到 监控</span></div><div class="line"><span class="number">30</span>:             logger.warn(<span class="string">"DS: Registry: cancel failed because Lease is not registered for: &#123;&#125;/&#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">31</span>:             <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 失败</span></div><div class="line"><span class="number">32</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">33</span>:             <span class="comment">// 设置 租约的取消注册时间戳</span></div><div class="line"><span class="number">34</span>:             leaseToCancel.cancel();</div><div class="line"><span class="number">35</span>:             <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">36</span>:             InstanceInfo instanceInfo = leaseToCancel.getHolder();</div><div class="line"><span class="number">37</span>:             String vip = <span class="keyword">null</span>;</div><div class="line"><span class="number">38</span>:             String svip = <span class="keyword">null</span>;</div><div class="line"><span class="number">39</span>:             <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">40</span>:                 instanceInfo.setActionType(ActionType.DELETED);</div><div class="line"><span class="number">41</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(leaseToCancel));</div><div class="line"><span class="number">42</span>:                 instanceInfo.setLastUpdatedTimestamp();</div><div class="line"><span class="number">43</span>:                 vip = instanceInfo.getVIPAddress();</div><div class="line"><span class="number">44</span>:                 svip = instanceInfo.getSecureVipAddress();</div><div class="line"><span class="number">45</span>:             &#125;</div><div class="line"><span class="number">46</span>:             <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">47</span>:             invalidateCache(appName, vip, svip);</div><div class="line"><span class="number">48</span>:             logger.info(<span class="string">"Cancelled instance &#123;&#125;/&#123;&#125; (replication=&#123;&#125;)"</span>, appName, id, isReplication);</div><div class="line"><span class="number">49</span>:             <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 成功</span></div><div class="line"><span class="number">50</span>:         &#125;</div><div class="line"><span class="number">51</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">52</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">53</span>:         read.unlock();</div><div class="line"><span class="number">54</span>:     &#125;</div><div class="line"><span class="number">55</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 9 行 ：TODO 为什么是读锁。</li><li>第 10 至 11 行 ：增加下线次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 12 至 17 行 ：移除租约映射( <code>registry</code> )。</li><li><p>第 18 至 21 行 ：添加到最近下线的<strong>调试</strong>队列( <code>recentCanceledQueue</code> )，用于 Eureka-Server 运维界面的显示，无实际业务逻辑使用。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近取消注册的调试队列</span></div><div class="line"><span class="comment">* key ：添加时的时间戳</span></div><div class="line"><span class="comment">* value ：字符串 = 应用名(应用实例信息编号)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt; recentCanceledQueue;</div></pre></td></tr></table></figure></li><li><p>第 22 至 26 行 ：移除应用实例覆盖状态映射。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li>第 27 至 31 行 ：租约不存在，返回下线失败( <code>false</code> )。</li><li><p>第 34 行 ：调用 <code>Lease#cancel()</code> 方法，取消租约。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lease.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (evictionTimestamp &lt;= <span class="number">0</span>) &#123;</div><div class="line">       evictionTimestamp = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 35 至 45 行 ：设置应用实例信息的<strong>操作类型为添加</strong>，并添加到最近租约变更记录队列( <code>recentlyChangedQueue</code> )。<code>recentlyChangedQueue</code> 用于注册信息的<strong>增量</strong>获取，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self">《应用实例注册发现 （七）之增量获取》</a>详细解析。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div></pre></td></tr></table></figure></li><li><p>第 47 行 ：设置响应缓存( ResponseCache )过期，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a>详细解析。</p></li><li>第 49 行 ：返回下线失败( <code>false</code> )。</li><li>第 53 行 ：释放锁。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>水更一篇，下一篇<strong>租约过期</strong>！走起。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-cancel/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-cancel/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（二）之续租</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-renew/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-renew/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2017-10-17T14:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">http://www.iocoder.cn/Eureka/instance-registry-renew/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2. Eureka-Client 发起续租</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.1 初始化定时任务</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.2 HeartbeatThread</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.3 TimedSupervisorTask</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3. Eureka-Server 接收续租</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3.1 接收续租请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3.2 续租应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 续租应用实例的过程</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="http://www.iocoder.cn/images/Eureka/2018_06_01/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1 id="2-Eureka-Client-发起续租"><a href="#2-Eureka-Client-发起续租" class="headerlink" title="2. Eureka-Client 发起续租"></a>2. Eureka-Client 发起续租</h1><p>Eureka-Client 向 Eureka-Server 发起注册应用实例成功后获得租约 ( Lease )。<br>Eureka-Client <strong>固定间隔</strong>向 Eureka-Server 发起<strong>续租</strong>( renew )，避免租约过期。</p><p>默认情况下，租约有效期为 90 秒，续租频率为 30 秒。两者比例为 1 : 3 ，保证在网络异常等情况下，有三次重试的机会。</p><h2 id="2-1-初始化定时任务"><a href="#2-1-初始化定时任务" class="headerlink" title="2.1 初始化定时任务"></a>2.1 初始化定时任务</h2><p>Eureka-Client 在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">初始化</a>过程中，创建<strong>心跳</strong>线程，<strong>固定间隔</strong>向 Eureka-Server 发起<strong>续租</strong>( renew )。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">               Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">               <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                       .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">                       .setDaemon(<span class="keyword">true</span>)</div><div class="line">                       .build());</div><div class="line"></div><div class="line">    heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">              <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">              <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                      .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</div><div class="line">                      .setDaemon(<span class="keyword">true</span>)</div><div class="line">                      .build()</div><div class="line">    );  <span class="comment">// use direct handoff</span></div><div class="line">      </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">  </div><div class="line">    <span class="comment">// 【3.2.14】初始化定时任务</span></div><div class="line">    initScheduledTasks();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); <span class="comment">// 续租频率</span></div><div class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); <span class="comment">//</span></div><div class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</div><div class="line"></div><div class="line">        <span class="comment">// Heartbeat timer</span></div><div class="line">        scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"heartbeat"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       heartbeatExecutor,</div><div class="line">                       renewalIntervalInSecs,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> HeartbeatThread()</div><div class="line">               ),</div><div class="line">               renewalIntervalInSecs, TimeUnit.SECONDS);</div><div class="line">               </div><div class="line">          <span class="comment">// ... 省略无关代码</span></div><div class="line">     &#125;</div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>scheduler</code>，定时任务服务，用于定时触发心跳( 续租 )。细心如你，会发现任务提交的方式是 <code>ScheduledExecutorService#schedule(...)</code> 方法，<strong>只延迟执行一次心跳，说好的固定频率执行心跳呢</strong>！！！答案在 <a href="#">「2.3 TimedSupervisorTask」</a> 揭晓。</li><li><code>heartbeatExecutor</code>，心跳任务执行线程池。为什么有 <code>scheduler</code> 的情况下，还有 <code>heartbeatExecutor</code> ？？？答案也在 <a href="#">「2.3 TimedSupervisorTask」</a> 揭晓。</li><li>HeartbeatThread，心跳线程，在<a href="#">「2.2 TimedSupervisorTask」</a> 详细解析。</li></ul><h2 id="2-2-HeartbeatThread"><a href="#2-2-HeartbeatThread" class="headerlink" title="2.2 HeartbeatThread"></a>2.2 HeartbeatThread</h2><p><code>com.netflix.discovery.DiscoveryClient.HeartbeatThread</code>，心跳线程，<strong>实现</strong>执行 Eureka-Client 向 Eureka-Server 发起<strong>续租</strong>( renew )请求。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功向 Eureka-Server 心跳时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulHeartbeatTimestamp = -<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (renew()) &#123;</div><div class="line">           lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#renew</code> 方法，执行续租逻辑。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">   EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</div><div class="line">       logger.debug(<span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">       <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</div><div class="line">           REREGISTER_COUNTER.increment();</div><div class="line">           logger.info(<span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, PREFIX + appPathIdentifier, instanceInfo.getAppName());</div><div class="line">           <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</div><div class="line">           <span class="comment">// 发起注册</span></div><div class="line">           <span class="keyword">boolean</span> success = register();</div><div class="line">           <span class="keyword">if</span> (success) &#123;</div><div class="line">               instanceInfo.unsetIsDirty(timestamp);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> success;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, PREFIX + appPathIdentifier, e);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>AbstractJerseyEurekaHttpClient#sendHeartBeat(...)</code> 方法，发起<strong>续租请求</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;InstanceInfo&gt; <span class="title">sendHeartBeat</span><span class="params">(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus)</span> </span>&#123;</div><div class="line">   String urlPath = <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       WebResource webResource = jerseyClient.resource(serviceUrl)</div><div class="line">               .path(urlPath)</div><div class="line">               .queryParam(<span class="string">"status"</span>, info.getStatus().toString())</div><div class="line">               .queryParam(<span class="string">"lastDirtyTimestamp"</span>, info.getLastDirtyTimestamp().toString());</div><div class="line">       <span class="keyword">if</span> (overriddenStatus != <span class="keyword">null</span>) &#123;</div><div class="line">           webResource = webResource.queryParam(<span class="string">"overriddenstatus"</span>, overriddenStatus.name());</div><div class="line">       &#125;</div><div class="line">       Builder requestBuilder = webResource.getRequestBuilder();</div><div class="line">       addExtraHeaders(requestBuilder);</div><div class="line">       response = requestBuilder.put(ClientResponse.class);</div><div class="line">       EurekaHttpResponseBuilder&lt;InstanceInfo&gt; eurekaResponseBuilder = anEurekaHttpResponse(response.getStatus(), InstanceInfo.class).headers(headersOf(response));</div><div class="line">       <span class="keyword">if</span> (response.hasEntity()) &#123;</div><div class="line">           eurekaResponseBuilder.entity(response.getEntity(InstanceInfo.class));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> eurekaResponseBuilder.build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP PUT &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>PUT 请求 Eureka-Server 的 <code>apps/${APP_NAME}/${INSTANCE_INFO_ID}</code> 接口，参数为 <code>status</code>、<code>lastDirtyTimestamp</code>、<code>overriddenstatus</code>，实现续租。</li></ul></li><li><p>调用 <code>AbstractJerseyEurekaHttpClient#register(...)</code> 方法，当 Eureka-Server <strong>不存在租约</strong>时，重新发起注册，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》</a>有详细解析。</p></li></ul></li></ul><h2 id="2-3-TimedSupervisorTask"><a href="#2-3-TimedSupervisorTask" class="headerlink" title="2.3 TimedSupervisorTask"></a>2.3 TimedSupervisorTask</h2><p><code>com.netflix.discovery.TimedSupervisorTask</code>，监管<strong>定时任务</strong>的任务。</p><blockquote><p>A supervisor task that schedules subtasks while enforce a timeout.</p></blockquote><p>创建 TimedSupervisorTask 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedSupervisorTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter timeoutCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter rejectedCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter throwableCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongGauge threadPoolLevelGauge;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行子任务线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 子任务执行超时时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 子任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前任子务执行频率</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong delay;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最大子任务执行频率</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 子任务执行超时情况下使用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDelay;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimedSupervisorTask</span><span class="params">(String name, ScheduledExecutorService scheduler, ThreadPoolExecutor executor,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> expBackOffBound, Runnable task)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">        <span class="keyword">this</span>.timeoutMillis = timeUnit.toMillis(timeout);</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.delay = <span class="keyword">new</span> AtomicLong(timeoutMillis);</div><div class="line">        <span class="keyword">this</span>.maxDelay = timeoutMillis * expBackOffBound;</div><div class="line"></div><div class="line">        <span class="comment">// Initialize the counters and register.</span></div><div class="line">        timeoutCounter = Monitors.newCounter(<span class="string">"timeouts"</span>);</div><div class="line">        rejectedCounter = Monitors.newCounter(<span class="string">"rejectedExecutions"</span>);</div><div class="line">        throwableCounter = Monitors.newCounter(<span class="string">"throwables"</span>);</div><div class="line">        threadPoolLevelGauge = <span class="keyword">new</span> LongGauge(MonitorConfig.builder(<span class="string">"threadPoolUsed"</span>).build());</div><div class="line">        Monitors.registerObject(name, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>scheduler</code> ，定时任务服务，用于定时【<strong>发起</strong>】子任务。</li><li><code>executor</code> ，执行子任务线程池，用于【<strong>提交</strong>】子任务执行。</li><li><code>task</code> ，子任务。</li><li><code>timeoutMillis</code> ，子任务执行超时时间，单位：毫秒。</li><li><code>delay</code> ，当前子任务执行频率，单位：毫秒。值等于 <code>timeout</code> 参数。</li><li><code>maxDelay</code> ，<strong>最大</strong>子任务执行频率，单位：毫秒。值等于 <code>timeout * expBackOffBound</code> 参数。</li></ul><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_01/02.png" alt=""></p><ul><li><code>scheduler</code> 初始化延迟执行 TimedSupervisorTask 。</li><li>TimedSupervisorTask 执行时，提交 <code>task</code> 到 <code>executor</code> 执行任务。<ul><li>当 <code>task</code> 执行正常，TimedSupervisorTask <strong>再次</strong>提交<strong>自己</strong>到<code>scheduler</code> 延迟 <code>timeoutMillis</code> 执行。</li><li>当 <code>task</code> 执行超时，重新计算延迟时间( 不允许超过 <code>maxDelay</code> )，<strong>再次</strong>提交<strong>自己</strong>到<code>scheduler</code> 延迟执行。</li></ul></li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TimedSupervisorTask.java</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     Future&lt;?&gt; future = <span class="keyword">null</span>;</div><div class="line">  <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">5</span>:         <span class="comment">// 提交 任务</span></div><div class="line">  <span class="number">6</span>:         future = executor.submit(task);</div><div class="line">  <span class="number">7</span>:         <span class="comment">//</span></div><div class="line">  <span class="number">8</span>:         threadPoolLevelGauge.set((<span class="keyword">long</span>) executor.getActiveCount());</div><div class="line">  <span class="number">9</span>:         <span class="comment">// 等待任务 执行完成 或 超时</span></div><div class="line"> <span class="number">10</span>:         future.get(timeoutMillis, TimeUnit.MILLISECONDS);  <span class="comment">// block until done or timeout</span></div><div class="line"> <span class="number">11</span>:         <span class="comment">// 设置 下一次任务执行频率</span></div><div class="line"> <span class="number">12</span>:         delay.set(timeoutMillis);</div><div class="line"> <span class="number">13</span>:         <span class="comment">//</span></div><div class="line"> <span class="number">14</span>:         threadPoolLevelGauge.set((<span class="keyword">long</span>) executor.getActiveCount());</div><div class="line"> <span class="number">15</span>:     &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line"> <span class="number">16</span>:         logger.error(<span class="string">"task supervisor timed out"</span>, e);</div><div class="line"> <span class="number">17</span>:         timeoutCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">18</span>: </div><div class="line"> <span class="number">19</span>:         <span class="comment">// 设置 下一次任务执行频率</span></div><div class="line"> <span class="number">20</span>:         <span class="keyword">long</span> currentDelay = delay.get();</div><div class="line"> <span class="number">21</span>:         <span class="keyword">long</span> newDelay = Math.min(maxDelay, currentDelay * <span class="number">2</span>);</div><div class="line"> <span class="number">22</span>:         delay.compareAndSet(currentDelay, newDelay);</div><div class="line"> <span class="number">23</span>: </div><div class="line"> <span class="number">24</span>:     &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (executor.isShutdown() || scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">26</span>:             logger.warn(<span class="string">"task supervisor shutting down, reject the task"</span>, e);</div><div class="line"> <span class="number">27</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">28</span>:             logger.error(<span class="string">"task supervisor rejected the task"</span>, e);</div><div class="line"> <span class="number">29</span>:         &#125;</div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:         rejectedCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">32</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (executor.isShutdown() || scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">34</span>:             logger.warn(<span class="string">"task supervisor shutting down, can't accept the task"</span>);</div><div class="line"> <span class="number">35</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">36</span>:             logger.error(<span class="string">"task supervisor threw an exception"</span>, e);</div><div class="line"> <span class="number">37</span>:         &#125;</div><div class="line"> <span class="number">38</span>: </div><div class="line"> <span class="number">39</span>:         throwableCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">40</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">41</span>:         <span class="comment">// 取消 未完成的任务</span></div><div class="line"> <span class="number">42</span>:         <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">43</span>:             future.cancel(<span class="keyword">true</span>);</div><div class="line"> <span class="number">44</span>:         &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:         <span class="comment">// 调度 下次任务</span></div><div class="line"> <span class="number">47</span>:         <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">48</span>:             scheduler.schedule(<span class="keyword">this</span>, delay.get(), TimeUnit.MILLISECONDS);</div><div class="line"> <span class="number">49</span>:         &#125;</div><div class="line"> <span class="number">50</span>:     &#125;</div><div class="line"> <span class="number">51</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 6 行 ：提交子任务 <code>task</code> 到执行子任务线程池 <code>executor</code> 。</li><li>第 9 至 10 行 ：等待子任务 <code>task</code> 执行完成或执行超时。</li><li>第 11 至 12 行 ：子任务 <code>task</code> 执行完成，设置下一次执行延迟 <code>delay</code> 。</li><li>第 19 至 22 行 ：子任务 <code>task</code> 执行超时，重新计算下一次执行延迟 <code>delay</code> 。计算公式为 <code>Math.min(maxDelay, currentDelay * 2)</code> 。如果多次超时，超时时间不断乘以 2 ，不允许超过最大延迟时间( <code>maxDelay</code> )。</li><li>第 41 至 44 行 ：<strong>强制</strong>取消未完成的子任务。</li><li>第 46 至 49 行 ：调度下一次 TimedSupervisorTask 。</li></ul><h1 id="3-Eureka-Server-接收续租"><a href="#3-Eureka-Server-接收续租" class="headerlink" title="3. Eureka-Server 接收续租"></a>3. Eureka-Server 接收续租</h1><h2 id="3-1-接收续租请求"><a href="#3-1-接收续租请求" class="headerlink" title="3.1 接收续租请求"></a>3.1 接收续租请求</h2><p><code>com.netflix.eureka.resources.InstanceResource</code>，处理<strong>单个</strong>应用实例信息的请求操作的 Resource ( Controller )。</p><p>续租应用实例信息的请求，映射 <code>InstanceResource#renewLease()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@PUT</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:         @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function"> 4:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</span></div><div class="line"><span class="function"> 5:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</span></div><div class="line"><span class="function"> 6:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">boolean</span> isFromReplicaNode = <span class="string">"true"</span>.equals(isReplication);</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 续租</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 续租失败</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// Not found in the registry, immediately ask for a register</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">if</span> (!isSuccess) &#123;</div><div class="line"><span class="number">14</span>:         logger.warn(<span class="string">"Not Found (Renew): &#123;&#125; - &#123;&#125;"</span>, app.getName(), id);</div><div class="line"><span class="number">15</span>:         <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:     <span class="comment">// 比较 InstanceInfo 的 lastDirtyTimestamp 属性</span></div><div class="line"><span class="number">19</span>:     <span class="comment">// Check if we need to sync based on dirty time stamp, the client</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// instance might have changed some value</span></div><div class="line"><span class="number">21</span>:     Response response = <span class="keyword">null</span>;</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span> &amp;&amp; serverConfig.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"><span class="number">23</span>:         response = <span class="keyword">this</span>.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);</div><div class="line"><span class="number">24</span>:         <span class="comment">// Store the overridden status since the validation found out the node that replicates wins</span></div><div class="line"><span class="number">25</span>:         <span class="keyword">if</span> (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()</div><div class="line"><span class="number">26</span>:                 &amp;&amp; (overriddenStatus != <span class="keyword">null</span>)</div><div class="line"><span class="number">27</span>:                 &amp;&amp; !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))</div><div class="line"><span class="number">28</span>:                 &amp;&amp; isFromReplicaNode) &#123;</div><div class="line"><span class="number">29</span>:             registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 成功</span></div><div class="line"><span class="number">32</span>:         response = Response.ok().build();</div><div class="line"><span class="number">33</span>:     &#125;</div><div class="line"><span class="number">34</span>:     logger.debug(<span class="string">"Found (Renew): &#123;&#125; - &#123;&#125;; reply status=&#123;&#125;"</span> + app.getName(), id, response.getStatus());</div><div class="line"><span class="number">35</span>:     <span class="keyword">return</span> response;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 8 至 9 行 ：调用 <code>PeerAwareInstanceRegistryImpl#renew(...)</code> 方法，续租。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.renew(appName, id, isReplication)) &#123; <span class="comment">// 续租</span></div><div class="line">       <span class="comment">// Eureka-Server 复制</span></div><div class="line">       replicateToPeers(Action.Heartbeat, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#renew(...)</code> 方法，注册应用实例信息。</li></ul></li><li><p>第 11 至 16 行 ：续租失败，返回 404 响应。当 Eureka-Client 收到 404 响应后，会重新发起 InstanceInfo 的注册。</p></li><li><p>第 18 至 30 行 ：比较请求的 <code>lastDirtyTimestamp</code> 和 Server 的 InstanceInfo 的 <code>lastDirtyTimestamp</code> 属性差异，需要配置 <code>eureka.syncWhenTimestampDiffers = true</code> ( 默认开启 )。</p><ul><li><p>第 23 行 ：调用 <code>#validateDirtyTimestamp(...)</code> 方法，比较 <code>lastDirtyTimestamp</code> 的差异。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceResource.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Response <span class="title">validateDirtyTimestamp</span><span class="params">(Long lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 获取 InstanceInfo</span></div><div class="line">  <span class="number">3</span>:     InstanceInfo appInfo = registry.getInstanceByAppAndId(app.getName(), id, <span class="keyword">false</span>);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (appInfo != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">5</span>:         <span class="keyword">if</span> ((lastDirtyTimestamp != <span class="keyword">null</span>) &amp;&amp; (!lastDirtyTimestamp.equals(appInfo.getLastDirtyTimestamp()))) &#123;</div><div class="line">  <span class="number">6</span>:             Object[] args = &#123;id, appInfo.getLastDirtyTimestamp(), lastDirtyTimestamp, isReplication&#125;;</div><div class="line">  <span class="number">7</span>:             <span class="comment">// 请求 的 较大</span></div><div class="line">  <span class="number">8</span>:             <span class="keyword">if</span> (lastDirtyTimestamp &gt; appInfo.getLastDirtyTimestamp()) &#123;</div><div class="line">  <span class="number">9</span>:                 logger.debug(<span class="string">"Time to sync, since the last dirty timestamp differs -"</span></div><div class="line"> <span class="number">10</span>:                                 + <span class="string">" ReplicationInstance id : &#123;&#125;,Registry : &#123;&#125; Incoming: &#123;&#125; Replication: &#123;&#125;"</span>, args);</div><div class="line"> <span class="number">11</span>:                 <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line"> <span class="number">12</span>:             <span class="comment">// Server 的 较大</span></div><div class="line"> <span class="number">13</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appInfo.getLastDirtyTimestamp() &gt; lastDirtyTimestamp) &#123;</div><div class="line"> <span class="number">14</span>:                 <span class="comment">// In the case of replication, send the current instance info in the registry for the</span></div><div class="line"> <span class="number">15</span>:                 <span class="comment">// replicating node to sync itself with this one.</span></div><div class="line"> <span class="number">16</span>:                 <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">17</span>:                     logger.debug(</div><div class="line"> <span class="number">18</span>:                             <span class="string">"Time to sync, since the last dirty timestamp differs -"</span></div><div class="line"> <span class="number">19</span>:                                     + <span class="string">" ReplicationInstance id : &#123;&#125;,Registry : &#123;&#125; Incoming: &#123;&#125; Replication: &#123;&#125;"</span>,</div><div class="line"> <span class="number">20</span>:                             args);</div><div class="line"> <span class="number">21</span>:                     <span class="keyword">return</span> Response.status(Status.CONFLICT).entity(appInfo).build();</div><div class="line"> <span class="number">22</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">23</span>:                     <span class="keyword">return</span> Response.ok().build();</div><div class="line"> <span class="number">24</span>:                 &#125;</div><div class="line"> <span class="number">25</span>:             &#125;</div><div class="line"> <span class="number">26</span>:         &#125;</div><div class="line"> <span class="number">27</span>: </div><div class="line"> <span class="number">28</span>:     &#125;</div><div class="line"> <span class="number">29</span>:     <span class="keyword">return</span> Response.ok().build();</div><div class="line"> <span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 11 行 ：请求的 <code>lastDirtyTimestamp</code> 较大，<strong>意味着请求方( 可能是 Eureka-Client ，也可能是 Eureka-Server 集群内的其他 Server )存在 InstanceInfo 和 Eureka-Server 的 InstanceInfo 的数据不一致，返回 404 响应。请求方收到 404 响应后重新发起注册</strong>。</li><li>第 16 至 21 行 ：<a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</li><li>第 22 至 24 行 ：Server 的 <code>lastDirtyTimestamp</code> 较大，并且请求方为 Eureka-Client，续租成功，返回 200 成功响应。</li><li>第 29 行 ：<code>lastDirtyTimestamp</code> 一致，返回 200 成功响应。</li></ul><ul><li>第 24 至 30 行 ：<a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</li></ul></li></ul></li><li><p>第 31 至 33 行 ：续租成功，返回 200 成功响应。</p></li></ul><h2 id="3-2-续租应用实例信息"><a href="#3-2-续租应用实例信息" class="headerlink" title="3.2 续租应用实例信息"></a>3.2 续租应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#renew(...)</code> 方法，续租应用实例信息，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 增加 续租次数 到 监控</span></div><div class="line"> <span class="number">3</span>:     RENEW.increment(isReplication);</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 获得 租约</span></div><div class="line"> <span class="number">5</span>:     Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"> <span class="number">6</span>:     Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">8</span>:         leaseToRenew = gMap.get(id);</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>:         RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"><span class="number">13</span>:         logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">14</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">15</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>:         InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></div><div class="line"><span class="number">19</span>:             <span class="comment">// override status</span></div><div class="line"><span class="number">20</span>:             InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line"><span class="number">21</span>:                     instanceInfo, leaseToRenew, isReplication);</div><div class="line"><span class="number">22</span>:             <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line"><span class="number">23</span>:                 logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line"><span class="number">24</span>:                         + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line"><span class="number">25</span>:                 RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"><span class="number">26</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">27</span>:             &#125;</div><div class="line"><span class="number">28</span>:             <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line"><span class="number">29</span>:                 Object[] args = &#123;</div><div class="line"><span class="number">30</span>:                         instanceInfo.getStatus().name(),</div><div class="line"><span class="number">31</span>:                         instanceInfo.getOverriddenStatus().name(),</div><div class="line"><span class="number">32</span>:                         instanceInfo.getId()</div><div class="line"><span class="number">33</span>:                 &#125;;</div><div class="line"><span class="number">34</span>:                 logger.info(</div><div class="line"><span class="number">35</span>:                         <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line"><span class="number">36</span>:                                 + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line"><span class="number">37</span>:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"><span class="number">38</span>:             &#125;</div><div class="line"><span class="number">39</span>:         &#125;</div><div class="line"><span class="number">40</span>:         <span class="comment">// 新增 续租每分钟次数</span></div><div class="line"><span class="number">41</span>:         renewsLastMin.increment();</div><div class="line"><span class="number">42</span>:         <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">43</span>:         leaseToRenew.renew();</div><div class="line"><span class="number">44</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">45</span>:     &#125;</div><div class="line"><span class="number">46</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 3 行 ：增加续租次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 4 至 9 行 ：获得租约( Lease )。</li><li>第 10 至 14 行 ：租约不存在，返回续租失败( <code>false</code> )。</li><li>第 19 至 21 行 ：获得应用实例的<strong>最终状态</strong>。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</li><li>第 22 至 27 行 ：应用实例的<strong>最终状态</strong>为 <code>UNKNOWN</code>，无法续约，返回 <code>false</code> 。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</li><li>第 28 至 37 行 ：应用实例的状态与<strong>最终状态</strong>不相等，使用<strong>最终状态</strong>覆盖应用实例的状态。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</li><li><p>第 40 至 41 行 ：新增续租每分钟次数( <code>renewsLastMin</code> )。<code>com.netflix.eureka.util.MeasuredRate</code>，速度测量类，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 续租每分钟次数</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> MeasuredRate renewsLastMin;</div><div class="line"></div><div class="line"><span class="comment">// MeasuredRate.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasuredRate</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 上一个间隔次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前间隔次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong currentBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 间隔</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sampleInterval;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Timer timer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isActive;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeasuredRate</span><span class="params">(<span class="keyword">long</span> sampleInterval)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.sampleInterval = sampleInterval;</div><div class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"Eureka-MeasureRateTimer"</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">this</span>.isActive = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isActive) &#123;</div><div class="line">            timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">// Zero out the current bucket.</span></div><div class="line">                        lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                        logger.error(<span class="string">"Cannot reset the Measured Rate"</span>, e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, sampleInterval, sampleInterval);</div><div class="line"></div><div class="line">            isActive = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isActive) &#123;</div><div class="line">            timer.cancel();</div><div class="line">            isActive = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the count in the last sample interval.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastBucket.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Increments the count in the current sample interval.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        currentBucket.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>timer</code> ，定时器，负责每个 <code>sampleInterval</code> 间隔重置<strong>当前次数</strong>( <code>currentBucket</code> )，并将<strong>原当前次数</strong>设置到<strong>上一个次数</strong>( <code>lastBucket</code> )。</li><li><code>#increment()</code> 方法，返回<strong>当前次数</strong>( <code>currentBucket</code> )。</li><li><code>#getCount()</code> 方法，返回<strong>上一个次数</strong>( <code>lastBucket</code> )。</li><li><code>renewsLastMin</code> 有如下用途：<ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集<strong>续租每分钟次数</strong>。</li><li>Eureka-Server 运维界面的显示<strong>续租每分钟次数</strong>。</li><li>自我保护机制，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现 （四）之自我保护机制》</a> 详细解析。</li></ul></li></ul></li><li><p>第 42 至 43 行 ：调用 <code>Lease#renew()</code> 方法，设置租约最后更新时间( 续租 )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">    lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 44 行 ：返回续租成功( <code>true</code> )。</p></li><li><strong>整个过程修改的租约的过期时间，即使并发请求，也不会对数据的一致性产生不一致的影响，因此像注册操作一样加锁</strong>。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>效率比想象的低一些，加油继续更新下一篇。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-renew/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-renew/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（一）之注册</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-register/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-register/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2017-10-17T14:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/">http://www.iocoder.cn/Eureka/instance-registry-register/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2. Eureka-Client 发起注册</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.1 应用实例信息复制器</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.2 刷新应用实例信息</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.3 发起注册应用实例</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3. Eureka-Server 接收注册</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.1 接收注册请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.2 Lease</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.3 注册应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 注册应用实例的过程</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-Eureka-Client-发起注册"><a href="#2-Eureka-Client-发起注册" class="headerlink" title="2. Eureka-Client 发起注册"></a>2. Eureka-Client 发起注册</h1><p>Eureka-Client 向 Eureka-Server 发起注册应用实例需要符合如下条件：</p><ul><li>配置 <code>eureka.registration.enabled = true</code>，Eureka-Client 向 Eureka-Server 发起注册应用实例的<strong>开关</strong>。</li><li>InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致。</li></ul><p>每次 InstanceInfo 发生<strong>属性变化</strong>时，标记 <code>isInstanceInfoDirty</code> 属性为 <code>true</code>，表示 InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致，需要注册。另外，InstanceInfo 刚被创建时，在 Eureka-Server 不存在，也会被注册。</p><p>当符合条件时，InstanceInfo 不会立即向 Eureka-Server 注册，而是后台线程<strong>定时</strong>注册。</p><p>当 InstanceInfo 的状态( <code>status</code> ) 属性发生变化时，并且配置 <code>eureka.shouldOnDemandUpdateStatusChange = true</code> 时，立即向 Eureka-Server 注册。<strong>因为状态属性非常重要，一般情况下建议开启，当然默认情况也是开启的</strong>。</p><p>Let’s Go。让我们看看代码的实现。</p><h2 id="2-1-应用实例信息复制器"><a href="#2-1-应用实例信息复制器" class="headerlink" title="2.1 应用实例信息复制器"></a>2.1 应用实例信息复制器</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryClient</span> <span class="keyword">implements</span> <span class="title">EurekaClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ApplicationInfoManager.StatusChangeListener statusChangeListener;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息复制器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InstanceInfoReplicator instanceInfoReplicator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">        </div><div class="line">            <span class="comment">// ... 省略无关代码</span></div><div class="line">            </div><div class="line">            <span class="comment">// 创建 应用实例信息复制器</span></div><div class="line">            <span class="comment">// InstanceInfo replicator</span></div><div class="line">            instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    instanceInfo,</div><div class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</div><div class="line">                    <span class="number">2</span>); <span class="comment">// burstSize</span></div><div class="line"></div><div class="line">            <span class="comment">// 创建 应用实例状态变更监听器</span></div><div class="line">            statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</div><div class="line">                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</div><div class="line">                        <span class="comment">// log at warn level if DOWN was involved</span></div><div class="line">                        logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">                    &#125;</div><div class="line">                    instanceInfoReplicator.onDemandUpdate();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="comment">// 注册 应用实例状态变更监听器</span></div><div class="line">            <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</div><div class="line">                applicationInfoManager.registerStatusChangeListener(statusChangeListener);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 开启 应用实例信息复制器</span></div><div class="line">            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.discovery.InstanceInfoReplicator</code>，应用实例信息复制器。</p><ul><li><p>调用 <code>InstanceInfoReplicator#start(...)</code> 方法，<strong>开启</strong>应用实例信息复制器。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InstanceInfoReplicator.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo instanceInfo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行频率，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicationIntervalSeconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行任务的 Future</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Future&gt; scheduledPeriodicRef;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否开启调度</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean started;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter; <span class="comment">// 限流相关，跳过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> burstSize; <span class="comment">// 限流相关，跳过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> allowedRatePerMinute; <span class="comment">// 限流相关，跳过</span></div><div class="line"></div><div class="line">    InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, <span class="keyword">int</span> replicationIntervalSeconds, <span class="keyword">int</span> burstSize) &#123;</div><div class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</div><div class="line">        <span class="keyword">this</span>.instanceInfo = instanceInfo;</div><div class="line">        <span class="keyword">this</span>.scheduler = Executors.newScheduledThreadPool(<span class="number">1</span>,</div><div class="line">                <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                        .setNameFormat(<span class="string">"DiscoveryClient-InstanceInfoReplicator-%d"</span>)</div><div class="line">                        .setDaemon(<span class="keyword">true</span>)</div><div class="line">                        .build());</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.scheduledPeriodicRef = <span class="keyword">new</span> AtomicReference&lt;Future&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.started = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">this</span>.rateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">this</span>.replicationIntervalSeconds = replicationIntervalSeconds;</div><div class="line">        <span class="keyword">this</span>.burstSize = burstSize;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.allowedRatePerMinute = <span class="number">60</span> * <span class="keyword">this</span>.burstSize / <span class="keyword">this</span>.replicationIntervalSeconds;</div><div class="line">        logger.info(<span class="string">"InstanceInfoReplicator onDemand update allowed rate per min is &#123;&#125;"</span>, allowedRatePerMinute);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initialDelayMs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            <span class="comment">// 设置 应用实例信息 数据不一致</span></div><div class="line">            instanceInfo.setIsDirty();  <span class="comment">// for initial register</span></div><div class="line">            <span class="comment">// 提交任务，并设置该任务的 Future</span></div><div class="line">            Future next = scheduler.schedule(<span class="keyword">this</span>, initialDelayMs, TimeUnit.SECONDS);</div><div class="line">            scheduledPeriodicRef.set(next);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isInstanceInfoDirty = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Long lastDirtyTimestamp;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setIsDirty</span><span class="params">()</span> </span>&#123;</div><div class="line">   isInstanceInfoDirty = <span class="keyword">true</span>;</div><div class="line">   lastDirtyTimestamp = System.currentTimeMillis();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>执行 <code>instanceInfo.setIsDirty()</code> 代码块，因为 <strong>InstanceInfo 刚被创建时，在 Eureka-Server 不存在，也会被注册</strong>。</li><li>调用 <code>ScheduledExecutorService#schedule(...)</code> 方法，延迟 <code>initialDelayMs</code> 毫秒执行<strong>一次</strong>任务。为什么此处设置 <code>scheduledPeriodicRef</code> ？在 <code>InstanceInfoReplicator#onDemandUpdate()</code> 方法会看到具体用途。</li></ul></li><li><p><strong>定时</strong>检查 InstanceInfo 的状态( <code>status</code> ) 属性是否发生变化。<strong>若是</strong>，发起注册。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 刷新 应用实例信息</span></div><div class="line">       discoveryClient.refreshInstanceInfo();</div><div class="line">       <span class="comment">// 判断 应用实例信息 是否数据不一致</span></div><div class="line">       Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</div><div class="line">       <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">// 发起注册</span></div><div class="line">           discoveryClient.register();</div><div class="line">           <span class="comment">// 设置 应用实例信息 数据一致</span></div><div class="line">           instanceInfo.unsetIsDirty(dirtyTimestamp);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 提交任务，并设置该任务的 Future</span></div><div class="line">       Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">       scheduledPeriodicRef.set(next);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">setIsDirtyWithTime</span><span class="params">()</span> </span>&#123;</div><div class="line">   setIsDirty();</div><div class="line">   <span class="keyword">return</span> lastDirtyTimestamp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unsetIsDirty</span><span class="params">(<span class="keyword">long</span> unsetDirtyTimestamp)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (lastDirtyTimestamp &lt;= unsetDirtyTimestamp) &#123;</div><div class="line">       isInstanceInfoDirty = <span class="keyword">false</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>DiscoveryClient#refreshInstanceInfo()</code> 方法，刷新应用实例信息。<strong>此处可能导致应用实例信息数据不一致</strong>，在<a href="#">「2.2」刷新应用实例信息</a> 详细解析。</li><li>调用 <code>DiscoveryClient#register()</code> 方法，<strong>Eureka-Client 向 Eureka-Server 注册应用实例</strong>。</li><li>调用 <code>ScheduledExecutorService#schedule(...)</code> 方法，再次延迟执行任务，并设置 <code>scheduledPeriodicRef</code>。通过这样的方式，不断<strong>循环</strong>定时执行任务。</li></ul></li></ul></li><li><p><code>com.netflix.appinfo.ApplicationInfoManager.StatusChangeListener</code> <strong>内部类</strong>，监听应用实例信息状态的变更。</p><ul><li><p>调用 <code>ApplicationInfoManager#registerStatusChangeListener(...)</code> 方法，注册应用实例状态变更监听器。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfoManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, StatusChangeListener&gt; listeners;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStatusChangeListener</span><span class="params">(StatusChangeListener listener)</span> </span>&#123;</div><div class="line">        listeners.put(listener.getId(), listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><strong>业务里</strong>，调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法，设置应用实例信息的状态，从而<strong>通知</strong> <code>InstanceInfoReplicator#onDemandUpdate()</code> 方法的调用。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setInstanceStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</div><div class="line">   InstanceStatus next = instanceStatusMapper.map(status);</div><div class="line">   <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   InstanceStatus prev = instanceInfo.setStatus(next);</div><div class="line">   <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (StatusChangeListener listener : listeners.values()) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               listener.notify(<span class="keyword">new</span> StatusChangeEvent(prev, next));</div><div class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">               logger.warn(<span class="string">"failed to notify listener: &#123;&#125;"</span>, listener.getId(), e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InstanceStatus <span class="title">setStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.status != status) &#123;</div><div class="line">       InstanceStatus prev = <span class="keyword">this</span>.status;</div><div class="line">       <span class="keyword">this</span>.status = status;</div><div class="line">       <span class="comment">// 设置 应用实例信息 数据一致</span></div><div class="line">       setIsDirty();</div><div class="line">       <span class="keyword">return</span> prev;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>InstanceInfoReplicator#onDemandUpdate()</code>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDemandUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123; <span class="comment">// 限流相关，跳过</span></div><div class="line">       scheduler.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               logger.debug(<span class="string">"Executing on-demand update of local InstanceInfo"</span>);</div><div class="line">               <span class="comment">// 取消任务</span></div><div class="line">               Future latestPeriodic = scheduledPeriodicRef.get();</div><div class="line">               <span class="keyword">if</span> (latestPeriodic != <span class="keyword">null</span> &amp;&amp; !latestPeriodic.isDone()) &#123;</div><div class="line">                   logger.debug(<span class="string">"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update"</span>);</div><div class="line">                   latestPeriodic.cancel(<span class="keyword">false</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="comment">// 再次调用</span></div><div class="line">               InstanceInfoReplicator.<span class="keyword">this</span>.run();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.warn(<span class="string">"Ignoring onDemand update due to rate limiter"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>Future#cancel(false)</code> 方法，取消定时任务，<strong>避免无用的注册</strong>。</li><li>调用 <code>InstanceInfoReplicator#run()</code> 方法，发起注册。</li></ul></li></ul></li></ul><h2 id="2-2-刷新应用实例信息"><a href="#2-2-刷新应用实例信息" class="headerlink" title="2.2 刷新应用实例信息"></a>2.2 刷新应用实例信息</h2><p>调用 <code>DiscoveryClient#refreshInstanceInfo()</code> 方法，刷新应用实例信息。<strong>此处可能导致应用实例信息数据不一致</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshInstanceInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 刷新 数据中心信息</span></div><div class="line">   applicationInfoManager.refreshDataCenterInfoIfRequired();</div><div class="line">   <span class="comment">// 刷新 租约信息</span></div><div class="line">   applicationInfoManager.refreshLeaseInfoIfRequired();</div><div class="line">   <span class="comment">// 健康检查</span></div><div class="line">   InstanceStatus status;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       status = getHealthCheckHandler().getStatus(instanceInfo.getStatus());</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"Exception from healthcheckHandler.getStatus, setting status to DOWN"</span>, e);</div><div class="line">       status = InstanceStatus.DOWN;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</div><div class="line">       applicationInfoManager.setInstanceStatus(status);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>ApplicationInfoManager#refreshDataCenterInfoIfRequired()</code> 方法，刷新数据中心相关信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshDataCenterInfoIfRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// hostname</span></div><div class="line">   String existingAddress = instanceInfo.getHostName();</div><div class="line">   String newAddress;</div><div class="line">   <span class="keyword">if</span> (config <span class="keyword">instanceof</span> RefreshableInstanceConfig) &#123;</div><div class="line">       <span class="comment">// Refresh data center info, and return up to date address</span></div><div class="line">       newAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(<span class="keyword">true</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       newAddress = config.getHostName(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ip</span></div><div class="line">   String newIp = config.getIpAddress();</div><div class="line">   <span class="keyword">if</span> (newAddress != <span class="keyword">null</span> &amp;&amp; !newAddress.equals(existingAddress)) &#123;</div><div class="line">       logger.warn(<span class="string">"The address changed from : &#123;&#125; =&gt; &#123;&#125;"</span>, existingAddress, newAddress);</div><div class="line">       <span class="comment">// :( in the legacy code here the builder is acting as a mutator.</span></div><div class="line">       <span class="comment">// This is hard to fix as this same instanceInfo instance is referenced elsewhere.</span></div><div class="line">       <span class="comment">// We will most likely re-write the client at sometime so not fixing for now.</span></div><div class="line">       InstanceInfo.Builder builder = <span class="keyword">new</span> InstanceInfo.Builder(instanceInfo);</div><div class="line">       builder.setHostName(newAddress) <span class="comment">// hostname</span></div><div class="line">               .setIPAddr(newIp) <span class="comment">// ip</span></div><div class="line">               .setDataCenterInfo(config.getDataCenterInfo()); <span class="comment">// dataCenterInfo</span></div><div class="line">       instanceInfo.setIsDirty();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pair&lt;String, String&gt; hostInfo = getHostInfo();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">(<span class="keyword">boolean</span> refresh)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hostInfo.second();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hostInfo.first();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">getHostInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Pair&lt;String, String&gt; pair;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InetAddress localHost = InetAddress.getLocalHost();</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(localHost.getHostAddress(), localHost.getHostName());</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot get host info"</span>, e);</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(<span class="string">""</span>, <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pair;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>关注应用实例信息的 <code>hostName</code> 、 <code>ipAddr</code> 、 <code>dataCenterInfo</code> 属性的变化。 </li><li>一般情况下，我们使用的是非 RefreshableInstanceConfig 实现的配置类( 一般是 MyDataCenterInstanceConfig )，因为 <code>AbstractInstanceConfig.hostInfo</code> 是<strong>静态属性</strong>，<strong>即使本机修改了 IP 等信息，Eureka-Client 进程也不会感知到</strong>。TODO[0022]：看下springcloud 的实现</li></ul></li><li><p>调用 <code>ApplicationInfoManager#refreshLeaseInfoIfRequired()</code> 方法，刷新租约相关信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshLeaseInfoIfRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">   LeaseInfo leaseInfo = instanceInfo.getLeaseInfo();</div><div class="line">   <span class="keyword">if</span> (leaseInfo == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> currentLeaseDuration = config.getLeaseExpirationDurationInSeconds();</div><div class="line">   <span class="keyword">int</span> currentLeaseRenewal = config.getLeaseRenewalIntervalInSeconds();</div><div class="line">   <span class="keyword">if</span> (leaseInfo.getDurationInSecs() != currentLeaseDuration <span class="comment">// 租约过期时间 改变</span></div><div class="line">           || leaseInfo.getRenewalIntervalInSecs() != currentLeaseRenewal) &#123; <span class="comment">// 租约续约频率 改变</span></div><div class="line">       LeaseInfo newLeaseInfo = LeaseInfo.Builder.newBuilder()</div><div class="line">               .setRenewalIntervalInSecs(currentLeaseRenewal)</div><div class="line">               .setDurationInSecs(currentLeaseDuration)</div><div class="line">               .build();</div><div class="line">       instanceInfo.setLeaseInfo(newLeaseInfo);</div><div class="line">       instanceInfo.setIsDirty();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>关注应用实例信息的 <code>renewalIntervalInSecs</code> 、 <code>durationInSecs</code> 属性的变化。</li></ul></li><li><p>调用 <code>HealthCheckHandler#getStatus()</code> 方法，健康检查。这里先暂时跳过，我们在<a href="#">TODO[0004]：健康检查</a> 详细解析。</p></li></ul><h2 id="2-3-发起注册应用实例"><a href="#2-3-发起注册应用实例" class="headerlink" title="2.3 发起注册应用实例"></a>2.3 发起注册应用实例</h2><p>调用 <code>DiscoveryClient#register()</code> 方法，<strong>Eureka-Client 向 Eureka-Server 注册应用实例</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   logger.info(PREFIX + appPathIdentifier + <span class="string">": registering service..."</span>);</div><div class="line">   EurekaHttpResponse&lt;Void&gt; httpResponse;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, PREFIX + appPathIdentifier, e.getMessage(), e);</div><div class="line">       <span class="keyword">throw</span> e;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">       logger.info(<span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</div><div class="line">   String urlPath = <span class="string">"apps/"</span> + info.getAppName();</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line">       addExtraHeaders(resourceBuilder);</div><div class="line">       response = resourceBuilder</div><div class="line">               .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</div><div class="line">               .type(MediaType.APPLICATION_JSON_TYPE)</div><div class="line">               .accept(MediaType.APPLICATION_JSON)</div><div class="line">               .post(ClientResponse.class, info);</div><div class="line">       <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</div><div class="line">                   response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#register(...)</code> 方法，<code>POST</code> 请求 Eureka-Server 的 <code>apps/${APP_NAME}</code> 接口，参数为 InstanceInfo ，实现注册实例信息的注册。</li></ul><h1 id="3-Eureka-Server-接收注册"><a href="#3-Eureka-Server-接收注册" class="headerlink" title="3. Eureka-Server 接收注册"></a>3. Eureka-Server 接收注册</h1><h2 id="3-1-接收注册请求"><a href="#3-1-接收注册请求" class="headerlink" title="3.1 接收注册请求"></a>3.1 接收注册请求</h2><p><code>com.netflix.eureka.resources.ApplicationResource</code>，处理<strong>单个</strong>应用的请求操作的 Resource ( Controller )。</p><p>注册应用实例信息的请求，映射 <code>ApplicationResource#addInstance()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@POST</span></div><div class="line">    <span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></div><div class="line"><span class="function"><span class="params">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</div><div class="line">        <span class="comment">// 校验参数是否合法</span></div><div class="line">        logger.debug(<span class="string">"Registering instance &#123;&#125; (replication=&#123;&#125;)"</span>, info.getId(), isReplication);</div><div class="line">        <span class="comment">// validate that the instanceinfo contains all the necessary required fields</span></div><div class="line">        <span class="keyword">if</span> (isBlank(info.getId())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing instanceId"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getHostName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing hostname"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getIPAddr())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing ip address"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getAppName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing appName"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!appName.equals(info.getAppName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Mismatched appName, expecting "</span> + appName + <span class="string">" but was "</span> + info.getAppName()).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo().getName() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo Name"</span>).build();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// AWS 相关，跳过</span></div><div class="line">        <span class="comment">// handle cases where clients may be registering with bad DataCenterInfo with missing data</span></div><div class="line">        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</div><div class="line">        <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</div><div class="line">            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();</div><div class="line">            <span class="keyword">if</span> (isBlank(dataCenterInfoId)) &#123;</div><div class="line">                <span class="keyword">boolean</span> experimental = <span class="string">"true"</span>.equalsIgnoreCase(serverConfig.getExperimental(<span class="string">"registration.validation.dataCenterInfoId"</span>));</div><div class="line">                <span class="keyword">if</span> (experimental) &#123;</div><div class="line">                    String entity = <span class="string">"DataCenterInfo of type "</span> + dataCenterInfo.getClass() + <span class="string">" must contain a valid id"</span>;</div><div class="line">                    <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(entity).build();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> AmazonInfo) &#123;</div><div class="line">                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;</div><div class="line">                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);</div><div class="line">                    <span class="keyword">if</span> (effectiveId == <span class="keyword">null</span>) &#123;</div><div class="line">                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    logger.warn(<span class="string">"Registering DataCenterInfo of type &#123;&#125; without an appropriate id"</span>, dataCenterInfo.getClass());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 注册应用实例信息</span></div><div class="line">        registry.register(info, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">        <span class="comment">// 返回 204 成功</span></div><div class="line">        <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>请求头 <code>isReplication</code> 参数，和 Eureka-Server 集群复制相关，暂时跳过。</li><li><p>调用 <code>PeerAwareInstanceRegistryImpl#register(...)</code> 方法，注册应用实例信息。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#register(...)</code> 方法，注册应用实例信息。</li></ul></li></ul><h2 id="3-2-Lease"><a href="#3-2-Lease" class="headerlink" title="3.2 Lease"></a>3.2 Lease</h2><p>在看具体的注册应用实例信息的逻辑之前，我们先来看下 <code>com.netflix.eureka.lease.Lease</code>，租约。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lease</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> T holder;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 注册时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> registrationTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始服务时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serviceUpTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消注册时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> evictionTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后更新时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">// Make it volatile so that the expiration task would see this quicker</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastUpdateTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 租约持续时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</div><div class="line">        holder = r;</div><div class="line">        registrationTimestamp = System.currentTimeMillis();</div><div class="line">        lastUpdateTimestamp = registrationTimestamp;</div><div class="line">        duration = (durationInSecs * <span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>holder</code> 属性，租约的持有者。在 Eureka-Server 里，暂时只有 InstanceInfo 使用。</li><li><code>registrationTimestamp</code> 属性，注册( 创建 )租约时间戳。在<strong>构造方法</strong>里可以看租约对象的创建时间戳即为注册租约时间戳。</li><li><p><code>serviceUpTimestamp</code> 属性，开始服务时间戳。注册应用实例信息会使用到它如下两个方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceUp</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (serviceUpTimestamp == <span class="number">0</span>) &#123; <span class="comment">// 第一次有效</span></div><div class="line">       serviceUpTimestamp = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceUpTimestamp</span><span class="params">(<span class="keyword">long</span> serviceUpTimestamp)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.serviceUpTimestamp = serviceUpTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>lastUpdatedTimestamp</code> 属性，最后更新租约时间戳。每次续租时，更新该时间戳。注册应用实例信息会使用到它如下方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdatedTimestamp</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.lastUpdatedTimestamp = System.currentTimeMillis();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>duration</code> 属性，租约持续时间，单位：毫秒。当租约过久未续租，即当前时间 - <code>lastUpdatedTimestamp</code> &gt; <code>duration</code> 时，租约过期。</p></li><li><code>evictionTimestamp</code> 属性，租约过期时间戳。</li></ul><h2 id="3-3-注册应用实例信息"><a href="#3-3-注册应用实例信息" class="headerlink" title="3.3 注册应用实例信息"></a>3.3 注册应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#register(...)</code> 方法，注册应用实例信息，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// TODO 为什么是读锁</span></div><div class="line"> <span class="number">4</span>:         read.lock();</div><div class="line"> <span class="number">5</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 增加 注册次数 到 监控</span></div><div class="line"> <span class="number">7</span>:         REGISTER.increment(isReplication);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 获得 应用实例信息 对应的 租约</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</div><div class="line"><span class="number">11</span>:             gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); <span class="comment">// 添加 应用</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123; <span class="comment">// 添加 应用 成功</span></div><div class="line"><span class="number">13</span>:                 gMap = gNewMap;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</div><div class="line"><span class="number">17</span>:         <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123; <span class="comment">// 已存在时，使用数据不一致的时间大的应用注册信息为有效的</span></div><div class="line"><span class="number">19</span>:             Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp(); <span class="comment">// Server 注册的 InstanceInfo</span></div><div class="line"><span class="number">20</span>:             Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp(); <span class="comment">// Client 请求的 InstanceInfo</span></div><div class="line"><span class="number">21</span>:             logger.debug(<span class="string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:             <span class="comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span></div><div class="line"><span class="number">24</span>:             <span class="comment">// InstanceInfo instead of the server local copy.</span></div><div class="line"><span class="number">25</span>:             <span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</div><div class="line"><span class="number">26</span>:                 logger.warn(<span class="string">"There is an existing lease and the existing lease's dirty timestamp &#123;&#125; is greater"</span> +</div><div class="line"><span class="number">27</span>:                         <span class="string">" than the one that is being registered &#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</div><div class="line"><span class="number">28</span>:                 logger.warn(<span class="string">"Using the existing instanceInfo instead of the new instanceInfo as the registrant"</span>);</div><div class="line"><span class="number">29</span>:                 registrant = existingLease.getHolder();</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">32</span>:             <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line"><span class="number">33</span>:             <span class="comment">// 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"><span class="number">34</span>:             <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:                     <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></div><div class="line"><span class="number">37</span>:                     <span class="comment">// (1</span></div><div class="line"><span class="number">38</span>:                     <span class="comment">// for 30 seconds, 2 for a minute)</span></div><div class="line"><span class="number">39</span>:                     <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</div><div class="line"><span class="number">40</span>:                     <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line"><span class="number">41</span>:                             (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">42</span>:                 &#125;</div><div class="line"><span class="number">43</span>:             &#125;</div><div class="line"><span class="number">44</span>:             logger.debug(<span class="string">"No previous lease information found; it is new registration"</span>);</div><div class="line"><span class="number">45</span>:         &#125;</div><div class="line"><span class="number">46</span>:         <span class="comment">// 创建 租约</span></div><div class="line"><span class="number">47</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</div><div class="line"><span class="number">48</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123; <span class="comment">// 若租约已存在，设置 租约的开始服务的时间戳</span></div><div class="line"><span class="number">49</span>:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</div><div class="line"><span class="number">50</span>:         &#125;</div><div class="line"><span class="number">51</span>:         <span class="comment">// 添加到 租约映射</span></div><div class="line"><span class="number">52</span>:         gMap.put(registrant.getId(), lease);</div><div class="line"><span class="number">53</span>:         <span class="comment">// 添加到 最近注册的调试队列</span></div><div class="line"><span class="number">54</span>:         <span class="keyword">synchronized</span> (recentRegisteredQueue) &#123;</div><div class="line"><span class="number">55</span>:             recentRegisteredQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(</div><div class="line"><span class="number">56</span>:                     System.currentTimeMillis(),</div><div class="line"><span class="number">57</span>:                     registrant.getAppName() + <span class="string">"("</span> + registrant.getId() + <span class="string">")"</span>));</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:         <span class="comment">// 添加到 应用实例覆盖状态映射（Eureka-Server 初始化使用）</span></div><div class="line"><span class="number">60</span>:         <span class="comment">// This is where the initial state transfer of overridden status happens</span></div><div class="line"><span class="number">61</span>:         <span class="keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</div><div class="line"><span class="number">62</span>:             logger.debug(<span class="string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span></div><div class="line"><span class="number">63</span>:                             + <span class="string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());</div><div class="line"><span class="number">64</span>:             <span class="keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</div><div class="line"><span class="number">65</span>:                 logger.info(<span class="string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());</div><div class="line"><span class="number">66</span>:                 overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</div><div class="line"><span class="number">67</span>:             &#125;</div><div class="line"><span class="number">68</span>:         &#125;</div><div class="line"><span class="number">69</span>:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</div><div class="line"><span class="number">70</span>:         <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">71</span>:             logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</div><div class="line"><span class="number">72</span>:             registrant.setOverriddenStatus(overriddenStatusFromMap);</div><div class="line"><span class="number">73</span>:         &#125;</div><div class="line"><span class="number">74</span>: </div><div class="line"><span class="number">75</span>:         <span class="comment">// 获得应用实例最终状态，并设置应用实例的状态</span></div><div class="line"><span class="number">76</span>:         <span class="comment">// Set the status based on the overridden status rules</span></div><div class="line"><span class="number">77</span>:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</div><div class="line"><span class="number">78</span>:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"><span class="number">79</span>: </div><div class="line"><span class="number">80</span>:         <span class="comment">// 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"><span class="number">81</span>:         <span class="comment">// If the lease is registered with UP status, set lease service up timestamp</span></div><div class="line"><span class="number">82</span>:         <span class="keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</div><div class="line"><span class="number">83</span>:             lease.serviceUp();</div><div class="line"><span class="number">84</span>:         &#125;</div><div class="line"><span class="number">85</span>:         <span class="comment">// 设置 应用实例信息的操作类型 为 添加</span></div><div class="line"><span class="number">86</span>:         registrant.setActionType(ActionType.ADDED);</div><div class="line"><span class="number">87</span>:         <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">88</span>:         recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">89</span>:         <span class="comment">// 设置 租约的最后更新时间戳</span></div><div class="line"><span class="number">90</span>:         registrant.setLastUpdatedTimestamp();</div><div class="line"><span class="number">91</span>:         <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">92</span>:         invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</div><div class="line"><span class="number">93</span>:         logger.info(<span class="string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,</div><div class="line"><span class="number">94</span>:                 registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</div><div class="line"><span class="number">95</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">96</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">97</span>:         read.unlock();</div><div class="line"><span class="number">98</span>:     &#125;</div><div class="line"><span class="number">99</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 行 ：添加到应用实例覆盖状态映射，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 详细解析。</li><li>第 6 至 7 行 ：增加注册次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li><p>第 5 至 16 行 ：获得应用实例信息对应的<strong>租约</strong>。<code>registry</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 租约映射</span></div><div class="line"><span class="comment"> * key1 ：应用名 &#123;<span class="doctag">@link</span> InstanceInfo#appName&#125;</span></div><div class="line"><span class="comment"> * key2 ：应用实例信息编号 &#123;<span class="doctag">@link</span> InstanceInfo#instanceId&#125;</span></div><div class="line"><span class="comment"> * value ：租约</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</div></pre></td></tr></table></figure></li><li><p>第 17 至 30 行 ：当租约<strong>已存在</strong>，判断 Server 已存在的 InstanceInfo 的 <code>lastDirtyTimestamp</code> 是否<strong>大于</strong>( 不包括等于 ) Client 请求的 InstanceInfo ，<strong>若是，使用 Server 的 InstanceInfo 进行替代</strong>。</p></li><li>第 31 至 44 行 ：增加 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code>，自我保护机制相关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</li><li>第 45 至 52 行 ：创建租约，并添加到租约映射( <code>registry</code> )。</li><li><p>第 53 至 58 行 ：添加到最近注册的<strong>调试</strong>队列( <code>recentRegisteredQueue</code> )，用于 Eureka-Server 运维界面的显示，无实际业务逻辑使用。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近注册的调试队列</span></div><div class="line"><span class="comment">* key ：添加时的时间戳</span></div><div class="line"><span class="comment">* value ：字符串 = 应用名(应用实例信息编号)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt; recentRegisteredQueue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 循环队列</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;E&gt; 泛型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 队列大小</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.size = size;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.makeSpaceIfNotAvailable();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 保证空间足够</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * 当空间不够时，移除首元素</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeSpaceIfNotAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.size() == size) &#123;</div><div class="line">           <span class="keyword">this</span>.remove();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.makeSpaceIfNotAvailable();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.offer(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 59 至 68 行 ：添加到应用实例覆盖状态映射，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 详细解析。</p></li><li>第 69 至 73 行 ：设置应用实例的覆盖状态( <code>overridestatus</code> )，避免注册应用实例后，丢失覆盖状态。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</li><li>第 75 至 78 行 ： <strong>获得应用实例最终状态</strong>，并设置应用实例的状态。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</li><li>第 80 至 84 行 ：设置租约的开始服务的时间戳( <strong>只有第一次有效</strong> )。</li><li><p>第 85 至 88 行 ：设置应用实例信息的<strong>操作类型为添加</strong>，并添加到最近租约变更记录队列( <code>recentlyChangedQueue</code> )。<code>recentlyChangedQueue</code> 用于注册信息的<strong>增量</strong>获取，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self">《应用实例注册发现 （七）之增量获取》</a>详细解析。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div></pre></td></tr></table></figure></li><li><p>第 89 至 90 行 ：设置租约的最后更新时间戳。</p></li><li>第 91 至 92 行 ：设置响应缓存( ResponseCache )过期，在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a>详细解析。</li><li>第 96 至 97 行 ：释放锁。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>嘿嘿，蛮嗨的，比起前面几篇写配置相关的文章来说。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-register/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-register/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 注册表 InstanceRegistry 类关系</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-class-diagram/</id>
    <published>2018-05-20T16:00:00.000Z</published>
    <updated>2017-10-12T05:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/">http://www.iocoder.cn/Eureka/instance-registry-class-diagram/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">2. 类图</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">3. LookupService</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">4. LeaseManager</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">5. InstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">6. AbstractInstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">7. PeerAwareInstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">8. PeerAwareInstanceRegistryImpl</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">666. 彩蛋</a></li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要简介 <strong>注册表 InstanceRegistry 的类关系</strong>，为后文的<strong>应用实例注册发现</strong>、<strong>Eureka-Server 集群复制</strong>做整体的铺垫。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-类图"><a href="#2-类图" class="headerlink" title="2. 类图"></a>2. 类图</h1><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_21/01.png" alt=""></p><ul><li><code>com.netflix.eureka.registry.AwsInstanceRegistry</code>，主要用于亚马逊 AWS，跳过。</li><li><code>com.netflix.eureka.registry.RemoteRegionRegistry</code>，笔者暂时不太理解它的用途。目前猜测 Eureka-Server 集群和集群之间的注册信息的交互方式。查阅官方资料，<a href="https://github.com/Netflix/eureka/issues/29" rel="external nofollow noopener noreferrer" target="_blank">《Add ability to retrieve instances from any remote region》</a> 在做了简单介绍。翻看目前网络上的博客、书籍、项目实战，暂时都没提及此块。估摸和亚马逊 AWS 跨区域( <code>region</code> ) 机制有一定关系，先暂时跳过。有了解此块的同学，麻烦告知下笔者，万分感谢。TODO[0009]：RemoteRegionRegistry。</li><li><strong>蓝框</strong>部分，本文主角。</li></ul><h1 id="3-LookupService"><a href="#3-LookupService" class="headerlink" title="3. LookupService"></a>3. LookupService</h1><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.shared.LookupService</code></a>，查找服务<strong>接口</strong>，提供<strong>简单单一</strong>的方式获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_29/01.png" alt=""></p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h1 id="4-LeaseManager"><a href="#4-LeaseManager" class="headerlink" title="4. LeaseManager"></a>4. LeaseManager</h1><p><code>com.netflix.eureka.lease.LeaseManager</code>，租约管理器<strong>接口</strong>，提供租约的注册、续租、取消( 主动下线 )、过期( 过期下线 )。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaseManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T r, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="5-InstanceRegistry"><a href="#5-InstanceRegistry" class="headerlink" title="5. InstanceRegistry"></a>5. InstanceRegistry</h1><p><code>com.netflix.eureka.registry.InstanceRegistry</code>，<strong>应用实例</strong>注册表<strong>接口</strong>。它继承了 LookupService 、LeaseManager 接口，提供应用实例的<strong>注册</strong>与<strong>发现</strong>服务。另外，它结合实际业务场景，定义了<strong>更加丰富</strong>的接口方法。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title">LeaseManager</span>&lt;<span class="title">InstanceInfo</span>&gt;, <span class="title">LookupService</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 开启与关闭相关 ======</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 应用实例状态变更相关 ======</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">storeOverriddenStatusIfRequired</span><span class="params">(String appName, String id, InstanceStatus overriddenStatus)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(String appName, String id, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                         String lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                 String lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Map&lt;String, InstanceStatus&gt; <span class="title">overriddenInstanceStatusesSnapshot</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 响应缓存相关 ======</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializedResponseCache</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ResponseCache <span class="title">getResponseCache</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ====== 自我保护模式相关 ======</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNumOfRenewsInLastMin</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumOfRenewsPerMinThreshold</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isBelowRenewThresold</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSelfPreservationModeEnabled</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ====== 调试/监控相关 ======</span></div><div class="line">    List&lt;Pair&lt;Long, String&gt;&gt; getLastNRegisteredInstances();</div><div class="line"></div><div class="line">    List&lt;Pair&lt;Long, String&gt;&gt; getLastNCanceledInstances();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="6-AbstractInstanceRegistry"><a href="#6-AbstractInstanceRegistry" class="headerlink" title="6. AbstractInstanceRegistry"></a>6. AbstractInstanceRegistry</h1><p><code>com.netflix.eureka.registry.AbstractInstanceRegistry</code>，应用对象注册表<strong>抽象实现</strong>。</p><p>这里先不拓展开，<a href="http://www.iocoder.cn/categories/Eureka/?self">《Eureka 源码解析 —— 应用实例注册发现》系列</a> 逐篇分享。</p><h1 id="7-PeerAwareInstanceRegistry"><a href="#7-PeerAwareInstanceRegistry" class="headerlink" title="7. PeerAwareInstanceRegistry"></a>7. PeerAwareInstanceRegistry</h1><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistry</code>，PeerAware ( 暂时找不到合适的翻译 ) 应用对象注册表<strong>接口</strong>，提供 Eureka-Server 集群内注册信息的<strong>同步</strong>服务。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PeerAwareInstanceRegistry</span> <span class="keyword">extends</span> <span class="title">InstanceRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PeerEurekaNodes peerEurekaNodes)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo info, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> String asgName, <span class="keyword">final</span> ASGResource.ASGStatus newStatus, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="8-PeerAwareInstanceRegistryImpl"><a href="#8-PeerAwareInstanceRegistryImpl" class="headerlink" title="8. PeerAwareInstanceRegistryImpl"></a>8. PeerAwareInstanceRegistryImpl</h1><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl</code>，PeerAware ( 暂时找不到合适的翻译 ) 应用对象注册表<strong>实现类</strong>。</p><p>这里先不拓展开，<a href="http://www.iocoder.cn/categories/Eureka/?self">《Eureka 源码解析 —— Eureka-Server 集群》系列</a> 逐篇分享。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文是一篇<strong>简介</strong>( 啪啪啪，打脸 )，如果胖友比较着急想了解原理，可以阅读 <a href="http://techshow.ctrip.com/archives/1699.html?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">携程 ——《深度剖析服务发现组件Netflix Eureka》</a> 先，写的非常非常非常不错。</p><p>快马加鞭，更新 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》</a> <strong>ing</strong> …</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-class-diagram/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-class-dia
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 启动（二）之 EurekaBootStrap</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-server-init-second/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-server-init-second/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2017-10-12T05:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">http://www.iocoder.cn/Eureka/eureka-server-init-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">2. EurekaBootStrap</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">2.1 初始化 Eureka-Server 配置环境</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">2.2 初始化 Eureka-Server 上下文</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3. Filter</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.1 StatusFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.2 ServerRequestAuthFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.3 RateLimitingFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.4 GzipEncodingEnforcingFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.5 ServletContainer</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">《Eureka 源码解析 —— Eureka-Server 启动（一）之 EurekaServerConfig》</a>，主要分享 <strong>Eureka-Server 启动的过程</strong>的第二部分 —— <strong>EurekaBootStrap</strong>。</p><p>考虑到整个初始化的过程中涉及的代码特别多，拆分成两两篇文章：</p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">ServerConfig</a></li><li>【本文】EurekaBootStrap</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaBootStrap"><a href="#2-EurekaBootStrap" class="headerlink" title="2. EurekaBootStrap"></a>2. EurekaBootStrap</h1><p><code>com.netflix.eureka.EurekaBootStrap</code>，Eureka-Server <strong>启动入口</strong>。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/01.png" alt=""></p><p>EurekaBootStrap 实现了 <code>javax.servlet.ServletContextListener</code> <strong>接口</strong>，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 <code>#contextInitialized()</code> 方法，初始化 Eureka-Server，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 省略无关变量和方法</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 初始化 Eureka-Server 配置环境</span></div><div class="line">            initEurekaEnvironment();</div><div class="line"></div><div class="line">            <span class="comment">// 初始化 Eureka-Server 上下文</span></div><div class="line">            initEurekaServerContext();</div><div class="line"></div><div class="line">            ServletContext sc = event.getServletContext();</div><div class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#initEurekaEnvironment()</code> 方法，初始化 Eureka-Server <strong>配置</strong>环境。</li><li>调用 <code>#initEurekaServerContext()</code> 方法，初始化 Eureka-Server 上下文。</li></ul><h2 id="2-1-初始化-Eureka-Server-配置环境"><a href="#2-1-初始化-Eureka-Server-配置环境" class="headerlink" title="2.1 初始化 Eureka-Server 配置环境"></a>2.1 初始化 Eureka-Server 配置环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaBootStrap.java</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署环境 - 测服</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署数据中心 - CLOUD</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOUD = <span class="string">"cloud"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署数据中心 - 默认</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT = <span class="string">"default"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_DATACENTER = <span class="string">"archaius.deployment.datacenter"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_DATACENTER = <span class="string">"eureka.datacenter"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    logger.info(<span class="string">"Setting the eureka configuration.."</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 设置配置文件的数据中心</span></div><div class="line">   String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);</div><div class="line">   <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</div><div class="line">       logger.info(<span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 设置配置文件的环境</span></div><div class="line">   String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);</div><div class="line">   <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</div><div class="line">       logger.info(<span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>设置基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius</a> 实现的配置文件的上下文，从而读取<strong>合适</strong>的配置文件。大多数情况下，只需要设置 <code>EUREKA_ENVIRONMENT</code> 即可，不同的服务器环境( 例如，<code>PROD</code> / <code>TEST</code> 等) 读取不同的配置文件。实现原理，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>有详细解析。</li><li>感兴趣的也可以阅读：<a href="https://github.com/Netflix/archaius/wiki/Deployment-context" rel="external nofollow noopener noreferrer" target="_blank">《Netflix Archaius 官方文档 —— Deployment context》</a>。</li></ul><h2 id="2-2-初始化-Eureka-Server-上下文"><a href="#2-2-初始化-Eureka-Server-上下文" class="headerlink" title="2.2 初始化 Eureka-Server 上下文"></a>2.2 初始化 Eureka-Server 上下文</h2><p>EurekaBootStrap 的 <code>#initEurekaServerContext()</code> 方法的实现代码相对较多，已经将代码<strong>切块</strong> + <strong>中文注册</strong>，点击 <a href="https://github.com/YunaiV/eureka/blob/a1c6074fd038f1182132a43b1ebc4cc08166f0be/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L137" rel="external nofollow noopener noreferrer" target="_blank">EurekaBootStrap</a> 链接，对照下面每个小结阅读理解。</p><h3 id="2-2-1-创建-Eureka-Server-配置"><a href="#2-2-1-创建-Eureka-Server-配置" class="headerlink" title="2.2.1 创建 Eureka-Server 配置"></a>2.2.1 创建 Eureka-Server 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</div></pre></td></tr></table></figure><ul><li>在 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">《Eureka 源码解析 —— Eureka-Server 启动（一）之 ServerConfig》「2.3 DefaultEurekaServerConfig」</a> 有详细解析。</li></ul><h3 id="2-2-2-Eureka-Server-请求和响应的数据兼容"><a href="#2-2-2-Eureka-Server-请求和响应的数据兼容" class="headerlink" title="2.2.2 Eureka-Server 请求和响应的数据兼容"></a>2.2.2 Eureka-Server 请求和响应的数据兼容</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// For backward compatibility</span></div><div class="line">JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div><div class="line">XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div></pre></td></tr></table></figure><ul><li>目前 Eureka-Server 提供 V2 版本 API ，如上代码主要对 V1 版本 API 做兼容。可以选择跳过。</li></ul><h3 id="2-2-3-创建-Eureka-Server-请求和响应编解码器"><a href="#2-2-3-创建-Eureka-Server-请求和响应编解码器" class="headerlink" title="2.2.3 创建 Eureka-Server 请求和响应编解码器"></a>2.2.3 创建 Eureka-Server 请求和响应编解码器</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">logger.info(<span class="string">"Initializing the eureka client..."</span>);</div><div class="line">logger.info(eurekaServerConfig.getJsonCodecName());</div><div class="line">ServerCodecs serverCodecs = <span class="keyword">new</span> DefaultServerCodecs(eurekaServerConfig);</div></pre></td></tr></table></figure><h3 id="2-2-4-创建-Eureka-Client"><a href="#2-2-4-创建-Eureka-Client" class="headerlink" title="2.2.4 创建 Eureka-Client"></a>2.2.4 创建 Eureka-Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ApplicationInfoManager applicationInfoManager;</div><div class="line"><span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</div><div class="line">  EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</div><div class="line">          ? <span class="keyword">new</span> CloudInstanceConfig()</div><div class="line">          : <span class="keyword">new</span> MyDataCenterInstanceConfig();</div><div class="line">  </div><div class="line">  applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</div><div class="line">          instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</div><div class="line">  </div><div class="line">  EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</div><div class="line">  eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  applicationInfoManager = eurekaClient.getApplicationInfoManager();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Eureka-Server 内嵌 Eureka-Client，用于和 Eureka-Server 集群里其他节点通信交互。</li><li>Eureka-Client 的初始化过程，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">《Eureka 源码解析 —— Eureka-Client 初始化（三）之 EurekaClient》「3. DiscoveryClient」</a>有详细解析。</li><li><p>Eureka-Client 也可以通过 EurekaBootStrap 构造方法传递，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> EurekaClient eurekaClient;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EurekaBootStrap</span><span class="params">(EurekaClient eurekaClient)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.eurekaClient = eurekaClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>大多数情况下用不到</strong>。</li></ul></li></ul><h3 id="2-2-5-创建应用实例信息的注册表"><a href="#2-2-5-创建应用实例信息的注册表" class="headerlink" title="2.2.5 创建应用实例信息的注册表"></a>2.2.5 创建应用实例信息的注册表</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PeerAwareInstanceRegistry registry;</div><div class="line"><span class="keyword">if</span> (isAws(applicationInfoManager.getInfo())) &#123; <span class="comment">// AWS 相关，跳过</span></div><div class="line">  registry = <span class="keyword">new</span> AwsInstanceRegistry(</div><div class="line">          eurekaServerConfig,</div><div class="line">          eurekaClient.getEurekaClientConfig(),</div><div class="line">          serverCodecs,</div><div class="line">          eurekaClient</div><div class="line">  );</div><div class="line">  awsBinder = <span class="keyword">new</span> AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);</div><div class="line">  awsBinder.start();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</div><div class="line">          eurekaServerConfig,</div><div class="line">          eurekaClient.getEurekaClientConfig(),</div><div class="line">          serverCodecs,</div><div class="line">          eurekaClient</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>应用实例信息的注册表<strong>类关系图</strong>如下：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_05_14/02.png" alt=""></p></li><li><p>本文不展开分享，在<a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?self">《Eureka 源码解析 —— 注册表 InstanceRegistry 类关系》</a>详细解析。</p></li></ul><h3 id="2-2-6-创建-Eureka-Server-集群节点集合"><a href="#2-2-6-创建-Eureka-Server-集群节点集合" class="headerlink" title="2.2.6 创建 Eureka-Server 集群节点集合"></a>2.2.6 创建 Eureka-Server 集群节点集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</div><div class="line">      registry,</div><div class="line">      eurekaServerConfig,</div><div class="line">      eurekaClient.getEurekaClientConfig(),</div><div class="line">      serverCodecs,</div><div class="line">      applicationInfoManager</div><div class="line">);</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.cluster.PeerEurekaNodes</code>，Eureka-Server 集群节点集合，在<a href="#">《TODO[0019]：集群初始化》</a>详细解析。</li></ul><h3 id="2-2-7-创建-Eureka-Server-上下文"><a href="#2-2-7-创建-Eureka-Server-上下文" class="headerlink" title="2.2.7 创建 Eureka-Server 上下文"></a>2.2.7 创建 Eureka-Server 上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</div><div class="line">      eurekaServerConfig,</div><div class="line">      serverCodecs,</div><div class="line">      registry,</div><div class="line">      peerEurekaNodes,</div><div class="line">      applicationInfoManager</div><div class="line">);</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.EurekaServerContext</code>，Eureka-Server 上下文<strong>接口</strong>，提供Eureka-Server 内部各组件对象的<strong>初始化</strong>、<strong>关闭</strong>、<strong>获取</strong>等方法。</li><li><p><code>com.netflix.eureka.EurekaServerContext.DefaultEurekaServerContext</code>，Eureka-Server 上下文<strong>实现类</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerContext</span> <span class="keyword">implements</span> <span class="title">EurekaServerContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 请求和响应编解码器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息的注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerEurekaNodes peerEurekaNodes;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-8-初始化-EurekaServerContextHolder"><a href="#2-2-8-初始化-EurekaServerContextHolder" class="headerlink" title="2.2.8 初始化 EurekaServerContextHolder"></a>2.2.8 初始化 EurekaServerContextHolder</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EurekaServerContextHolder.initialize(serverContext);</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.eureka.EurekaServerContextHolder</code>，Eureka-Server 上下文持有者。通过它，可以很方便的获取到 Eureka-Server 上下文，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerContextHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 持有者</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EurekaServerContextHolder holder;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerContext serverContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaServerContextHolder</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serverContext = serverContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">getServerContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serverContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> serverContext Eureka-Server 上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</div><div class="line">        holder = <span class="keyword">new</span> EurekaServerContextHolder(serverContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaServerContextHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> holder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-9-初始化-Eureka-Server-上下文"><a href="#2-2-9-初始化-Eureka-Server-上下文" class="headerlink" title="2.2.9 初始化 Eureka-Server 上下文"></a>2.2.9 初始化 Eureka-Server 上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverContext.initialize();</div><div class="line">logger.info(<span class="string">"Initialized server context"</span>);</div></pre></td></tr></table></figure><ul><li><p>调用 <code>ServerContext#initialize()</code> 方法，初始化 Eureka-Server 上下文，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DefaultEurekaServerContext.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   logger.info(<span class="string">"Initializing ..."</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 启动 Eureka-Server 集群节点集合（复制）</span></div><div class="line">   peerEurekaNodes.start();</div><div class="line">   <span class="comment">// 初始化 应用实例信息的注册表</span></div><div class="line">   registry.init(peerEurekaNodes);</div><div class="line"></div><div class="line">   logger.info(<span class="string">"Initialized"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-10-从其他-Eureka-Server-拉取注册信息"><a href="#2-2-10-从其他-Eureka-Server-拉取注册信息" class="headerlink" title="2.2.10 从其他 Eureka-Server 拉取注册信息"></a>2.2.10 从其他 Eureka-Server 拉取注册信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Copy registry from neighboring eureka node</span></div><div class="line"><span class="keyword">int</span> registryCount = registry.syncUp();</div><div class="line">registry.openForTraffic(applicationInfoManager, registryCount);</div></pre></td></tr></table></figure><ul><li>本文不展开分享，在<a href="#">《TODO[0019]：集群初始化》</a>详细解析。</li></ul><h3 id="2-2-11-注册监控"><a href="#2-2-11-注册监控" class="headerlink" title="2.2.11 注册监控"></a>2.2.11 注册监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Register all monitoring statistics.</span></div><div class="line">EurekaMonitors.registerAllStats();</div></pre></td></tr></table></figure><ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul><h1 id="3-Filter"><a href="#3-Filter" class="headerlink" title="3. Filter"></a>3. Filter</h1><p>Eureka-Server 过滤器( <code>javax.servlet.Filter</code> ) <strong>顺序</strong>如下：</p><ul><li>StatusFilter</li><li>ServerRequestAuthFilter</li><li>RateLimitingFilter</li><li>GzipEncodingEnforcingFilter</li><li>ServletContainer</li></ul><h2 id="3-1-StatusFilter"><a href="#3-1-StatusFilter" class="headerlink" title="3.1 StatusFilter"></a>3.1 StatusFilter</h2><p><code>com.netflix.eureka.StatusFilter</code>，Eureka-Server 状态过滤器。当 Eureka-Server 未处于开启( <code>InstanceStatus.UP</code> )状态，返回 HTTP 状态码 307 重定向，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatusFilter.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></div><div class="line"><span class="function"><span class="params">                   FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">  InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();</div><div class="line">  InstanceStatus status = myInfo.getStatus();</div><div class="line">  <span class="keyword">if</span> (status != InstanceStatus.UP &amp;&amp; response <span class="keyword">instanceof</span> HttpServletResponse) &#123;</div><div class="line">      HttpServletResponse httpRespone = (HttpServletResponse) response;</div><div class="line">      httpRespone.sendError(SC_TEMPORARY_REDIRECT,</div><div class="line">              <span class="string">"Current node is currently not ready to serve requests -- current status: "</span></div><div class="line">                      + status + <span class="string">" - try another DS node: "</span>);</div><div class="line">  &#125;</div><div class="line">  chain.doFilter(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-ServerRequestAuthFilter"><a href="#3-2-ServerRequestAuthFilter" class="headerlink" title="3.2 ServerRequestAuthFilter"></a>3.2 ServerRequestAuthFilter</h2><p><code>com.netflix.eureka.ServerRequestAuthFilter</code>，Eureka-Server 请求认证过滤器。Eureka-Server 未实现认证。目前打印访问的客户端名和版本号，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。实现代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerRequestAuthFilter.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logAuth</span><span class="params">(ServletRequest request)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (serverConfig.shouldLogIdentityHeaders()) &#123;</div><div class="line">       <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</div><div class="line">           HttpServletRequest httpRequest = (HttpServletRequest) request;</div><div class="line"></div><div class="line">           String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);</div><div class="line">           String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY);</div><div class="line"></div><div class="line">           DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + <span class="string">"-"</span> + clientVersion).build());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="3-3-RateLimitingFilter"><a href="#3-3-RateLimitingFilter" class="headerlink" title="3.3 RateLimitingFilter"></a>3.3 RateLimitingFilter</h2><p><code>com.netflix.eureka.RateLimitingFilter</code>，请求限流过滤器。在<a href="#">《TODO[0020]：限流》</a>详细解析。</p><h2 id="3-4-GzipEncodingEnforcingFilter"><a href="#3-4-GzipEncodingEnforcingFilter" class="headerlink" title="3.4 GzipEncodingEnforcingFilter"></a>3.4 GzipEncodingEnforcingFilter</h2><p><code>com.netflix.eureka.GzipEncodingEnforcingFilter</code>，GZIP 编码过滤器。</p><h2 id="3-5-ServletContainer"><a href="#3-5-ServletContainer" class="headerlink" title="3.5 ServletContainer"></a>3.5 ServletContainer</h2><p><code>com.sun.jersey.spi.container.servlet.ServletContainer</code>，Jersey MVC 请求过滤器。</p><ul><li><p>Jersey MVC 模式如下图：</p><blockquote><p>FROM <a href="http://blog.csdn.net/wangqyoho/article/details/51981916" rel="external nofollow noopener noreferrer" target="_blank">《Jersey框架的MVC》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/03.png" alt=""></p></blockquote></li><li><p>在 <code>com.netflix.eureka.resources</code> 包里，有所有的 Eureka-Server Jersey Resource ( Controller )。</p></li><li><p>过滤器在 <code>web.xml</code> 配置如下：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.sun.jersey.spi.container.servlet.ServletContainer<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.WebPageContentRegex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/(flex|images|js|css|jsp)/.*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.packages<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey;com.netflix<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- GZIP content encoding/decoding --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerRequestFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerResponseFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">   </div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>啦啦啦，Eureka-Server 启动完成！</p><p>准备工作已经完成，可以开始更加有趣的注册、续约、取消注册、过期等等 Eureka-Client 与 Eureka-Server 的交互。</p><p>搞起！</p><p>胖友，分享一波朋友圈可好！？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-server-init-second/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-server-init-second/&lt;/a&gt; 「芋
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 启动（一）之 ServerConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-server-init-first/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-server-init-first/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2017-10-17T14:02:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">http://www.iocoder.cn/Eureka/eureka-server-init-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2. EurekaServerConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2.3 DefaultEurekaServerConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 启动的过程</strong>。</p><p>考虑到整个初始化的过程中涉及的代码特别多，拆分成两两篇文章：</p><ul><li>【本文】ServerConfig</li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/?self">EurekaBootStrap</a></li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaServerConfig"><a href="#2-EurekaServerConfig" class="headerlink" title="2. EurekaServerConfig"></a>2. EurekaServerConfig</h1><p><code>com.netflix.eureka.EurekaServerConfig</code>，<strong>Eureka-Server</strong> 配置<strong>接口</strong>。</p><h2 id="2-1-类关系图"><a href="#2-1-类关系图" class="headerlink" title="2.1 类关系图"></a>2.1 类关系图</h2><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_07/01.png" alt=""></p><h2 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaServerConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><strong>请求认证相关</strong><ul><li>Eureka-Server 未实现认证。在 Spring-Cloud-Eureka-Server，通过 <code>spring-boot-starter-security</code> 模块支持。<a href="http://blog.csdn.net/liuchuanhong1/article/details/54729556" rel="external nofollow noopener noreferrer" target="_blank">《spring cloud-给Eureka Server加上安全的用户认证》</a>有详细解析。</li><li><code>#shouldLogIdentityHeaders()</code> ：打印访问的客户端名和版本号，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul></li><li><strong>请求限流相关</strong><ul><li>TODO[0020]：限流</li><li><code>#isRateLimiterEnabled()</code> ：请求限流是否开启。</li><li><code>#isRateLimiterThrottleStandardClients()</code> ：是否限制<strong>非标准</strong>客户端的访问。<strong>标准客户端</strong>通过请求头( <code>header</code> )的 <code>&quot;DiscoveryIdentity-Name&quot;</code> 来判断，是否在标准客户端名集合里。</li><li><code>#getRateLimiterPrivilegedClients()</code> ：<strong>标准</strong>客户端名集合。默认包含<code>&quot;DefaultClient&quot;</code> 和 <code>&quot;DefaultServer&quot;</code> 。</li><li><code>#getRateLimiterBurstSize()</code> ：速率限制的 burst size ，使用<strong>令牌桶算法</strong>。</li><li><code>#getRateLimiterRegistryFetchAverageRate()</code> ：<strong>增量</strong>拉取注册信息的速率限制。</li><li><code>#getRateLimiterFullFetchAverageRate()</code> ：<strong>全量</strong>拉取注册信息的速率限制。</li></ul></li><li><p><strong>获取注册信息请求相关</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a> 有详细解析。</li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 有详细解析。</li><li><code>#shouldUseReadOnlyResponseCache()</code> ：是否开启只读请求响应缓存。响应缓存 ( ResponseCache ) 机制目前使用两层缓存策略。优先读取<strong>只读缓存</strong>，读取不到后读取<strong>固定过期</strong>的<strong>读写缓存</strong>。</li><li><code>#getResponseCacheUpdateIntervalMs()</code> ：<strong>只读缓存</strong>更新频率，单位：毫秒。<strong>只读缓存</strong>定时更新任务只更新读取过请求 (<code>com.netflix.eureka.registry.Key</code>)，因此虽然永不过期，也会存在读取不到的情况。</li><li><code>#getResponseCacheAutoExpirationInSeconds()</code> ：<strong>读写缓存</strong>写入后过期时间，单位：秒。</li><li><code>#getRetentionTimeInMSInDeltaQueue()</code>：租约变更记录过期时长，单位：毫秒。默认值 ： 3 <em> 60 </em> 1000 毫秒。</li><li><code>#DeltaRetentionTimerIntervalInMs()</code>：移除队列里过期的租约变更记录的定时任务执行频率，单位：毫秒。默认值 ：30 * 1000 毫秒。</li></ul></li><li><p><strong>自我保护机制相关</strong></p><ul><li>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。 </li><li><p><code>#shouldEnableSelfPreservation()</code> ：是否开启自我保护模式。</p><blockquote><p>FROM <a href="http://www.itmuch.com/spring-cloud-sum/understanding-eureka-self-preservation/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立——《理解Eureka的自我保护模式》</a><br>当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。<br>一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。<br>当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p></blockquote></li><li><p><code>#getRenewalPercentThreshold()</code> ：开启自我保护模式比例，超过该比例后开启自我保护模式。</p></li><li><code>#getRenewalThresholdUpdateIntervalMs()</code> ：自我保护模式比例更新定时任务执行频率，单位：毫秒。</li></ul></li><li><p><strong>注册的应用实例的租约过期相关</strong></p><ul><li><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-evict/?self">《Eureka 源码解析 —— 应用实例注册发现（五）之过期》</a> 有详细解析。 </p></li><li><p><code>#getEvictionIntervalTimerInMs()</code> ：租约过期定时任务执行频率，单位：毫秒。</p></li></ul></li><li><strong>Eureka-Server 远程节点( 非集群 )读取相关</strong><ul><li>TODO[0009]：RemoteRegionRegistry</li><li><code>#getRemoteRegionUrlsWithName()</code> ：TODO[0009]：RemoteRegionRegistry。<ul><li><code>key</code> ：Eureka-Server 区域( <code>region</code> )</li><li><code>value</code> ：Eureka-Server 地址</li></ul></li><li><code>#getRemoteRegionAppWhitelist()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#getRemoteRegionRegistryFetchInterval()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#getRegistrySyncRetries()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取失败重试次数。</li><li><code>#getRegistrySyncRetryWaitMs()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取失败等待( <code>sleep</code> )间隔，单位：毫秒。 </li><li><code>#getRemoteRegionFetchThreadPoolSize()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#disableTransparentFallbackToOtherRegion()</code> ：是否禁用本地读取不到注册信息，从远程 Eureka-Server 读取。</li></ul></li><li><strong>Eureka-Server 集群同步相关</strong><ul><li>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/">《Eureka 源码解析 —— Eureka-Server 集群同步》</a></li><li><code>#getMaxThreadsForPeerReplication()</code> ：同步应用实例信息最大线程数。</li><li><code>#getMaxElementsInPeerReplicationPool()</code> ：待执行同步应用实例信息事件缓冲最大数量。</li><li><code>#getMaxTimeForReplication()</code> ：执行单个同步应用实例信息状态任务最大时间。</li><li><code>#shouldSyncWhenTimestampDiffers()</code> ：是否同步应用实例信息，当应用实例信息最后更新时间戳( <code>lastDirtyTimestamp</code> )发生改变。</li><li><code>#getWaitTimeInMsWhenSyncEmpty()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取不到注册信息时，多长时间不允许 Eureka-Client 访问。TODO[0019]：集群初始化</li><li><code>#getPeerEurekaNodesUpdateIntervalMs()</code> ：Eureka-Server 集群节点更新频率，单位：毫秒。TTODO[0019]：集群初始化</li></ul></li></ul><h2 id="2-3-DefaultEurekaServerConfig"><a href="#2-3-DefaultEurekaServerConfig" class="headerlink" title="2.3 DefaultEurekaServerConfig"></a>2.3 DefaultEurekaServerConfig</h2><p><code>com.netflix.eureka.DefaultEurekaServerConfig</code>，基于<strong>配置文件</strong>的 <strong>Eureka-Server</strong> 配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerConfig</span> <span class="keyword">implements</span> <span class="title">EurekaServerConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略部分方法和属性</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance = com.netflix.config.DynamicPropertyFactory.getInstance();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory</div><div class="line">            .getInstance().getStringProperty(<span class="string">"eureka.server.props"</span>, <span class="string">"eureka-server"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String namespace = <span class="string">"eureka."</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, TEST);</div><div class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</div><div class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// ConfigurationManager</span></div><div class="line">            <span class="comment">// .loadPropertiesFromResources(eurekaPropsFile);</span></div><div class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(<span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></div><div class="line">                            + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>, eurekaPropsFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#init()</code> 方法，初始化配置文件对象。类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。<strong>默认配置文件名</strong>为 <code>eureka-server</code>。</li><li>无配置文件的每个属性 KEY 的枚举类。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-server-init-first/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-server-init-first/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（三）之 EurekaClient</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-third/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-third/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2017-10-16T09:46:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">http://www.iocoder.cn/Eureka/eureka-client-init-third/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">2. EurekaClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">2.1 LookupService</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">3. DiscoveryClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">3.1 构造方法参数</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">3.2 构造方法</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/?self">《Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig》</a>，主要分享 <strong>Eureka-Client 自身初始化的过程</strong>的第三部分 —— <strong>EurekaClient</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li>（一）<a href="(http://www.iocoder.cn/Eureka/eureka-client-init-first/">EurekaInstanceConfig</a>)</li><li>（二）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">EurekaClientConfig</a></li><li><strong>【本文】</strong>（三）EurekaClient</li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaClient"><a href="#2-EurekaClient" class="headerlink" title="2. EurekaClient"></a>2. EurekaClient</h1><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.EurekaClient</code></a>，Eureka-Client <strong>接口</strong>，声明如下方法：</p><ul><li>提供<strong>多种</strong>方法获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。</li><li>提供方法获取<strong>本地</strong>客户端信息，例如，应用管理器( <code>com.netflix.appinfo.ApplicationInfoManager</code> )和 Eureka-Client 配置( <code>com.netflix.discovery.EurekaClientConfig</code> )。</li><li>提供方法<strong>注册</strong>本地客户端的健康检查和 Eureka 事件监听器。</li></ul><p>另外，Eureka 2.X 版本正在开发，该接口为 Eureka 1.X 和 2.X 提供平滑过渡接口。</p><blockquote><p>This interface does NOT try to clean up the current client interface for eureka 1.x. Rather it tries to provide an easier transition path from eureka 1.x to eureka 2.x.</p></blockquote><h2 id="2-1-LookupService"><a href="#2-1-LookupService" class="headerlink" title="2.1 LookupService"></a>2.1 LookupService</h2><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.shared.LookupService</code></a>，查找服务<strong>接口</strong>，提供<strong>简单单一</strong>的方式获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_29/01.png" alt=""></p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h1 id="3-DiscoveryClient"><a href="#3-DiscoveryClient" class="headerlink" title="3. DiscoveryClient"></a>3. DiscoveryClient</h1><p><code>com.netflix.discovery.DiscoveryClient</code>，实现 EurekaClient <strong>接口</strong>，用于与 Eureka-Server 交互。实现如下方法：</p><ul><li>向 Eureka-Server <strong>注册</strong>自身服务</li><li>向 Eureka-Server <strong>续约</strong>自身服务</li><li>向 Eureka-Server <strong>取消</strong>自身服务，当关闭时</li><li>从 Eureka-Server <strong>查询</strong>应用集合和应用实例信息</li><li><em>简单来理解，对 Eureka-Server 服务的增删改查</em></li></ul><h2 id="3-1-构造方法参数"><a href="#3-1-构造方法参数" class="headerlink" title="3.1 构造方法参数"></a>3.1 构造方法参数</h2><p>DiscoveryClient <strong>完整</strong>构造方法需要传入四个参数，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">     <span class="comment">// .... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ApplicationInfoManager，在<a href="ttp://www.iocoder.cn/Eureka/eureka-client-init-first/">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》</a>有详细解析。</li><li>EurekaClientConfig，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">《Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig》</a>有详细解析。</li><li><p><code>com.netflix.discovery.BackupRegistry</code>，备份注册中心<strong>接口</strong>。当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息（可能挂了），从备份注册中心读取注册信息。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BackupRegistry.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackupRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NotImplementedRegistryImpl.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotImplementedRegistryImpl</span> <span class="keyword">implements</span> <span class="title">BackupRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>com.netflix.discovery.NotImplementedRegistryImpl</code> 可以看出，目前 Eureka-Client 未提供合适的默认实现。</li></ul></li><li><p><code>com.netflix.discovery.AbstractDiscoveryClientOptionalArgs</code>，DiscoveryClient 可选参数抽象基类。不同于上面三个<strong>必填</strong>参数，该参数是<strong>选填</strong>参数，实际生产下使用较少。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成健康检查回调的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成健康检查处理器的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 向 Eureka-Server 注册之前的处理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    PreRegistrationHandler preRegistrationHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey 过滤器集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Collection&lt;T&gt; additionalFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey 客户端</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    EurekaJerseyClient eurekaJerseyClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成 Jersey 客户端的工厂的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TransportClientFactories transportClientFactories;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka 事件监听器集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Set&lt;EurekaEventListener&gt; eventListeners;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.appinfo.HealthCheckCallback</code>，健康检查回调<strong>接口</strong>，目前已经废弃，使用 HealthCheckHandler 替代，<strong>你可以不关注该参数</strong>。</li><li><p><code>com.netflix.appinfo.HealthCheckHandler</code>，健康检查处理器<strong>接口</strong>，目前暂未提供合适的<strong>默认</strong>实现，唯一提供的 <code>com.netflix.appinfo.HealthCheckCallbackToHandlerBridge</code>，用于将 HealthCheckCallback <strong>桥接</strong>成 HealthCheckHandler，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HealthCheckHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HealthCheckHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HealthCheckCallbackToHandlerBridge.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HealthCheckCallbackToHandlerBridge</span> <span class="keyword">implements</span> <span class="title">HealthCheckHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HealthCheckCallback callback;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthCheckCallbackToHandlerBridge</span><span class="params">()</span> </span>&#123;</div><div class="line">        callback = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthCheckCallbackToHandlerBridge</span><span class="params">(HealthCheckCallback callback)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.callback = callback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == callback || InstanceInfo.InstanceStatus.STARTING == currentStatus</div><div class="line">                || InstanceInfo.InstanceStatus.OUT_OF_SERVICE == currentStatus) &#123; <span class="comment">// Do not go to healthcheck handler if the status is starting or OOS.</span></div><div class="line">            <span class="keyword">return</span> currentStatus;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> callback.isHealthy() ? InstanceInfo.InstanceStatus.UP : InstanceInfo.InstanceStatus.DOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 Spring-Cloud-Eureka-Client，提供了默认实现 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/82991a7fc2859b6345b7f67e2461dbf5d7663836/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaHealthCheckHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.cloud.netflix.eureka.EurekaHealthCheckHandler</code></a>，需要结合 <a href="https://github.com/spring-projects/spring-boot/tree/c79568886406662736dcdce78f65e7f46dd62696/spring-boot-actuator/" rel="external nofollow noopener noreferrer" target="_blank"><code>spirng-boot-actuate</code></a> 使用，感兴趣的同学可以看看。本文暂不拓展开，后面另开文章分享。（TODO[0004]：健康检查）</li></ul></li><li><p><code>com.netflix.discovery.PreRegistrationHandler</code>，向 Eureka-Server 注册之前的处理器<strong>接口</strong>，目前暂未提供默认实现。通过实现该接口，可以在注册前做一些自定义的处理。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PreRegistrationHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeRegistration</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul><ul><li><p><code>additionalFilters</code>，Jersey 过滤器集合。这里声明泛型 <code>&lt;T&gt;</code> 的原因，Jersey 1.X 和 Jersey 2.X 的过滤器接口<strong>不同</strong>，通过泛型来支持。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Jersey1DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jersey1DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">ClientFilter</span>&gt; </span>&#123;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="comment">// Jersey2DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jersey2DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">ClientRequestFilter</span>&gt; </span>&#123;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="comment">// DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">Jersey1DiscoveryClientOptionalArgs</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Jersey 1.X 使用 ClientFilter 。ClientFilter 目前有两个过滤器实现：EurekaIdentityHeaderFilter 、DynamicGZIPContentEncodingFilter 。</li><li>Jersey 2.X 使用 ClientRequestFilter 。</li><li>DiscoveryClient 使用 DiscoveryClientOptionalArgs，即 Jersey 1.X 。</li></ul></li></ul></li></ul><ul><li><code>eurekaJerseyClient</code>，Jersey 客户端。该<strong>参数</strong>目前废弃，使用下面 TransportClientFactories 参数来进行生成。</li><li><p><code>com.netflix.discovery.shared.transport.jersey.TransportClientFactories</code>，生成 Jersey 客户端<strong>工厂的工厂</strong>接口。目前有 Jersey1TransportClientFactories 、Jersey2TransportClientFactories 两个实现。TransportClientFactories 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransportClientFactories.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactories</span>&lt;<span class="title">F</span>&gt; </span>&#123;</div><div class="line">  </div><div class="line">      <span class="meta">@Deprecated</span></div><div class="line">      <span class="function">TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> Collection&lt;F&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> EurekaJerseyClient providedJerseyClient)</span></span>;</div><div class="line">  </div><div class="line">      <span class="function">TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> Collection&lt;F&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TransportClientFactory.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="function">EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span></span>;</div><div class="line">    </div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第一个方法已经废弃，这就是为什么说上面的 <code>eurekaJerseyClient</code> <strong>参数</strong>( 不是 EurekaJerseyClient 类)已经废弃，被第二个方法取代。相比来说，第二个方法对 EurekaJerseyClient 创建封装会更好。</li></ul></li><li><p><code>com.netflix.discovery.EurekaEventListener</code>，Eureka 事件监听器。实现代码如下：</p> <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaEventListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEventListener</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// EurekaEvent.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEvent</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryEvent.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryEvent</span> <span class="keyword">implements</span> <span class="title">EurekaEvent</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.discovery.StatusChangeEvent</code>，应用实例状态变更事件，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a> 有详细解析。</li><li><code>com.netflix.discovery.CacheRefreshedEvent</code>，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》「2.4 发起获取注册信息」</a> 有详细解析。</li></ul></li></ul></li></ul><h2 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h2><p>DiscoveryClient 的构造方法实现代码相对较多，已经将代码<strong>切块</strong> + <strong>中文注册</strong>，点击 <a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L298" rel="external nofollow noopener noreferrer" target="_blank">DiscoveryClient</a> 链接，对照下面每个小结阅读理解。</p><h3 id="3-2-1-赋值-AbstractDiscoveryClientOptionalArgs"><a href="#3-2-1-赋值-AbstractDiscoveryClientOptionalArgs" class="headerlink" title="3.2.1 赋值 AbstractDiscoveryClientOptionalArgs"></a>3.2.1 赋值 AbstractDiscoveryClientOptionalArgs</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.healthCheckHandlerProvider = args.healthCheckHandlerProvider;</div><div class="line">  <span class="keyword">this</span>.healthCheckCallbackProvider = args.healthCheckCallbackProvider;</div><div class="line">  <span class="keyword">this</span>.eventListeners.addAll(args.getEventListeners());</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler = args.preRegistrationHandler;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.healthCheckCallbackProvider = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">this</span>.healthCheckHandlerProvider = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-2-赋值-ApplicationInfoManager、EurekaClientConfig"><a href="#3-2-2-赋值-ApplicationInfoManager、EurekaClientConfig" class="headerlink" title="3.2.2 赋值 ApplicationInfoManager、EurekaClientConfig"></a>3.2.2 赋值 ApplicationInfoManager、EurekaClientConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"></div><div class="line">clientConfig = config;</div><div class="line">staticClientConfig = clientConfig;</div><div class="line">transportConfig = config.getTransportConfig();</div><div class="line">instanceInfo = myInfo;</div><div class="line"><span class="keyword">if</span> (myInfo != <span class="keyword">null</span>) &#123;</div><div class="line">  appPathIdentifier = instanceInfo.getAppName() + <span class="string">"/"</span> + instanceInfo.getId(); <span class="comment">// 无实际业务用途，用于打 logger</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  logger.warn(<span class="string">"Setting instanceInfo to a passed in null value"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-3-赋值-BackupRegistry"><a href="#3-2-3-赋值-BackupRegistry" class="headerlink" title="3.2.3 赋值 BackupRegistry"></a>3.2.3 赋值 BackupRegistry</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.backupRegistryProvider = backupRegistryProvider;</div></pre></td></tr></table></figure><h3 id="3-2-4-初始化-InstanceInfoBasedUrlRandomizer"><a href="#3-2-4-初始化-InstanceInfoBasedUrlRandomizer" class="headerlink" title="3.2.4 初始化 InstanceInfoBasedUrlRandomizer"></a>3.2.4 初始化 InstanceInfoBasedUrlRandomizer</h3><p>TODO[0016]：InstanceInfoBasedUrlRandomizer</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.urlRandomizer = <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);</div></pre></td></tr></table></figure><h3 id="3-2-5-初始化-Applications-在本地的缓存"><a href="#3-2-5-初始化-Applications-在本地的缓存" class="headerlink" title="3.2.5 初始化 Applications 在本地的缓存"></a>3.2.5 初始化 Applications 在本地的缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Applications 在本地的缓存</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拉取注册信息次数</span></div><div class="line"><span class="comment">* monotonically increasing generation counter to ensure stale threads do not reset registry to an older version</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong fetchRegistryGeneration;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">localRegionApps.set(<span class="keyword">new</span> Applications());</div><div class="line"></div><div class="line">fetchRegistryGeneration = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div></pre></td></tr></table></figure><ul><li>在创建 DiscoveryClient 时，<code>localRegionApps</code> 为空。</li><li>定时任务<strong>间隔</strong>从 Eureka-Server 拉取注册应用信息到本地缓存，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a> 有详细解析。</li></ul><h3 id="3-2-6-获取哪些-Region-集合的注册信息"><a href="#3-2-6-获取哪些-Region-集合的注册信息" class="headerlink" title="3.2.6 获取哪些 Region 集合的注册信息"></a>3.2.6 获取哪些 Region 集合的注册信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取哪些区域( Region )集合的注册信息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; remoteRegionsToFetch;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取哪些区域( Region )集合的注册信息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String[]&gt; remoteRegionsRef;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">remoteRegionsToFetch = <span class="keyword">new</span> AtomicReference&lt;&gt;(clientConfig.fetchRegistryForRemoteRegions());</div><div class="line">remoteRegionsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == <span class="keyword">null</span> ? <span class="keyword">null</span> : remoteRegionsToFetch.get().split(<span class="string">","</span>));</div></pre></td></tr></table></figure><h3 id="3-2-7-初始化拉取、心跳的监控"><a href="#3-2-7-初始化拉取、心跳的监控" class="headerlink" title="3.2.7 初始化拉取、心跳的监控"></a>3.2.7 初始化拉取、心跳的监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功从 Eureka-Server 拉取注册信息时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulRegistryFetchTimestamp = -<span class="number">1</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功向 Eureka-Server 心跳时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulHeartbeatTimestamp = -<span class="number">1</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 心跳监控</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThresholdLevelsMetric heartbeatStalenessMonitor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拉取监控</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThresholdLevelsMetric registryStalenessMonitor;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (config.shouldFetchRegistry()) &#123;</div><div class="line">  <span class="keyword">this</span>.registryStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="string">"lastUpdateSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (config.shouldRegisterWithEureka()) &#123;</div><div class="line">  <span class="keyword">this</span>.heartbeatStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="string">"lastHeartbeatSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>每次成功向 Eureka-Serve 心跳或者从从 Eureka-Server 拉取注册信息后，都会更新相应时间戳。</li><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>对 <a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/util/ThresholdLevelsMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.util.ThresholdLevelsMetric</code></a> 感兴趣的同学可以点击链接查看。本文暂不拓展开，后面另开文章分享。（TODO[0012]：监控相关）</li></ul><h3 id="3-2-8-结束初始化，当无需和-Eureka-Server-交互"><a href="#3-2-8-结束初始化，当无需和-Eureka-Server-交互" class="headerlink" title="3.2.8 结束初始化，当无需和 Eureka-Server 交互"></a>3.2.8 结束初始化，当无需和 Eureka-Server 交互</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;</div><div class="line">  logger.info(<span class="string">"Client configured to neither register nor query for data."</span>);</div><div class="line">  scheduler = <span class="keyword">null</span>;</div><div class="line">  heartbeatExecutor = <span class="keyword">null</span>;</div><div class="line">  cacheRefreshExecutor = <span class="keyword">null</span>;</div><div class="line">  eurekaTransport = <span class="keyword">null</span>;</div><div class="line">  instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(<span class="keyword">new</span> PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());</div><div class="line"></div><div class="line">  <span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></div><div class="line">  <span class="comment">// to work with DI'd DiscoveryClient</span></div><div class="line">  DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</div><div class="line">  DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line"></div><div class="line">  initTimestampMs = System.currentTimeMillis();</div><div class="line">  logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</div><div class="line">          initTimestampMs, <span class="keyword">this</span>.getApplications().size());</div><div class="line"></div><div class="line">  <span class="keyword">return</span>;  <span class="comment">// no need to setup up an network tasks and we are done</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-9-初始化线程池"><a href="#3-2-9-初始化线程池" class="headerlink" title="3.2.9 初始化线程池"></a>3.2.9 初始化线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 线程池</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* A scheduler to be used for the following 3 tasks: 【目前只有两个】</span></div><div class="line"><span class="comment">* - updating service urls</span></div><div class="line"><span class="comment">* - scheduling a TimedSuperVisorTask</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line"><span class="comment">// additional executors for supervised subtasks</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 心跳执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor heartbeatExecutor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #localRegionApps&#125; 刷新执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor cacheRefreshExecutor;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></div><div class="line">scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build());</div><div class="line"></div><div class="line">heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">     <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build()</div><div class="line">);  <span class="comment">// use direct handoff</span></div><div class="line"></div><div class="line">cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">     <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build()</div><div class="line">);  <span class="comment">// use direct handoff</span></div></pre></td></tr></table></figure><ul><li><code>scheduler</code>，<strong>定时任务</strong>线程池，初始化大小为 2，一个给 <code>heartbeatExecutor</code>，一个给 <code>cacheRefreshExecutor</code>。</li><li><code>heartbeatExecutor</code>、<code>cacheRefreshExecutor</code> 在提交给 <code>scheduler</code> 才声明具体的<strong>任务</strong>。</li></ul><h3 id="3-2-10-初始化-Eureka-网络通信相关"><a href="#3-2-10-初始化-Eureka-网络通信相关" class="headerlink" title="3.2.10 初始化 Eureka 网络通信相关"></a>3.2.10 初始化 Eureka 网络通信相关</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</div><div class="line">scheduleServerEndpointTask(eurekaTransport, args);</div></pre></td></tr></table></figure><ul><li>本文暂不拓展开，在 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》</a> 和 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》</a> 详细解析。</li></ul><h3 id="3-2-11-初始化-InstanceRegionChecker"><a href="#3-2-11-初始化-InstanceRegionChecker" class="headerlink" title="3.2.11 初始化 InstanceRegionChecker"></a>3.2.11 初始化 InstanceRegionChecker</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">AzToRegionMapper azToRegionMapper;</div><div class="line"><span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</div><div class="line">    azToRegionMapper = <span class="keyword">new</span> DNSBasedAzToRegionMapper(clientConfig);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    azToRegionMapper = <span class="keyword">new</span> PropertyBasedAzToRegionMapper(clientConfig);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsToFetch.get()) &#123;</div><div class="line">    azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(<span class="string">","</span>));</div><div class="line">&#125;</div><div class="line">instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());</div></pre></td></tr></table></figure><ul><li><code>com.netflix.discovery.AzToRegionMapper</code>，主要用于亚马逊 AWS，跳过。</li><li><p><code>com.netflix.discovery.InstanceRegionChecker</code>，应用实例信息区域( <code>region</code> )校验，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceRegionChecker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略和亚马逊 AWS 相关的属性和方法</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 本地区域( Region )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String localRegion;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocalRegion</span><span class="params">(@Nullable String instanceRegion)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == instanceRegion || instanceRegion.equals(localRegion); <span class="comment">// no region == local</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocalRegion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> localRegion;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="3-2-12-从-Eureka-Server-拉取注册信息"><a href="#3-2-12-从-Eureka-Server-拉取注册信息" class="headerlink" title="3.2.12 从 Eureka-Server 拉取注册信息"></a>3.2.12 从 Eureka-Server 拉取注册信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">  fetchRegistryFromBackup();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server <strong>初始</strong>拉取注册信息。在（TO后文链接）详细解析。</li><li><p>调用 <code>#fetchRegistryFromBackup()</code> 方法，若<strong>初始</strong>拉取注册信息失败，从备份注册中心获取。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchRegistryFromBackup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        BackupRegistry backupRegistryInstance = newBackupRegistryInstance();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == backupRegistryInstance) &#123; <span class="comment">// backward compatibility with the old protected method, in case it is being used.</span></div><div class="line">            backupRegistryInstance = backupRegistryProvider.get();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != backupRegistryInstance) &#123;</div><div class="line">            Applications apps = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (isFetchingRemoteRegionRegistries()) &#123;</div><div class="line">                String remoteRegionsStr = remoteRegionsToFetch.get();</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsStr) &#123;</div><div class="line">                    apps = backupRegistryInstance.fetchRegistry(remoteRegionsStr.split(<span class="string">","</span>));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                apps = backupRegistryInstance.fetchRegistry();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (apps != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> Applications applications = <span class="keyword">this</span>.filterAndShuffle(apps);</div><div class="line">                applications.setAppsHashCode(applications.getReconcileHashCode());</div><div class="line">                localRegionApps.set(applications);</div><div class="line">                logTotalInstances();</div><div class="line">                logger.info(<span class="string">"Fetched registry successfully from the backup"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.warn(<span class="string">"No backup registry instance defined &amp; unable to find any discovery servers."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        logger.warn(<span class="string">"Cannot fetch applications from apps although backup registry was specified"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>BackupRegistry 目前暂未提供默认实现，需要自行相关逻辑。</li></ul></li></ul><h3 id="3-2-13-执行向-Eureka-Server-注册之前的处理器"><a href="#3-2-13-执行向-Eureka-Server-注册之前的处理器" class="headerlink" title="3.2.13 执行向 Eureka-Server 注册之前的处理器"></a>3.2.13 执行向 Eureka-Server 注册之前的处理器</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// call and execute the pre registration handler before all background tasks (inc registration) is started</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.preRegistrationHandler != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler.beforeRegistration();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-14-初始化定时任务"><a href="#3-2-14-初始化定时任务" class="headerlink" title="3.2.14 初始化定时任务"></a>3.2.14 初始化定时任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">initScheduledTasks();</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Eureka-Server 拉取注册信息执行器</span></div><div class="line">   <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line">       <span class="comment">// registry cache refresh timer</span></div><div class="line">       <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"cacheRefresh"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       cacheRefreshExecutor,</div><div class="line">                       registryFetchIntervalSeconds,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> CacheRefreshThread()</div><div class="line">               ),</div><div class="line">               registryFetchIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">   <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">       <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</div><div class="line">       logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</div><div class="line"></div><div class="line">       <span class="comment">// Heartbeat timer</span></div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"heartbeat"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       heartbeatExecutor,</div><div class="line">                       renewalIntervalInSecs,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> HeartbeatThread()</div><div class="line">               ),</div><div class="line">               renewalIntervalInSecs, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">       <span class="comment">// InstanceInfo replicator</span></div><div class="line">       instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</div><div class="line">               <span class="keyword">this</span>,</div><div class="line">               instanceInfo,</div><div class="line">               clientConfig.getInstanceInfoReplicationIntervalSeconds(),</div><div class="line">               <span class="number">2</span>); <span class="comment">// burstSize</span></div><div class="line"></div><div class="line">       statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</div><div class="line">                       InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</div><div class="line">                   <span class="comment">// log at warn level if DOWN was involved</span></div><div class="line">                   logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">               &#125;</div><div class="line">               instanceInfoReplicator.onDemandUpdate();</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</div><div class="line">           applicationInfoManager.registerStatusChangeListener(statusChangeListener);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>初始化</strong>从 Eureka-Server 拉取注册信息执行器，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a> 详细解析。</li><li><strong>初始化</strong>向 Eureka-Server 心跳（续租）执行器，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 详细解析。</li></ul><h3 id="3-2-15-向-Servo-注册监控"><a href="#3-2-15-向-Servo-注册监控" class="headerlink" title="3.2.15 向 Servo 注册监控"></a>3.2.15 向 Servo 注册监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Monitors.registerObject(<span class="keyword">this</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">  logger.warn(<span class="string">"Cannot register timers"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul><h3 id="3-2-16-初始化完成"><a href="#3-2-16-初始化完成" class="headerlink" title="3.2.16 初始化完成"></a>3.2.16 初始化完成</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 初始化完成时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> initTimestampMs;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// 【3.2.16】初始化完成</span></div><div class="line"><span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></div><div class="line"><span class="comment">// to work with DI'd DiscoveryClient</span></div><div class="line">DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</div><div class="line">DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line"></div><div class="line">initTimestampMs = System.currentTimeMillis();</div><div class="line">logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</div><div class="line">      initTimestampMs, <span class="keyword">this</span>.getApplications().size());</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>由于笔者是边理解源码边输出博客内容，如果有错误或者不清晰的地方，<strong>欢迎</strong>微笑给我的微信公众号( <strong>芋道源码</strong> ) 留言，我会<strong>仔细</strong>回复。感谢 + 1024。</p><p>后面文章不断更新，会慢慢完善本文中的。</p><p>推荐参考阅读：</p><ul><li><a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD —— 《Spring Cloud微服务实战》</a> Spring Cloud Eureka —— 源码分析</li><li><strong>买盗版书，等于编写一个初级 BUG</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-client-init-third/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-client-init-third/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-second/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-second/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2017-10-16T13:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">http://www.iocoder.cn/Eureka/eureka-client-init-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2. EurekaClientConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.3 DefaultEurekaClientConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.4 DefaultEurekaClientConfigProvider</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3. EurekaTransportConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3.3 DefaultEurekaTransportConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">666. 彩蛋</a></li></ul><hr><p><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg"></a></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》</a>，主要分享 <strong>Eureka-Client 自身初始化的过程</strong>的第二部分 —— <strong>EurekaClientConfig</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li>（一）<a href="(http://www.iocoder.cn/Eureka/eureka-client-init-first/">EurekaInstanceConfig</a>)</li><li><strong>【本文】</strong>（二）EurekaClientConfig</li><li>（三）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">EurekaClient</a></li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaClientConfig"><a href="#2-EurekaClientConfig" class="headerlink" title="2. EurekaClientConfig"></a>2. EurekaClientConfig</h1><p><code>com.netflix.discovery.EurekaClientConfig</code>，<strong>Eureka-Client</strong> 配置<strong>接口</strong>。</p><h2 id="2-1-类关系图"><a href="#2-1-类关系图" class="headerlink" title="2.1 类关系图"></a>2.1 类关系图</h2><p>EurekaClientConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_22/04.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2ClientConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li></ul><h2 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaClientConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><p><strong>Region、Zone 相关</strong></p><ul><li><code>#getRegion()</code> ：Eureka-Client 所在区域( <code>region</code> )。</li><li><p><code>#getAvailabilityZones()</code> ：Eureka-Client 所在地区( <code>region</code> ) 可用区( <code>zone</code> )集合。<strong>该参数虽然是数组，第一个元素代表其所在的可用区</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getZone</span><span class="params">(String[] availZones, InstanceInfo myInfo)</span> </span>&#123;</div><div class="line">    String instanceZone = ((availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) ? <span class="string">"default"</span></div><div class="line">            : availZones[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">if</span> (myInfo != <span class="keyword">null</span></div><div class="line">            &amp;&amp; myInfo.getDataCenterInfo().getName() == DataCenterInfo.Name.Amazon) &#123;</div><div class="line">    </div><div class="line">        String awsInstanceZone = ((AmazonInfo) myInfo.getDataCenterInfo())</div><div class="line">                .get(AmazonInfo.MetaDataKey.availabilityZone);</div><div class="line">        <span class="keyword">if</span> (awsInstanceZone != <span class="keyword">null</span>) &#123;</div><div class="line">            instanceZone = awsInstanceZone;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instanceZone;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul><ul><li>进步一步理解 Region、Zone 查看<a href="http://www.itmuch.com/spring-cloud-1/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《周立 —— Region、Zone解析》</a>。</li></ul></li></ul></li><li><strong>使用 DNS 获取 Eureka-Server URL 相关</strong><ul><li><code>#shouldUseDnsForFetchingServiceUrls()</code> ：是否使用 DNS 方式获取 Eureka-Server URL 地址。</li><li><code>#getEurekaServerDNSName()</code> ：Eureka-Server 的 DNS 名。</li><li><code>#getEurekaServerPort()</code> ：Eureka-Server 的端口。</li><li><code>#getEurekaServerURLContext()</code> ：Eureka-Server 的 URL Context 。</li><li><code>#getEurekaServiceUrlPollIntervalSeconds()</code> ：轮询获取 Eureka-Server 地址变更频率，单位：秒。默认：300 秒。</li><li><code>#shouldPreferSameZoneEureka()</code> ：优先使用相同区( <code>zone</code> )的 Eureka-Server。</li></ul></li><li><strong>直接配合 Eureka-Server URL 相关</strong><ul><li><code>#getEurekaServerServiceUrls()</code> ： Eureka-Server 的 URL 集合。</li></ul></li><li><strong>发现：从 Eureka-Server 获取注册信息相关</strong><ul><li><code>#shouldFetchRegistry()</code> ：是否从 Eureka-Server 拉取注册信息。</li><li><code>#getRegistryFetchIntervalSeconds()</code> ：从 Eureka-Server 拉取注册信息频率，单位：秒。默认：30 秒。</li><li><code>#shouldFilterOnlyUpInstances()</code> ：是否过滤，只获取状态为开启( Up )的应用实例集合。</li><li><code>#fetchRegistryForRemoteRegions()</code> ：TODO[0009]：RemoteRegionRegistry</li><li><code>#getCacheRefreshExecutorThreadPoolSize()</code> ：注册信息缓存刷新线程池大小。</li><li><code>#getCacheRefreshExecutorExponentialBackOffBound()</code> ：注册信息缓存刷新执行超时后的延迟重试的时间。</li><li><code>#getRegistryRefreshSingleVipAddress()</code> ：TODO[0010]：getRegistryRefreshSingleVipAddress</li></ul></li><li><strong>注册：向 Eureka-Server 注册自身服务</strong><ul><li><code>#shouldRegisterWithEureka()</code> ：是否向 Eureka-Server 注册自身服务。</li><li><code>#shouldUnregisterOnShutdown()</code> ：是否向 Eureka-Server 取消注册自身服务，当进程关闭时。</li><li><code>#getInstanceInfoReplicationIntervalSeconds()</code> ：向 Eureka-Server 同步应用实例信息变化频率，单位：秒。</li><li><code>#getInitialInstanceInfoReplicationIntervalSeconds()</code> ：向 Eureka-Server 同步应用信息变化初始化延迟，单位：秒。</li><li><code>#getBackupRegistryImpl()</code> ：获取备份注册中心实现类。当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息（可能挂了），从备份注册中心读取注册信息。目前 Eureka-Client 未提供合适的实现。</li><li><code>#getHeartbeatExecutorThreadPoolSize()</code> ：心跳执行线程池大小。</li><li><code>#getHeartbeatExecutorExponentialBackOffBound()</code> ：心跳执行超时后的延迟重试的时间。</li></ul></li></ul><h2 id="2-3-DefaultEurekaClientConfig"><a href="#2-3-DefaultEurekaClientConfig" class="headerlink" title="2.3 DefaultEurekaClientConfig"></a>2.3 DefaultEurekaClientConfig</h2><p><code>com.netflix.discovery.DefaultEurekaClientConfig</code>，基于<strong>配置文件</strong>的 <strong>Eureka-Client</strong> 配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfig</span> <span class="keyword">implements</span> <span class="title">EurekaClientConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ZONE = <span class="string">"defaultZone"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * HTTP 传输配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaTransportConfig transportConfig;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaClientConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</div><div class="line">                ? namespace</div><div class="line">                : namespace + <span class="string">"."</span>;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</div><div class="line">        <span class="comment">// 创建 HTTP 传输配置</span></div><div class="line">        <span class="keyword">this</span>.transportConfig = <span class="keyword">new</span> DefaultEurekaTransportConfig(namespace, configInstance);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。</li><li>在 <code>com.netflix.discovery.PropertyBasedClientConfigConstants</code> 可以看到配置文件的每个属性 KEY 。</li><li><code>transportConfig</code> 属性，在 <a href="#">「3. EurekaTransportConfig」</a> 详细解析。</li></ul><h2 id="2-4-DefaultEurekaClientConfigProvider"><a href="#2-4-DefaultEurekaClientConfigProvider" class="headerlink" title="2.4 DefaultEurekaClientConfigProvider"></a>2.4 DefaultEurekaClientConfigProvider</h2><p><code>com.netflix.discovery.providers.DefaultEurekaClientConfigProvider</code>，创建 DefaultEurekaClientConfig 的工厂，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfigProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">EurekaClientConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</div><div class="line">    <span class="meta">@EurekaNamespace</span></div><div class="line">    <span class="keyword">private</span> String namespace;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DefaultEurekaClientConfig config;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> EurekaClientConfig <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</div><div class="line">            config = (namespace == <span class="keyword">null</span>)</div><div class="line">                    ? <span class="keyword">new</span> DefaultEurekaClientConfig()</div><div class="line">                    : <span class="keyword">new</span> DefaultEurekaClientConfig(namespace);</div><div class="line">                    </div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Remove this when DiscoveryManager is finally no longer used</span></div><div class="line">            DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> config;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>推荐参考阅读：</p><ul><li><a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD —— 《Spring Cloud微服务实战》</a> Spring Cloud Eureka —— 配置详解</li><li><a href="http://www.cnblogs.com/fangfuhai/p/7070325.html" rel="external nofollow noopener noreferrer" target="_blank">风中程序猿 —— 《微服务架构：Eureka参数配置项详解》</a></li></ul><h1 id="3-EurekaTransportConfig"><a href="#3-EurekaTransportConfig" class="headerlink" title="3. EurekaTransportConfig"></a>3. EurekaTransportConfig</h1><h2 id="3-1-类关系图"><a href="#3-1-类关系图" class="headerlink" title="3.1 类关系图"></a>3.1 类关系图</h2><p>EurekaTransportConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_22/05.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2TransportConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li></ul><h2 id="3-2-配置属性"><a href="#3-2-配置属性" class="headerlink" title="3.2 配置属性"></a>3.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/3a65b471526e4912829bbfedc29822ba93ef42bb/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaTransportConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaTransportConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><code>#getSessionedClientReconnectIntervalSeconds()</code> ：EurekaHttpClient 会话周期性重连时间，单位：秒。在 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》「5.4 SessionedEurekaHttpClient」》</a> 有详细解析。</li><li><code>#getRetryableClientQuarantineRefreshPercentage()</code> ：重试 EurekaHttpClient ，请求失败的 Eureka-Server 隔离集合占比 Eureka-Server 全量集合占比，超过该比例，进行清空。在 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》「5.3 RetryableEurekaHttpClient」》</a> 有详细解析。</li><li><strong>异步 EndPoint 集群解析器</strong> ：<ul><li>在 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》「3.6 AsyncResolver」》</a> 有详细解析。</li><li><code>#getAsyncResolverRefreshIntervalMs()</code> ：异步解析 EndPoint 集群频率，单位：毫秒。</li><li><code>#getAsyncResolverWarmUpTimeoutMs()</code> ：异步解析器预热解析 EndPoint 集群超时时间，单位：毫秒。</li><li><code>#getAsyncExecutorThreadPoolSize()</code> ：异步解析器线程池大小。</li></ul></li><li>TODO[0028]：写入集群和读取集群。Eureka 2.x 兼容 ：<ul><li><code>#getApplicationsResolverDataStalenessThresholdSeconds()</code></li><li><code>#applicationsResolverUseIp()</code></li><li><code>#getWriteClusterVip()</code></li><li><code>#getReadClusterVip()</code></li><li><code>#getBootstrapResolverStrategy()</code></li><li><code>#useBootstrapResolverForQuery()</code></li></ul></li></ul><h2 id="3-3-DefaultEurekaTransportConfig"><a href="#3-3-DefaultEurekaTransportConfig" class="headerlink" title="3.3 DefaultEurekaTransportConfig"></a>3.3 DefaultEurekaTransportConfig</h2><p><code>com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig</code>，基于<strong>配置文件</strong>的<strong>网络传输</strong>配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaTransportConfig</span> <span class="keyword">implements</span> <span class="title">EurekaTransportConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + <span class="string">"."</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaTransportConfig</span><span class="params">(String parentNamespace, DynamicPropertyFactory configInstance)</span> </span>&#123;</div><div class="line">        <span class="comment">// 命名空间</span></div><div class="line">        <span class="keyword">this</span>.namespace = parentNamespace == <span class="keyword">null</span></div><div class="line">                ? SUB_NAMESPACE</div><div class="line">                : (parentNamespace.endsWith(<span class="string">"."</span>)</div><div class="line">                    ? parentNamespace + SUB_NAMESPACE</div><div class="line">                    : parentNamespace + <span class="string">"."</span> + SUB_NAMESPACE);</div><div class="line">        <span class="comment">// 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = configInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。</li><li>在 <code>com.netflix.discovery.shared.transport.PropertyBasedTransportConfigConstants</code> 可以看到配置文件的每个属性 KEY 。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-client-init-second/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-client-init-second/&lt;/a&gt; 「芋
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-first/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-first/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2017-10-12T05:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">http://www.iocoder.cn/Eureka/eureka-client-init-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2. EurekaInstanceConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.3 AbstractInstanceConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.4 PropertiesInstanceConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.5 MyDataCenterInstanceConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.6 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">3. InstanceInfo</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">4. ApplicationInfoManager</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 自身初始化的过程</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li><strong>【本文】</strong>（一）EurekaInstanceConfig</li><li>（二）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">EurekaClientConfig</a></li><li>（三）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">EurekaClient</a></li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaInstanceConfig"><a href="#2-EurekaInstanceConfig" class="headerlink" title="2. EurekaInstanceConfig"></a>2. EurekaInstanceConfig</h1><p><code>com.netflix.appinfo.EurekaInstanceConfig</code>，Eureka <strong>应用实例</strong>配置<strong>接口</strong>。在下文你会看到 EurekaClientConfig <strong>接口</strong>，两者的区别如下：</p><ul><li>EurekaInstanceConfig，重在<strong>应用实例</strong>，例如，应用名、应用的端口等等。此处应用指的是，Application Consumer 和 Application Provider。</li><li>EurekaClientConfig，重在 <strong>Eureka-Client</strong>，例如， 连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。</li></ul><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/02.jpeg" alt=""></p><h2 id="2-1-类关系图"><a href="#2-1-类关系图" class="headerlink" title="2.1 类关系图"></a>2.1 类关系图</h2><p>EurekaInstanceConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/03.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2ClientConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li><li>CloudInstanceConfig、Ec2EurekaArchaius2InstanceConfig 基于亚马逊 AWS，大多数读者和我对 AWS 都不了解，因此暂不解析。</li></ul><h2 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaInstanceConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><code>#getLeaseRenewalIntervalInSeconds()</code> ：租约续约频率，单位：秒。应用不断通过按照该频率发送心跳给 Eureka-Server 以达到续约的作用。当 Eureka-Server 超过最大频率未收到续约（心跳），契约失效，进行应用移除。应用移除后，其他应用无法从 Eureka-Server 获取该应用。</li><li><code>#getLeaseExpirationDurationInSeconds()</code> ：契约过期时间，单位：秒。</li><li><p><code>#getDataCenterInfo()</code> ：数据中心信息。<code>com.netflix.appinfo.DataCenterInfo</code>，数据中心信息<strong>接口</strong>，目前较为简单，标记所属数据中心名。一般情况下，我们使用 <code>Name.MyOwn</code>。接口实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCenterInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据中心名枚举</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> Name &#123;</div><div class="line">        Netflix,</div><div class="line">        Amazon,</div><div class="line">        MyOwn</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 归属的数据中心名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Name <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>#getNamespace()</code> ：配置命名空间，默认使用 <code>eureka</code>。以 <code>eureka-client.properties</code> 举个例子：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">eureka.name=eureka</div><div class="line">eureka.port=<span class="number">8080</span></div><div class="line">eureka.vipAddress=eureka.mydomain.net</div></pre></td></tr></table></figure><ul><li>每个属性<strong>最前面</strong>的 <code>eureka</code> 即是配置命名空间，一般情况无需修改。</li></ul></li><li><p>TODO[0004]：健康检查</p></li><li>TODO[0006]：getDefaultAddressResolutionOrder</li><li><code>#isInstanceEnabledOnit()</code> ：应用初始化后是否开启。在<a href="#">「3. InstanceInfo」</a>详细解析。</li></ul><h2 id="2-3-AbstractInstanceConfig"><a href="#2-3-AbstractInstanceConfig" class="headerlink" title="2.3 AbstractInstanceConfig"></a>2.3 AbstractInstanceConfig</h2><p><code>com.netflix.appinfo.AbstractInstanceConfig</code>，Eureka <strong>应用实例</strong>配置<strong>抽象基类</strong>，主要实现一些相对<strong>通用</strong>的配置，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 契约过期时间，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEASE_EXPIRATION_DURATION_SECONDS = <span class="number">90</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 租约续约频率，单位：秒。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEASE_RENEWAL_INTERVAL_SECONDS = <span class="number">30</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 https 端口关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SECURE_PORT_ENABLED = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 http 端口开启</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> NON_SECURE_PORT_ENABLED = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 http 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NON_SECURE_PORT = <span class="number">80</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 https 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECURE_PORT = <span class="number">443</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用初始化后开启</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> INSTANCE_ENABLED_ON_INIT = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主机信息</span></div><div class="line"><span class="comment">     * key：主机 IP 地址</span></div><div class="line"><span class="comment">     * value：主机名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pair&lt;String, String&gt; hostInfo = getHostInfo();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据中心信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> DataCenterInfo info = <span class="keyword">new</span> DataCenterInfo() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Name.MyOwn;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">getHostInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Pair&lt;String, String&gt; pair;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InetAddress localHost = InetAddress.getLocalHost();</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(localHost.getHostAddress(), localHost.getHostName());</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot get host info"</span>, e);</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(<span class="string">""</span>, <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pair;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略 setting / getting 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#getHostInfo()</code> 方法，获取本地服务器的主机名和主机 IP 地址。<strong>如果主机有多网卡或者虚拟机网卡</strong>，这块要小心，解决方式如下：<ul><li>手动配置本机的 <code>hostname</code> + <code>etc/hosts</code> 文件，从而映射主机名和 IP 地址。</li><li>使用 Spring-Cloud-Eureka-Client 的话，参考<a href="http://www.itmuch.com/spring-cloud-code-read/spring-cloud-code-read-eureka-registry-ip/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立 —— 《Eureka服务注册过程详解之IpAddress》</a>解决。</li></ul></li></ul><h2 id="2-4-PropertiesInstanceConfig"><a href="#2-4-PropertiesInstanceConfig" class="headerlink" title="2.4 PropertiesInstanceConfig"></a>2.4 PropertiesInstanceConfig</h2><p><code>com.netflix.appinfo.PropertiesInstanceConfig</code>，基于<strong>配置文件</strong>的 Eureka <strong>应用实例</strong>配置<strong>抽象基类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用分组</span></div><div class="line"><span class="comment">     * 从 环境变量 获取</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String appGrpNameFromEnv;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(CommonConstants.DEFAULT_CONFIG_NAMESPACE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(namespace, <span class="keyword">new</span> DataCenterInfo() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Name.MyOwn;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace, DataCenterInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(info);</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</div><div class="line">                ? namespace</div><div class="line">                : namespace + <span class="string">"."</span>;</div><div class="line">        <span class="comment">// 从 环境变量 获取 应用分组</span></div><div class="line">        appGrpNameFromEnv = ConfigurationManager.getConfigInstance()</div><div class="line">                .getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppGroupName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> configInstance.getStringProperty(namespace + APP_GROUP_KEY, appGrpNameFromEnv).get().trim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>configInstance</code> 属性，配置文件对象，基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 1.x</a> 实现配置文件的读取。在 <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/PropertyBasedInstanceConfigConstants.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.PropertyBasedInstanceConfigConstants</code></a> 可以看到配置文件的每个属性 KEY 。</li><li><p><code>appGrpNameFromEnv</code> 属性，应用分组，从<strong>环境变量</strong>中获取。从 <code>#getAppGroupName()</code> 方法中，可以看到优先还是从配置文件读取。设置方法如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">System.setProperty(FALLBACK_APP_GROUP_KEY, <span class="string">"app_gropu_name"</span>);</div></pre></td></tr></table></figure><ul><li><code>FALLBACK_APP_GROUP_KEY</code>，私有静态变量，实际得使用 <code>NETFLIX_APP_GROUP</code>。</li><li><code>com.netflix.config.ConfigurationManager</code> 可以从<strong>环境变量</strong>获取到值。</li></ul></li><li><p>调用 <code>Archaius1Utils#initConfig(...)</code> 方法，初始化读取的配置文件对象，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1Utils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Archaius1Utils.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicPropertyFactory <span class="title">initConfig</span><span class="params">(String configName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 配置文件对象</span></div><div class="line">        DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance();</div><div class="line">        <span class="comment">// 配置文件名</span></div><div class="line">        DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty(<span class="string">"eureka.client.props"</span>, configName);</div><div class="line">        <span class="comment">// 配置文件环境</span></div><div class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, <span class="string">"test"</span>);</div><div class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</div><div class="line">        <span class="comment">// 将配置文件加载到环境变量</span></div><div class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></div><div class="line">                            + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>,</div><div class="line">                    eurekaPropsFile);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> configInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从环境变量 <code>eureka.client.props</code>，获取配置文件名。如果未配置，使用参数 <code>configName</code>，即 <code>CommonConstants.CONFIG_FILE_NAME</code> ( <code>&quot;eureka-client&quot;</code> )。</li><li>从环境变量 <code>eureka.environment</code> ( EUREKA_ENVIRONMENT )，获取配置文件环境。</li><li>调用 <code>ConfigurationManager#loadCascadedPropertiesFromResources(...)</code> 方法，读取配置文件到环境变量，首先读取 <code>${eureka.client.props}</code> 对应的配置文件；然后读取 <code>${eureka.client.props}-${eureka.environment}</code> 对应的配置文件。若有相同属性，进行覆盖。</li></ul></li></ul><h2 id="2-5-MyDataCenterInstanceConfig"><a href="#2-5-MyDataCenterInstanceConfig" class="headerlink" title="2.5 MyDataCenterInstanceConfig"></a>2.5 MyDataCenterInstanceConfig</h2><p><code>com.netflix.appinfo.MyDataCenterInstanceConfig</code>，非 AWS 数据中心的 Eureka <strong>应用实例</strong>配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataCenterInstanceConfig</span> <span class="keyword">extends</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(namespace);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace, DataCenterInfo dataCenterInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(namespace, dataCenterInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h2><p>一般情况下，使用 MyDataCenterInstanceConfig 配置 Eureka 应用实例。</p><p>在 Spring-Cloud-Eureka 里，<strong>直接</strong>基于 EurekaInstanceConfig 接口重新实现了配置类，实际逻辑差别不大，在<a href="#">TODO[0007] ：《Spring-Cloud-Eureka-Client》</a>详细解析。</p><h1 id="3-InstanceInfo"><a href="#3-InstanceInfo" class="headerlink" title="3. InstanceInfo"></a>3. InstanceInfo</h1><p><code>com.netflix.appinfo.InstanceInfo</code>，<strong>应用实例</strong>信息。Eureka-Client 向 Eureka-Server <strong>注册</strong>该对象信息。注册成功后，可以被其他 Eureka-Client <strong>发现</strong>。</p><p><strong>本文仅分享 InstanceInfo 的初始化</strong>。InstanceInfo 里和注册发现相关的属性和方法，暂时跳过。</p><p><code>com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider</code>，基于 EurekaInstanceConfig 创建 InstanceInfo 的工厂，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="meta">@Singleton</span></div><div class="line">  <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">InstanceInfo</span>&gt; </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(EurekaConfigBasedInstanceInfoProvider.class);</div><div class="line">  <span class="number">4</span>: </div><div class="line">  <span class="number">5</span>:     <span class="keyword">private</span> <span class="keyword">final</span> EurekaInstanceConfig config;</div><div class="line">  <span class="number">6</span>: </div><div class="line">  <span class="number">7</span>:     <span class="keyword">private</span> InstanceInfo instanceInfo;</div><div class="line">  <span class="number">8</span>: </div><div class="line">  <span class="number">9</span>:     <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</div><div class="line"> <span class="number">10</span>:     <span class="keyword">private</span> VipAddressResolver vipAddressResolver = <span class="keyword">null</span>;</div><div class="line"> <span class="number">11</span>: </div><div class="line"> <span class="number">12</span>:     <span class="meta">@Inject</span></div><div class="line"> <span class="number">13</span>:     <span class="function"><span class="keyword">public</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span><span class="params">(EurekaInstanceConfig config)</span> </span>&#123;</div><div class="line"> <span class="number">14</span>:         <span class="keyword">this</span>.config = config;</div><div class="line"> <span class="number">15</span>:     &#125;</div><div class="line"> <span class="number">16</span>: </div><div class="line"> <span class="number">17</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">18</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InstanceInfo <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">19</span>:         <span class="keyword">if</span> (instanceInfo == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">20</span>:             <span class="comment">// Build the lease information to be passed to the server based on config</span></div><div class="line"> <span class="number">21</span>:             <span class="comment">// 创建 租约信息构建器，并设置属性</span></div><div class="line"> <span class="number">22</span>:             LeaseInfo.Builder leaseInfoBuilder = LeaseInfo.Builder.newBuilder()</div><div class="line"> <span class="number">23</span>:                     .setRenewalIntervalInSecs(config.getLeaseRenewalIntervalInSeconds())</div><div class="line"> <span class="number">24</span>:                     .setDurationInSecs(config.getLeaseExpirationDurationInSeconds());</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// 创建 VIP地址解析器</span></div><div class="line"> <span class="number">27</span>:             <span class="keyword">if</span> (vipAddressResolver == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">28</span>:                 vipAddressResolver = <span class="keyword">new</span> Archaius1VipAddressResolver();</div><div class="line"> <span class="number">29</span>:             &#125;</div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:             <span class="comment">// Builder the instance information to be registered with eureka server</span></div><div class="line"> <span class="number">32</span>:             <span class="comment">// 创建 应用实例信息构建器</span></div><div class="line"> <span class="number">33</span>:             InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver);</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:             <span class="comment">// 应用实例编号</span></div><div class="line"> <span class="number">36</span>:             <span class="comment">// set the appropriate id for the InstanceInfo, falling back to datacenter Id if applicable, else hostname</span></div><div class="line"> <span class="number">37</span>:             String instanceId = config.getInstanceId();</div><div class="line"> <span class="number">38</span>:             DataCenterInfo dataCenterInfo = config.getDataCenterInfo();</div><div class="line"> <span class="number">39</span>:             <span class="keyword">if</span> (instanceId == <span class="keyword">null</span> || instanceId.isEmpty()) &#123;</div><div class="line"> <span class="number">40</span>:                 <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</div><div class="line"> <span class="number">41</span>:                     instanceId = ((UniqueIdentifier) dataCenterInfo).getId();</div><div class="line"> <span class="number">42</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">43</span>:                     instanceId = config.getHostName(<span class="keyword">false</span>);</div><div class="line"> <span class="number">44</span>:                 &#125;</div><div class="line"> <span class="number">45</span>:             &#125;</div><div class="line"> <span class="number">46</span>: </div><div class="line"> <span class="number">47</span>:             <span class="comment">// 获得 主机名</span></div><div class="line"> <span class="number">48</span>:             String defaultAddress;</div><div class="line"> <span class="number">49</span>:             <span class="keyword">if</span> (config <span class="keyword">instanceof</span> RefreshableInstanceConfig) &#123;</div><div class="line"> <span class="number">50</span>:                 <span class="comment">// Refresh AWS data center info, and return up to date address</span></div><div class="line"> <span class="number">51</span>:                 defaultAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(<span class="keyword">false</span>);</div><div class="line"> <span class="number">52</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">53</span>:                 defaultAddress = config.getHostName(<span class="keyword">false</span>);</div><div class="line"> <span class="number">54</span>:             &#125;</div><div class="line"> <span class="number">55</span>:             <span class="comment">// fail safe</span></div><div class="line"> <span class="number">56</span>:             <span class="keyword">if</span> (defaultAddress == <span class="keyword">null</span> || defaultAddress.isEmpty()) &#123;</div><div class="line"> <span class="number">57</span>:                 defaultAddress = config.getIpAddress();</div><div class="line"> <span class="number">58</span>:             &#125;</div><div class="line"> <span class="number">59</span>: </div><div class="line"> <span class="number">60</span>:             <span class="comment">// 设置 应用实例信息构建器 的 属性</span></div><div class="line"> <span class="number">61</span>:             builder.setNamespace(config.getNamespace())</div><div class="line"> <span class="number">62</span>:                     .setInstanceId(instanceId)</div><div class="line"> <span class="number">63</span>:                     .setAppName(config.getAppname())</div><div class="line"> <span class="number">64</span>:                     .setAppGroupName(config.getAppGroupName())</div><div class="line"> <span class="number">65</span>:                     .setDataCenterInfo(config.getDataCenterInfo())</div><div class="line"> <span class="number">66</span>:                     .setIPAddr(config.getIpAddress())</div><div class="line"> <span class="number">67</span>:                     .setHostName(defaultAddress) <span class="comment">// 主机名</span></div><div class="line"> <span class="number">68</span>:                     .setPort(config.getNonSecurePort())</div><div class="line"> <span class="number">69</span>:                     .enablePort(PortType.UNSECURE, config.isNonSecurePortEnabled())</div><div class="line"> <span class="number">70</span>:                     .setSecurePort(config.getSecurePort())</div><div class="line"> <span class="number">71</span>:                     .enablePort(PortType.SECURE, config.getSecurePortEnabled())</div><div class="line"> <span class="number">72</span>:                     .setVIPAddress(config.getVirtualHostName()) <span class="comment">// VIP 地址</span></div><div class="line"> <span class="number">73</span>:                     .setSecureVIPAddress(config.getSecureVirtualHostName())</div><div class="line"> <span class="number">74</span>:                     .setHomePageUrl(config.getHomePageUrlPath(), config.getHomePageUrl())</div><div class="line"> <span class="number">75</span>:                     .setStatusPageUrl(config.getStatusPageUrlPath(), config.getStatusPageUrl())</div><div class="line"> <span class="number">76</span>:                     .setASGName(config.getASGName())</div><div class="line"> <span class="number">77</span>:                     .setHealthCheckUrls(config.getHealthCheckUrlPath(),</div><div class="line"> <span class="number">78</span>:                             config.getHealthCheckUrl(), config.getSecureHealthCheckUrl());</div><div class="line"> <span class="number">79</span>: </div><div class="line"> <span class="number">80</span>:             <span class="comment">// 应用初始化后是否开启</span></div><div class="line"> <span class="number">81</span>:             <span class="comment">// Start off with the STARTING state to avoid traffic</span></div><div class="line"> <span class="number">82</span>:             <span class="keyword">if</span> (!config.isInstanceEnabledOnit()) &#123;</div><div class="line"> <span class="number">83</span>:                 InstanceStatus initialStatus = InstanceStatus.STARTING;</div><div class="line"> <span class="number">84</span>:                 LOG.info(<span class="string">"Setting initial instance status as: "</span> + initialStatus);</div><div class="line"> <span class="number">85</span>:                 builder.setStatus(initialStatus);</div><div class="line"> <span class="number">86</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">87</span>:                 LOG.info(<span class="string">"Setting initial instance status as: &#123;&#125;. This may be too early for the instance to advertise "</span></div><div class="line"> <span class="number">88</span>:                          + <span class="string">"itself as available. You would instead want to control this via a healthcheck handler."</span>,</div><div class="line"> <span class="number">89</span>:                          InstanceStatus.UP);</div><div class="line"> <span class="number">90</span>:             &#125;</div><div class="line"> <span class="number">91</span>: </div><div class="line"> <span class="number">92</span>:             <span class="comment">// 设置 应用实例信息构建器 的 元数据( Metadata )集合</span></div><div class="line"> <span class="number">93</span>:             <span class="comment">// Add any user-specific metadata information</span></div><div class="line"> <span class="number">94</span>:             <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; mapEntry : config.getMetadataMap().entrySet()) &#123;</div><div class="line"> <span class="number">95</span>:                 String key = mapEntry.getKey();</div><div class="line"> <span class="number">96</span>:                 String value = mapEntry.getValue();</div><div class="line"> <span class="number">97</span>:                 builder.add(key, value);</div><div class="line"> <span class="number">98</span>:             &#125;</div><div class="line"> <span class="number">99</span>: </div><div class="line"><span class="number">100</span>:             <span class="comment">// 创建 应用实例信息</span></div><div class="line"><span class="number">101</span>:             instanceInfo = builder.build();</div><div class="line"><span class="number">102</span>: </div><div class="line"><span class="number">103</span>:             <span class="comment">// 设置 应用实例信息 的 租约信息</span></div><div class="line"><span class="number">104</span>:             instanceInfo.setLeaseInfo(leaseInfoBuilder.build());</div><div class="line"><span class="number">105</span>:         &#125;</div><div class="line"><span class="number">106</span>:         <span class="keyword">return</span> instanceInfo;</div><div class="line"><span class="number">107</span>:     &#125;</div><div class="line"><span class="number">108</span>: </div><div class="line"><span class="number">109</span>: &#125;</div></pre></td></tr></table></figure><ul><li>该类实现 <code>javax.inject.Provider</code> 接口，设置 InstanceInfo 的生成工厂。感兴趣的同学，可以点击<a href="http://blog.csdn.net/derekjiang/article/details/7231490" rel="external nofollow noopener noreferrer" target="_blank">《Google-Guice入门介绍》</a>搜索 <strong>Provider</strong> 关键字。目前处于<strong>试验</strong>阶段，未完成。</li><li><code>EurekaConfigBasedInstanceInfoProvider(config)</code> 构造方法，设置生成 InstanceInfo 的 EurekaInstanceConfig 配置。</li><li><p>调用 <code>#get()</code> 方法，根据 EurekaInstanceConfig 创建 InstanceInfo。InstanceInfo 的绝大数属性和 EurekaInstanceConfig 是一致的 。实现代码如下：</p><ul><li>第 21 至 24 行 ：创建租约信息构建器( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/LeaseInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.LeaseInfo.Builder</code></a> )，并设置 <code>renewalIntervalInSecs</code> / <code>durationInSecs</code> 属性。</li><li><p>第 26 至 29 行 ：创建 VIP地址解析器( <code>com.netflix.appinfo.providers.VipAddressResolver</code> )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// VipAddressResolver.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VipAddressResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1VipAddressResolver</span> <span class="keyword">implements</span> <span class="title">VipAddressResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile(<span class="string">"\\$\\&#123;(.*?)\\&#125;"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vipAddressMacro == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        String result = vipAddressMacro;</div><div class="line">        <span class="comment">// 替换表达式</span></div><div class="line">        Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</div><div class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line">            String key = matcher.group(<span class="number">1</span>);</div><div class="line">            String value = DynamicPropertyFactory.getInstance().getStringProperty(key, <span class="string">""</span>).get();</div><div class="line"></div><div class="line">            logger.debug(<span class="string">"att:"</span> + matcher.group());</div><div class="line">            logger.debug(<span class="string">", att key:"</span> + key);</div><div class="line">            logger.debug(<span class="string">", att value:"</span> + value);</div><div class="line">            logger.debug(<span class="string">""</span>);</div><div class="line"></div><div class="line">            result = result.replaceAll(<span class="string">"\\$\\&#123;"</span> + key + <span class="string">"\\&#125;"</span>, value);</div><div class="line">            matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>#resolveDeploymentContextBasedVipAddresses()</code> 方法，将 <strong>VIP地址</strong> 里的 <code>${(.*?)}</code> 查找配置文件里的键值进行替换。例如，<code>${eureka.env}.domain.com</code>，查找配置文件里的键 <code>${eureka.env}</code> 对应值进行替换。TODO[0005]：调试下来，发现 Archaius 已经替换，等到找到答案修改此处。</li></ul></li><li><p>第 32 至 33 行 ：创建应用实例信息构建器( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo.Builder</code></a> )。</p></li><li>第 35 至 45 行 ：获得应用实例编号( <code>instanceId</code> )。</li><li>第 47 至 58 行 ：获得主机名。</li><li>第 60 至 78 行 ：设置应用实例信息构建器的属性。</li><li>第 80 至 90 行 ：应用初始化后是否开启。<ul><li>第 82 至 85 行 ：应用<strong>不开启</strong>，应用实例处于 STARTING 状态。</li><li>第 86 至 90 行 ：应用<strong>开启</strong>，应用实例处于 UP 状态。</li><li><strong>使用应用初始化后不开启</strong>，可以通过调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法改变应用实例状态，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</li></ul></li><li>第 92 至 98 行 ：设置应用实例信息构建器的元数据( Metadata )集合。</li><li>第 100 至 101 行 ：创建应用实例信息( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo</code></a> )。</li><li>第 103 至 104 行 ：设置应用实例信息的租约信息( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo</code></a> )。</li></ul></li></ul><h1 id="4-ApplicationInfoManager"><a href="#4-ApplicationInfoManager" class="headerlink" title="4. ApplicationInfoManager"></a>4. ApplicationInfoManager</h1><p><code>com.netflix.appinfo.ApplicationInfoManager</code>，应用信息管理器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfoManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationInfoManager instance = <span class="keyword">new</span> ApplicationInfoManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, StatusChangeListener&gt; listeners;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例状态匹配</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusMapper instanceStatusMapper;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InstanceInfo instanceInfo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> EurekaInstanceConfig config;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它构造方法</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationInfoManager</span><span class="params">(EurekaInstanceConfig config, InstanceInfo instanceInfo, OptionalArgs optionalArgs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.config = config;</div><div class="line">        <span class="keyword">this</span>.instanceInfo = instanceInfo;</div><div class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ConcurrentHashMap&lt;String, StatusChangeListener&gt;();</div><div class="line">        <span class="keyword">if</span> (optionalArgs != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.instanceStatusMapper = optionalArgs.getInstanceStatusMapper();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.instanceStatusMapper = NO_OP_MAPPER;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Hack to allow for getInstance() to use the DI'd ApplicationInfoManager</span></div><div class="line">        instance = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>listeners</code> 属性，状态变更监听器集合。在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</li><li><p><code>instanceStatusMapper</code> 属性，应用实例状态匹配。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceStatusMapper</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InstanceStatusMapper NO_OP_MAPPER = <span class="keyword">new</span> InstanceStatusMapper() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> InstanceStatus <span class="title">map</span><span class="params">(InstanceStatus prev)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> prev;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><code>#map</code> 方法，根据传入 <code>pre</code> 参数，转换成对应的应用实例状态。</li><li>默认情况下，使用 NO_OP_MAPPER 。一般情况下，不需要关注该类。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-client-init-first/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-client-init-first/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/Eureka/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/Eureka/build-debugging-environment/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2017-10-12T05:36:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">http://www.iocoder.cn/Eureka/build-debugging-environment/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3. Eureka-Server 启动</a><ul><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3.1 MockRemoteEurekaServer</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3.2 Eureka-Server war 包</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3.3 Eureka-Server 直接启动</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">4. Eureka-Client 启动</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Gradle</li><li>JDK</li><li>IntelliJ IDEA</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/Netflix/eureka.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/eureka.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Gradle</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master</code> 分支。</p><h1 id="3-Eureka-Server-启动"><a href="#3-Eureka-Server-启动" class="headerlink" title="3. Eureka-Server 启动"></a>3. Eureka-Server 启动</h1><p>Eureka-Server 启动调试方式，有三种方式，我们来尝试每一种。</p><h2 id="3-1-MockRemoteEurekaServer"><a href="#3-1-MockRemoteEurekaServer" class="headerlink" title="3.1 MockRemoteEurekaServer"></a>3.1 MockRemoteEurekaServer</h2><p><code>com.netflix.eureka.AbstractTester</code>，测试抽象类，有如下实现子类：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_08/01.png" alt=""></p><p>使用任意一个子类的单元测试执行即可执行 Eureka-Server 逻辑的调试，这里以 <code>com.netflix.eureka.resources.ApplicationsResourceTest</code> 作为例子。</p><p>Debug 运行 <code>ApplicationsResourceTest#testFullAppsGetJson()</code> 单元测试。在方法执行前，<code>ApplicationsResourceTest#setUp()</code> 会运行，初始化 Eureka-Server <strong>模拟环境</strong>，例如：<br><code>com.netflix.eureka.mock.MockRemoteEurekaServer</code> ( 模拟 Eureka-Server )。</p><p>因为是<strong>模拟环境</strong>，对 Eureka-Server 的操作不是 Eureka-Client 请求 Eureka-Server 的方式，而是直接调用单元测试对应的方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationsResourceTest.java</span></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFullAppsGetJson</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   Response response = applicationsResource.getContainers(</div><div class="line">           Version.V2.name(),</div><div class="line">           MediaType.APPLICATION_JSON,</div><div class="line">           <span class="keyword">null</span>, <span class="comment">// encoding</span></div><div class="line">           EurekaAccept.full.name(),</div><div class="line">           <span class="keyword">null</span>,  <span class="comment">// uriInfo</span></div><div class="line">           <span class="keyword">null</span>  <span class="comment">// remote regions</span></div><div class="line">   );</div><div class="line"></div><div class="line">   String json = String.valueOf(response.getEntity());</div><div class="line">   DecoderWrapper decoder = CodecWrappers.getDecoder(CodecWrappers.LegacyJacksonJson.class);</div><div class="line"></div><div class="line">   Applications decoded = decoder.decode(json, Applications.class);</div><div class="line">   <span class="comment">// test per app as the full apps list include the mock server that is not part of the test apps</span></div><div class="line">   <span class="keyword">for</span> (Application application : testApplications.getRegisteredApplications()) &#123;</div><div class="line">       Application decodedApp = decoded.getRegisteredApplications(application.getName());</div><div class="line">       assertThat(EurekaEntityComparators.equal(application, decodedApp), is(<span class="keyword">true</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>直接调用 <code>ApplicationsResource#getContainers(...)</code> 方法。</li></ul><p><strong>总结</strong>：这种方式，简单粗暴，容易上手。当然，它的缺点是<strong>模拟</strong>。刚开始调试 Eureka-Server 可以尝试这种方式。</p><h2 id="3-2-Eureka-Server-war-包"><a href="#3-2-Eureka-Server-war-包" class="headerlink" title="3.2 Eureka-Server war 包"></a>3.2 Eureka-Server war 包</h2><p>第一步，编译 Eureka-Server war 包。该步骤可能消耗漫长的时间，如果执行失败，请不断重试。命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> eureka</div><div class="line">./gradlew clean build</div></pre></td></tr></table></figure><p>第二步，Debug 运行<code>com.netflix.eureka.resources.EurekaClientServerRestIntegrationTest</code> 任意单元测试方法。</p><p><strong>总结</strong>：这种方式，编译的过程比较痛苦，不排除失败的可能性。每次增加对代码的注册后，都需要重新编译打包。因此不建议采用。那咋办呢？见第三种。良心如博主，赶紧关注博主的微信公众号：【<strong>芋道源码</strong>】。</p><h2 id="3-3-Eureka-Server-直接启动"><a href="#3-3-Eureka-Server-直接启动" class="headerlink" title="3.3 Eureka-Server 直接启动"></a>3.3 Eureka-Server 直接启动</h2><p>第一步，修改 <code>EurekaClientServerRestIntegrationTest#startServer()</code> 方法，解决第二种方式使用 war 包运行每次修改代码都需要重新编译的问题，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaClientServerRestIntegrationTest.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</div><div class="line"></div><div class="line">   <span class="comment">// TODO Thread.currentThread().getContextClassLoader() 获取不到路径，先暂时这样；</span></div><div class="line">   WebAppContext webAppCtx = <span class="keyword">new</span> WebAppContext(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/webapp"</span>).getAbsolutePath(), <span class="string">"/"</span>);</div><div class="line">   webAppCtx.setDescriptor(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/webapp/WEB-INF/web.xml"</span>).getAbsolutePath());</div><div class="line">   webAppCtx.setResourceBase(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/resources"</span>).getAbsolutePath());</div><div class="line">   webAppCtx.setClassLoader(Thread.currentThread().getContextClassLoader());</div><div class="line">   server.setHandler(webAppCtx);</div><div class="line">   server.start();</div><div class="line"></div><div class="line">   eurekaServiceUrl = <span class="string">"http://localhost:8080/v2"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>笔者不太熟悉 Gradle 的打包方式，使用 <code>Thread.currentThread().getContextClassLoader().getResource()</code> 方法，一直无法拿到路径，有知道的同学麻烦告知下。</li></ul><p>第二步，Debug 运行<code>com.netflix.eureka.resources.EurekaClientServerRestIntegrationTest</code> 任意单元测试方法。TODO[0003]：Thread.currentThread().getContextClassLoader() 获取不到路径，先暂时这样；</p><p><strong>总结</strong>：这种方式，完美。建议使用该方式调试。</p><h1 id="4-Eureka-Client-启动"><a href="#4-Eureka-Client-启动" class="headerlink" title="4. Eureka-Client 启动"></a>4. Eureka-Client 启动</h1><p>我们以 <code>com.netflix.eureka.ExampleEurekaClient</code> 为例子。</p><p>第一步，在 <code>EurekaClientServerRestIntegrationTest#setUp()</code> 方法末尾添加 <code>Thread.sleep(Long.MAX_VALUE)</code> 代码。</p><p>第二步，按照<a href="#">「 3.3 Eureka-Server 直接启动」</a>方法启动 Eureka-Server。</p><p>第三步，将 <code>EurekaClientServerRestIntegrationTest#injectEurekaConfiguration</code> 复制到 ExampleEurekaClient 类里。</p><p>第四步，在 <code>ExampleEurekaClient#main()</code> 方法的第一行，添加 <code>injectEurekaConfiguration()</code> 代码。</p><p>第五步，Debug 运行 <code>ExampleEurekaClient#main()</code> 方法。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_08/02.png" alt=""></p><p><code>eureka-examples</code> 模块还提供别的例子，可以逐个调试。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文写的，相对比较简洁，如果有任何疑问，可以给我公众号留言。</p><p>下一篇更新？恩，我还没想好，整理<a href="#">《Eureka 源码解析》</a>整个系列的目录ing。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/build-debugging-environment/&quot;&gt;http://www.iocoder.cn/Eureka/build-debugging-environment/&lt;/a
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 项目结构简介</title>
    <link href="http://www.iocoder.cn/Eureka/project-structure/"/>
    <id>http://www.iocoder.cn/Eureka/project-structure/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2017-10-17T14:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/project-structure/">http://www.iocoder.cn/Eureka/project-structure/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong>  </p><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">1. 概述</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">1.1 简介</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">1.2 项目结构</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">2. eureka-client</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">2.1 eureka-client-archaius2</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">2.2 eureka-client-jersey2</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">3. eureka-core</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">3.1 eureka-core-jersey2</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">4. eureka-resources</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">5. eureka-server</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">5.1 eureka-server-governator</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">6. eureka-examples</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">7. eureka-test-utils</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka 的项目结构</strong>，附带部分简介和原理。</p><p>Eureka 项目地址：<a href="https://github.com/Netflix/eureka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/eureka</a></p><ul><li>请注意下，不是 <code>spring-cloud-netflix-eureka-client</code> / <code>spring-cloud-netflix-eureka-server</code> 。</li><li>笔者 Fork 的代码仓库 <a href="https://github.com/YunaiV/eureka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/eureka</a>，会随着这个系列的文章逐渐增加<strong>中文注释</strong>，可以先 Star 一下。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Eureka 是 <a href="https://zh.wikipedia.org/wiki/Netflix" rel="external nofollow noopener noreferrer" target="_blank">Netflix</a> 开源的服务注册发现组件，分成 Client 和 Server 两部分。简化架构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/01.png" alt=""></p><ul><li>Eureka-Server ：通过 REST 协议暴露服务，提供应用服务的注册和发现的功能。</li><li>Application Provider ：应用服务提供者，内嵌 Eureka-Client ，通过它向 Eureka-Server 注册自身服务。</li><li>Application Consumer ：应用服务消费者，内嵌 Eureka-Client ，通过它从 Eureka-Server 获取服务列表。</li><li>请注意下，Application Provider 和 Application Consumer 强调扮演的角色，实际可以在同一 JVM 进程，即是服务的提供者，又是服务的消费者。</li></ul><h2 id="1-2-项目结构"><a href="#1-2-项目结构" class="headerlink" title="1.2 项目结构"></a>1.2 项目结构</h2><p>Eureka 项目结构如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/02.png" alt=""></p><p>❓❓❓不只 Eureka-Client 、 Eureka-Server ❓❓❓</p><p>淡定。我们一起来了解每个模块的功能和结构。</p><h1 id="2-eureka-client"><a href="#2-eureka-client" class="headerlink" title="2. eureka-client"></a>2. <code>eureka-client</code></h1><p><code>eureka-client</code> 模块为 Eureka-Client 的功能实现：</p><ul><li><code>com.netflix.appinfo</code> 包：Eureka-Client 的应用配置。此处的应用指的就是上文提到的 Application Provider，Application Consumer。</li><li><p><code>com.netflix.discovery</code> 包：Eureka-Client 的注册与发现相关功能。</p><ul><li><code>com.netflix.discovery.DiscoveryClient</code> 类：注册发现客户端实现类。</li><li><p><code>com.netflix.discovery.guice</code> 包：Eureka <strong>计划</strong>使用 <a href="https://github.com/google/guice" rel="external nofollow noopener noreferrer" target="_blank">Google Guice</a> 实现依赖注入，参见本文「5.1 <code>eureka-server-governator</code>」。一方面 Guice 是轻量级的依赖注入框架，另一方面避免和业务代码的 Spring 版本冲突。</p><blockquote><p>Guice (pronounced ‘juice’) is a lightweight dependency injection framework for Java 6 and above, brought to you by Google. </p></blockquote></li><li><p><code>com.netflix.discovery.converters</code> 包：Eureka 内部传输数据编解码转换器，支持 XML / JSON 格式。</p></li><li><code>com.netflix.discovery.endpoint</code> 包：目前该包正在重构，和下文的 <code>com.netflix.discovery.shared.dns</code> 和 <code>com.netflix.discovery.shared.resolver</code> 用途相近。</li><li><code>com.netflix.disvoery.provider</code> 包：目前仅有 DiscoveryJerseyProvider 类。该类声明自定义的 Jersey 请求和响应的序列化和反序列化实现。</li><li><code>com.netflix.disvoery.providers</code> 包：目前仅有 DefaultEurekaClientConfigProvider 类。该类实现 <code>javax.inject.Provider</code> 接口，设置 EurekaClientConfig ( Eureka 客户端配置 ) 的生成工厂。感兴趣的同学，可以点击<a href="http://blog.csdn.net/derekjiang/article/details/7231490" rel="external nofollow noopener noreferrer" target="_blank">《Google-Guice入门介绍》</a>搜索 <strong>Provider</strong> 关键字。</li><li><p><code>com.netflix.discovery.shared</code> 包：Eureka-Client 和 Eureka-Server 注册发现相关的共享重用的代码。下文你会看到，Eureka-Server 通过 <code>eureka-core</code> 模块实现，<code>eureka-core</code> 依赖 <code>eureka-client</code>。<strong>粗一看，我们会感觉 What ？Eureka-Server 代码依赖 Eureka-Client 代码</strong>！？这个和 Eureka-Server 多节点注册信息 P2P 同步的实现有关。一个 Eureka-Server 收到 Eureka-Client 注册请求后，Eureka-Server 会自己模拟 Eureka-Client 发送注册请求到其它的 Eureka-Server，因此部分实现代码就使用到了这个包，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 详细解析。</p><ul><li><code>com.netflix.discovery.shared.transport</code> 包：Eureka-Client 对 Eureka-Server RESTful 的 HTTP 客户端，基于 Jersey Client 实现。Jersey 在下文「2.1 <code>eureka-client-jersey2</code>」详细解析。</li><li><code>com.netflix.discovery.shared.dns</code> 包 ：DNS 解析器。</li><li><code>com.netflix.discovery.shared.resolver</code> 包：Eureka Endpoint 解析器。在 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》</a> 有详细解析。</li></ul></li><li><p><code>com.netflix.discovery.util</code> 包 ：工具类。</p></li></ul></li></ul><h2 id="2-1-eureka-client-archaius2"><a href="#2-1-eureka-client-archaius2" class="headerlink" title="2.1 eureka-client-archaius2"></a>2.1 <code>eureka-client-archaius2</code></h2><p><a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Archaius</a> 是 Netflix 开源的配置管理组件。</p><p>Archaius 目前有 1.x 和 2.x 版本，默认情况下，Eureka 使用 1.x 版本。从官方文档上来看，2.x 版本仍然在开发中。</p><blockquote><p>FROM <a href="https://github.com/YunaiV/eureka/blob/103e0875b08c9ff4abb85eaab672df2041b63558/eureka-client-archaius2/README.md" rel="external nofollow noopener noreferrer" target="_blank">eureka-client-archaius2 README</a><br>This is a version of eureka-client that has been ported to use Archaius 2.x as the backing configuration system. Please note that this client is still work in progress. This client is also only java8 compatible (as Archaius 2.x is only java8 compatible).</p></blockquote><h2 id="2-2-eureka-client-jersey2"><a href="#2-2-eureka-client-jersey2" class="headerlink" title="2.2 eureka-client-jersey2"></a>2.2 <code>eureka-client-jersey2</code></h2><p><a href="https://github.com/jersey/jersey" rel="external nofollow noopener noreferrer" target="_blank">Jersey</a> 是 JAX-RS（JSR311）开源参考实现，用于构建 RESTful Web Service。</p><ul><li>Eureka-Server 使用 <a href="https://github.com/jersey/jersey/tree/9fdb7e386dc56b33f569ab198caf818d7a18525d/core-server/" rel="external nofollow noopener noreferrer" target="_blank">Jersey Server</a> 创建 RESTful Server 。</li><li>Eureka-Client 使用 <a href="https://github.com/jersey/jersey/tree/9fdb7e386dc56b33f569ab198caf818d7a18525d/core-client/" rel="external nofollow noopener noreferrer" target="_blank">Jersey Client</a> 请求 Eureka-Server 。</li></ul><p>Jersey 目前有 1.x 和 2.x 版本，默认情况下，Eureka 使用 1.x 版本。从官方文档上来看，2.x 版本由社区实现，Netflix 自己暂未使用。</p><blockquote><p>FROM <a href="https://github.com/Netflix/eureka/tree/30a85dc31be1c9d399e4e6ec5150759fb8777edf/eureka-client-jersey2/" rel="external nofollow noopener noreferrer" target="_blank">eureka-client-jersey2 README</a><br>Please note that this jersey2 compatible Eureka client (eureka-client-jersey2) is created and maintained by the community. Netflix does not currently use this library internally.</p></blockquote><h1 id="3-eureka-core"><a href="#3-eureka-core" class="headerlink" title="3. eureka-core"></a>3. <code>eureka-core</code></h1><p><code>eureka-core</code> 模块为 Eureka-Server 的功能实现：</p><ul><li><code>com.netflix.eureka.EurekaBootStrap</code> 类：Eureka-Server 启动类。</li><li><code>com.netflix.eureka.aws</code> 包：与亚马逊 AWS 服务相关的类。由于笔者和大多数读者都对 AWS 暂不了解，本系列<a href="#">《Eureka 源码解析》</a>会跳过和 AWS 相关的代码。</li><li><code>com.netflix.eureka.cluster</code> 包：Eureka-Server 集群数据复制相关的代码。</li><li><code>com.netflix.eureka.lease</code> 包：应用注册后的<strong>租约</strong>管理( 注册 / 取消 / 续期 / 过期 )。</li><li><code>com.netflix.eureka.resousrces</code> 包：资源，基于 Jersey Server 实现，相当于 Spring MVC 的控制层代码。</li><li><code>com.netflix.eureka.transport</code> 包：Eureka-Server 对 Eureka-Server 的 RESTful HTTP 客户端，基于 <code>com.netflix.discovery.shared.transport</code> 封装实现。</li><li><code>com.netflix.eureka.util</code> 包：工具类。</li></ul><h2 id="3-1-eureka-core-jersey2"><a href="#3-1-eureka-core-jersey2" class="headerlink" title="3.1 eureka-core-jersey2"></a>3.1 <code>eureka-core-jersey2</code></h2><p>参见本文「2.1 <code>eureka-client-jersey2</code>」。</p><h1 id="4-eureka-resources"><a href="#4-eureka-resources" class="headerlink" title="4. eureka-resources"></a>4. <code>eureka-resources</code></h1><p><code>eureka-resources</code> 模块，使用 JSP 实现 Eureka-Server 的运维后台界面。项目结构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/03.png" alt=""></p><h1 id="5-eureka-server"><a href="#5-eureka-server" class="headerlink" title="5. eureka-server"></a>5. <code>eureka-server</code></h1><p><code>eureka-server</code> 模块，将 <code>eureka-client</code> + <code>eureka-core</code> + <code>eureka-resources</code> 三者打包成 Eureka-Server 的 <code>war</code> 包。项目结构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/04.png" alt=""></p><h2 id="5-1-eureka-server-governator"><a href="#5-1-eureka-server-governator" class="headerlink" title="5.1 eureka-server-governator"></a>5.1 <code>eureka-server-governator</code></h2><p><code>eureka-server-governator</code> 模块，使用 <a href="https://github.com/Netflix/governator" rel="external nofollow noopener noreferrer" target="_blank">Netflix Governator</a> 管理 Eureka-Server 的生命周期。</p><blockquote><p>FROM <a href="http://www.infoq.com/cn/news/2013/02/netflix-opensource" rel="external nofollow noopener noreferrer" target="_blank">http://www.infoq.com/cn/news/2013/02/netflix-opensource</a><br><strong>Governator</strong>，一款对 Google Guice 进行扩展的类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能。</p></blockquote><p>目前该模块正在实现阶段。</p><blockquote><p>FROM <a href="https://github.com/Netflix/eureka/tree/30a85dc31be1c9d399e4e6ec5150759fb8777edf/eureka-server-governator/" rel="external nofollow noopener noreferrer" target="_blank">eureka-server-governator README</a><br>This server build is still experimental.</p></blockquote><h1 id="6-eureka-examples"><a href="#6-eureka-examples" class="headerlink" title="6. eureka-examples"></a>6. <code>eureka-examples</code></h1><p><code>eureka-examples</code> 模块，提供 Eureka-Client 使用例子。</p><h1 id="7-eureka-test-utils"><a href="#7-eureka-test-utils" class="headerlink" title="7. eureka-test-utils"></a>7. <code>eureka-test-utils</code></h1><p><code>eureka-test-utils</code> 模块，提供 Eureka 单元测试工具类。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>第一篇 Eureka 的文章，如果有地方写的不正确，还望指出，谢谢。</p><p>下一篇 Eureka 调试环境搭建。</p><p>更多 Eureka 内容，推荐阅读如下文章：</p><ul><li>携程 —— <a href="http://techshow.ctrip.com/archives/1699.html" rel="external nofollow noopener noreferrer" target="_blank">《深度剖析服务发现组件Netflix Eureka》</a></li><li>程序员DD —— <a href="http://blog.didispace.com/springcloud-sourcecode-eureka/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud源码分析（一）Eureka》</a></li><li>王鸿飞 —— <a href="http://blog.spring-cloud.io/blog/sc-eureka.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix Eureka源码导读与原理分析》</a></li><li>许进 —— <a href="http://xujin.org/sc/sc-netflix-eureka/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix之Eureka上篇》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/project-structure/&quot;&gt;http://www.iocoder.cn/Eureka/project-structure/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
</feed>
