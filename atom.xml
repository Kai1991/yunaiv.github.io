<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-10-12T07:34:35.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Eureka 源码解析 —— 任务批处理</title>
    <link href="http://www.iocoder.cn/Eureka/batch-tasks/"/>
    <id>http://www.iocoder.cn/Eureka/batch-tasks/</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2017-10-12T07:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/batch-tasks/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">2. 整体流程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">3. 任务处理器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4. 创建任务分发器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.1 批量任务执行分发器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.2 单任务执行分发器</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">5. 创建任务接收执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6. 创建任务执行器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.1 创建批量任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.2 创建单任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.3 工作线程抽象类</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">7. 网络通信整形器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">8. 任务接收执行器【处理任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">9. 任务接收线程【调度任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10. 任务执行器【执行任务】</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.1 批量任务工作线程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.2 单任务工作线程</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>任务批处理</strong>。Eureka-Server 集群通过任务批处理同步应用实例注册实例，所以本文也是为 Eureka-Server 集群同步的分享做铺垫。</p><p>本文涉及类在 <code>com.netflix.eureka.util.batcher</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png" alt=""></p><ul><li>紫色部分 —— 任务分发器</li><li>蓝色部分 —— 任务接收器</li><li>红色部分 —— 任务执行器</li><li>绿色部分 —— 任务处理器</li><li>黄色部分 —— 任务持有者( 任务 )</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 整体流程</h1><p>任务执行的整体流程如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png" alt=""></p><ul><li><p>细箭头 —— 任务执行经历的操作</p></li><li><p>粗箭头 —— 任务队列流转的方向</p></li><li><p><strong>不同于</strong>一般情况下，任务提交了<strong>立即</strong>同步或异步执行，任务的执行拆分了<strong>三层队列</strong>：</p><ul><li><p>第一层，接收队列( <code>acceptorQueue</code> )，重新处理队列( <code>reprocessQueue</code> )。</p><ul><li>蓝线：分发器在收到任务执行请求后，提交到接收队列，<strong>任务实际未执行</strong>。</li><li>黄线：执行器的工作线程处理任务失败，将符合条件( 见 <a href="#">「3. 任务处理器」</a> )的失败任务提交到重新执行队列。</li></ul></li><li><p>第二层，待执行队列( <code>processingOrder</code> )</p><ul><li>粉线：接收线程( Runner )将重新执行队列，接收队列提交到待执行队列。</li></ul></li><li><p>第三层，工作队列( <code>workQueue</code> )</p><ul><li>粉线：接收线程( Runner )将待执行队列的任务根据参数( <code>maxBatchingSize</code> )将任务合并成<strong>批量任务</strong>，调度( 提交 )到工作队列。</li><li>黄线：执行器的工作线程<strong>池</strong>，一个工作线程可以拉取一个<strong>批量任务</strong>进行执行。</li></ul></li></ul></li><li><p><strong>三层队列的好处</strong>：</p><ul><li>接收队列，避免处理任务的阻塞等待。</li><li>接收线程( Runner )合并任务，将相同任务编号( <strong>是的，任务是带有编号的</strong> )的任务合并，只执行一次。</li><li>Eureka-Server 为集群同步提供批量操作<strong>多个</strong>应用实例的<strong>接口</strong>，一个<strong>批量任务</strong>可以一次调度接口完成，避免多次调用的开销。当然，这样做的前提是合并任务，这也导致 Eureka-Server 集群之间对应用实例的注册和下线带来更大的延迟。<strong>毕竟，Eureka 是在 CAP 之间，选择了 AP</strong>。</li></ul></li></ul><h1>3. 任务处理器</h1><p><code>com.netflix.eureka.util.batcher.TaskProcessor</code> ，任务处理器<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * A processed task/task list ends up in one of the following states:</span></div><div class="line"><span class="comment">     * &lt;ul&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> Success&#125; processing finished successfully&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> TransientError&#125; processing failed, but shall be retried later&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> PermanentError&#125; processing failed, and is non recoverable&lt;/li&gt;</span></div><div class="line"><span class="comment">     * &lt;/ul&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> ProcessingResult &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 成功</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Success,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 拥挤错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Congestion,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 瞬时错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        TransientError,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 永久错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        PermanentError</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理单任务</span></div><div class="line"><span class="comment">     * In non-batched mode a single task is processed at a time.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(T task)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理批量任务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * For batched mode a collection of tasks is run at a time. The result is provided for the aggregated result,</span></div><div class="line"><span class="comment">     * and all tasks are handled in the same way according to what is returned (for example are rescheduled, if the</span></div><div class="line"><span class="comment">     * error is transient).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(List&lt;T&gt; tasks)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>ProcessingResult ，处理任务结果。<ul><li><code>Success</code> ，成功。</li><li><code>Congestion</code> ，拥挤错误，<strong>任务将会被重试</strong>。例如，请求被限流。</li><li><code>TransientError</code> ，瞬时错误，<strong>任务将会被重试</strong>。例如，网络请求超时。</li><li><code>PermanentError</code> ，永久错误，<strong>任务将会被丢弃</strong>。例如，执行时发生程序异常。</li></ul></li><li><code>#process(task)</code> 方法，处理单任务。</li><li><code>#process(tasks)</code> 方法，处理批量任务。</li></ul><h1>4. 创建任务分发器</h1><p><code>com.netflix.eureka.util.batcher.TaskDispatcher</code> ，任务分发器<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskDispatcher</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#process(...)</code> 方法，提交任务编号，任务，任务过期时间给任务分发器处理。</li></ul><p><code>com.netflix.eureka.util.batcher.TaskDispatchers</code> ，任务分发器<strong>工厂类</strong>，用于创建任务分发器。其内部提供两种任务分发器的实现：</p><ul><li><strong>批量任务</strong>执行的分发器，用于 Eureka-Server 集群注册信息的同步任务。</li><li><strong>单任务</strong>执行的分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( Autoscaling Group ) 同步状态。虽然本系列暂时对 AWS 相关的不做解析，从工具类的角度来说，本文会对该分发器进行分享。</li></ul><p><code>com.netflix.eureka.cluster.ReplicationTaskProcessor</code> ，实现 TaskDispatcher ，Eureka-Server 集群任务处理器。感兴趣的同学，可以点击<a href="https://github.com/YunaiV/eureka/blob/6e1b694898aa2f4c155936420c2ce5850f142742/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>自己研究，我们将在 <a href="TODO%5B0021%5D%EF%BC%9A%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5">TODO[0021]：集群同步</a> 详细解析。</p><h2>4.1 批量任务执行分发器</h2><p>调用 <code>TaskDispatchers#createBatchingTaskDispatcher(...)</code> 方法，创建<strong>批量任务</strong>执行的分发器，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatchers.java</span></div><div class="line">  <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">  2:  * 创建批量任务执行的分发器</span></div><div class="line"><span class="comment">  3:  *</span></div><div class="line"><span class="comment">  4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment">  5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment">  6:  * <span class="doctag">@param</span> workloadSize 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">  7:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">  8:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">  9:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 10:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment"> 11:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment"> 12:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment"> 13:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment"> 14:  * <span class="doctag">@return</span> 批量任务执行的分发器</span></div><div class="line"><span class="comment"> 15:  */</span></div><div class="line"> <span class="number">16</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">17</span>:                                                                          <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">18</span>:                                                                          <span class="keyword">int</span> workloadSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">19</span>:                                                                          <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">20</span>:                                                                          <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">21</span>:                                                                          <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">22</span>:                                                                          <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">23</span>:                                                                          TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"> <span class="number">24</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"> <span class="number">25</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"> <span class="number">26</span>:             id, maxBufferSize, workloadSize, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"> <span class="number">27</span>:     );</div><div class="line"> <span class="number">28</span>:     <span class="comment">// 创建 批量任务执行器</span></div><div class="line"> <span class="number">29</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.batchExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"> <span class="number">30</span>:     <span class="comment">// 创建 批量任务分发器</span></div><div class="line"> <span class="number">31</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"> <span class="number">32</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">33</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"> <span class="number">34</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"> <span class="number">35</span>:         &#125;</div><div class="line"> <span class="number">36</span>: </div><div class="line"> <span class="number">37</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">38</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">39</span>:             acceptorExecutor.shutdown();</div><div class="line"> <span class="number">40</span>:             taskExecutor.shutdown();</div><div class="line"> <span class="number">41</span>:         &#125;</div><div class="line"> <span class="number">42</span>:     &#125;;</div><div class="line"> <span class="number">43</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 1 至 23 行 ：方法参数。比较多哈，请耐心理解。<ul><li><code>workloadSize</code> 参数，单个批量任务包含任务最大数量。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 24 至 27 行 ：创建任务<strong>接收</strong>执行器。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>批量</strong>任务执行器。在 <a href="#">「6.1 创建批量任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>批量</strong>任务分发器。<ul><li>第 32 至 35 行 ：<code>#process()</code> 方法的实现，调用 <code>AcceptorExecutor#process(...)</code> 方法，提交 [ 任务编号 , 任务 , 任务过期时间 ] 给任务分发器处理。</li></ul></li></ul><h2>4.2 单任务执行分发器</h2><p>调用 <code>TaskDispatchers#createNonBatchingTaskDispatcher(...)</code> 方法，创建<strong>单任务</strong>执行的分发器，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 2:  * 创建单任务执行的分发器</span></div><div class="line"><span class="comment"> 3:  *</span></div><div class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment"> 6:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment"> 7:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment"> 8:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 9:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">10:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment">11:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">12:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">13:  * <span class="doctag">@return</span> 单任务执行的分发器</span></div><div class="line"><span class="comment">14:  */</span></div><div class="line"><span class="number">15</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createNonBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">16</span>:                                                                             <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">17</span>:                                                                             <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">18</span>:                                                                             <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">19</span>:                                                                             <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">20</span>:                                                                             <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">21</span>:                                                                             TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"><span class="number">24</span>:             id, maxBufferSize, <span class="comment">/* workloadSize = 1 */</span><span class="number">1</span>, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"><span class="number">25</span>:     );</div><div class="line"><span class="number">26</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.singleItemExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"><span class="number">27</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"><span class="number">28</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">29</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"><span class="number">30</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">34</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">35</span>:             acceptorExecutor.shutdown();</div><div class="line"><span class="number">36</span>:             taskExecutor.shutdown();</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 1 至 21 行 ：方法参数。比较多哈，请耐心理解。<ul><li><s><code>workloadSize</code> 参数</s>，相比 <code>#createBatchingTaskDispatcher(...)</code> 少这个参数。<strong>在第 24 行，你会发现该参数传递给 AcceptorExecutor 使用 1 噢</strong>。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 21 至 25 行 ：创建任务<strong>接收</strong>执行器。和 <code>#createBatchingTaskDispatcher(...)</code> 只差 <code>workloadSize = 1</code> 参数。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>单</strong>任务执行器。<strong>和 <code>#createBatchingTaskDispatcher(...)</code> 差别很大</strong>。<a href="#">「6.2 创建单任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>单</strong>任务分发器。和 <code>#createBatchingTaskDispatcher(...)</code> 一样。</li></ul><h1>5. 创建任务接收执行器</h1><p><code>com.netflix.eureka.util.batcher.AcceptorExecutor</code> ，任务接收执行器。创建构造方法代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">AcceptorExecutor</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AcceptorExecutor.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:      * 待执行队列最大数量</span></div><div class="line"><span class="comment"> 7:      * &#123;<span class="doctag">@link</span> #processingOrder&#125;</span></div><div class="line"><span class="comment"> 8:      */</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBufferSize;</div><div class="line"><span class="number">10</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">11:      * 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">12:      */</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBatchingSize;</div><div class="line"><span class="number">14</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">15:      * 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">16:      */</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBatchingDelay;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">20:      * 是否关闭</span></div><div class="line"><span class="comment">21:      */</span></div><div class="line"><span class="number">22</span>:     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">23</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">24:      * 接收任务队列</span></div><div class="line"><span class="comment">25:      */</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; acceptorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">27</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">28:      * 重新执行任务队列</span></div><div class="line"><span class="comment">29:      */</span></div><div class="line"><span class="number">30</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;TaskHolder&lt;ID, T&gt;&gt; reprocessQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</div><div class="line"><span class="number">31</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">32:      * 接收任务线程</span></div><div class="line"><span class="comment">33:      */</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Thread acceptorThread;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">37:      * 待执行任务映射</span></div><div class="line"><span class="comment">38:      */</span></div><div class="line"><span class="number">39</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ID, TaskHolder&lt;ID, T&gt;&gt; pendingTasks = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="number">40</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">41:      * 待执行队列</span></div><div class="line"><span class="comment">42:      */</span></div><div class="line"><span class="number">43</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ID&gt; processingOrder = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">46:      * 单任务工作请求信号量</span></div><div class="line"><span class="comment">47:      */</span></div><div class="line"><span class="number">48</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore singleItemWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">49</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">50:      * 单任务工作队列</span></div><div class="line"><span class="comment">51:      */</span></div><div class="line"><span class="number">52</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; singleItemWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">53</span>: </div><div class="line"><span class="number">54</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">55:      * 批量任务工作请求信号量</span></div><div class="line"><span class="comment">56:      */</span></div><div class="line"><span class="number">57</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">58</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">59:      * 批量任务工作队列</span></div><div class="line"><span class="comment">60:      */</span></div><div class="line"><span class="number">61</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">62</span>: </div><div class="line"><span class="number">63</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">64:      * 网络通信整形器</span></div><div class="line"><span class="comment">65:      */</span></div><div class="line"><span class="number">66</span>:     <span class="keyword">private</span> <span class="keyword">final</span> TrafficShaper trafficShaper;</div><div class="line"><span class="number">67</span>: </div><div class="line"><span class="number">68</span>:     AcceptorExecutor(String id,</div><div class="line"><span class="number">69</span>:                      <span class="keyword">int</span> maxBufferSize,</div><div class="line"><span class="number">70</span>:                      <span class="keyword">int</span> maxBatchingSize,</div><div class="line"><span class="number">71</span>:                      <span class="keyword">long</span> maxBatchingDelay,</div><div class="line"><span class="number">72</span>:                      <span class="keyword">long</span> congestionRetryDelayMs,</div><div class="line"><span class="number">73</span>:                      <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line"><span class="number">74</span>:         <span class="keyword">this</span>.maxBufferSize = maxBufferSize;</div><div class="line"><span class="number">75</span>:         <span class="keyword">this</span>.maxBatchingSize = maxBatchingSize;</div><div class="line"><span class="number">76</span>:         <span class="keyword">this</span>.maxBatchingDelay = maxBatchingDelay;</div><div class="line"><span class="number">77</span>: </div><div class="line"><span class="number">78</span>:         <span class="comment">// 创建 网络通信整形器</span></div><div class="line"><span class="number">79</span>:         <span class="keyword">this</span>.trafficShaper = <span class="keyword">new</span> TrafficShaper(congestionRetryDelayMs, networkFailureRetryMs);</div><div class="line"><span class="number">80</span>: </div><div class="line"><span class="number">81</span>:         <span class="comment">// 创建 接收任务线程</span></div><div class="line"><span class="number">82</span>:         ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line"><span class="number">83</span>:         <span class="keyword">this</span>.acceptorThread = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> AcceptorRunner(), <span class="string">"TaskAcceptor-"</span> + id);</div><div class="line"><span class="number">84</span>:         <span class="keyword">this</span>.acceptorThread.setDaemon(<span class="keyword">true</span>);</div><div class="line"><span class="number">85</span>:         <span class="keyword">this</span>.acceptorThread.start();</div><div class="line"><span class="number">86</span>: </div><div class="line"><span class="number">87</span>:         <span class="comment">// TODO （省略代码）芋艿：监控相关，暂时无视</span></div><div class="line"><span class="number">88</span>:     &#125;</div><div class="line"><span class="number">89</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 5 至 61 行 ：属性。比较多哈，请耐心理解。<ul><li>眼尖如你，会发现 AcceptorExecutor 即存在单任务工作队列( <code>singleItemWorkQueue</code> )，又存在批量任务工作队列( <code>batchWorkQueue</code> ) ，在 <a href="#">「9. 任务接收线程【调度任务】」</a> 会解答这个疑惑。</li></ul></li><li>第 78 至 79 行 ：创建网络通信整形器。在 <a href="#">「7. 网络通信整形器」</a> 详细解析。</li><li>第 81 至 85 行 ：<strong>创建接收任务线程</strong>。</li></ul><h1>6. 创建任务执行器</h1><p><code>com.netflix.eureka.util.batcher.TaskExecutors</code> ，任务执行器。<strong>其内部提供创建单任务和批量任务执行器的两种方法</strong>。TaskExecutors 构造方法如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutors</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TaskExecutors.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 工作线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; workerThreads;</div><div class="line"></div><div class="line">    TaskExecutors(WorkerRunnableFactory&lt;ID, T&gt; workerRunnableFactory, <span class="keyword">int</span> workerCount, AtomicBoolean isShutdown) &#123;</div><div class="line">        <span class="keyword">this</span>.isShutdown = isShutdown;</div><div class="line">        <span class="keyword">this</span>.workerThreads = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 创建 工作线程池</span></div><div class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) &#123;</div><div class="line">            WorkerRunnable&lt;ID, T&gt; runnable = workerRunnableFactory.create(i);</div><div class="line">            Thread workerThread = <span class="keyword">new</span> Thread(threadGroup, runnable, runnable.getWorkerName());</div><div class="line">            workerThreads.add(workerThread);</div><div class="line">            workerThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">            workerThread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建工作线程工厂</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 批量任务执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">WorkerRunnableFactory</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function">WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>workerThreads</code> 属性，工作线程<strong>池</strong>。<strong>工作任务队列会被工作线程池并发拉取，并发执行</strong>。</li><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnableFactory</code> ，创建工作线程工厂<strong>接口</strong>。单任务和批量任务执行器的工作线程实现不同，通过自定义工厂实现类创建。</li></ul><h2>6.1 创建批量任务执行器</h2><p>调用 <code>TaskExecutors#batchExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建批量任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 批量任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">batchExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建批量任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 批量任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> BatchWorkerRunnable&lt;&gt;(<span class="string">"TaskBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.BatchWorkerRunnable</code> ，批量任务工作线程。</li></ul><h2>6.2 创建单任务执行器</h2><p>调用 <code>TaskExecutors#singleItemExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建单任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 单任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">singleItemExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建单任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 单任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SingleTaskWorkerRunnable&lt;&gt;(<span class="string">"TaskNonBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.SingleTaskWorkerRunnable</code> ，单任务工作线程。</li></ul><h2>6.3 工作线程抽象类</h2><p><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable</code> ，任务工作线程抽象类。BatchWorkerRunnable 和 SingleTaskWorkerRunnable 都实现该类，差异在 <code>#run()</code> 的自定义实现。WorkerRunnable 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 线程名</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> String workerName;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 是否关闭</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务处理器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务接收执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; taskDispatcher;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略构造方法和 getting 方法。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>7. 网络通信整形器</h1><p><code>com.netflix.eureka.util.batcher.TrafficShaper</code> ，网络通信整形器。当任务执行发生请求限流，或是请求网络失败的情况，则延时 AcceptorRunner 将任务提交到工作任务队列，从而避免任务很快去执行，再次发生上述情况。TrafficShaper 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrafficShaper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Upper bound on delay provided by configuration.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DELAY = <span class="number">30</span> * <span class="number">1000</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> congestionRetryDelayMs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> networkFailureRetryMs;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后请求限流时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastCongestionError;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后网络失败时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastNetworkFailure;</div><div class="line"></div><div class="line">    TrafficShaper(<span class="keyword">long</span> congestionRetryDelayMs, <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line">        <span class="keyword">this</span>.congestionRetryDelayMs = Math.min(MAX_DELAY, congestionRetryDelayMs);</div><div class="line">        <span class="keyword">this</span>.networkFailureRetryMs = Math.min(MAX_DELAY, networkFailureRetryMs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFailure</span><span class="params">(ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (processingResult == ProcessingResult.Congestion) &#123;</div><div class="line">            lastCongestionError = System.currentTimeMillis();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processingResult == ProcessingResult.TransientError) &#123;</div><div class="line">            lastNetworkFailure = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 计算提交延迟，单位：毫秒</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">transmissionDelay</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError == -<span class="number">1</span> &amp;&amp; lastNetworkFailure == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后请求限流带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> congestionDelay = now - lastCongestionError;</div><div class="line">            <span class="keyword">if</span> (congestionDelay &gt;= <span class="number">0</span> &amp;&amp; congestionDelay &lt; congestionRetryDelayMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> congestionRetryDelayMs - congestionDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastCongestionError = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后网络失败带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastNetworkFailure != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> failureDelay = now - lastNetworkFailure;</div><div class="line">            <span class="keyword">if</span> (failureDelay &gt;= <span class="number">0</span> &amp;&amp; failureDelay &lt; networkFailureRetryMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> networkFailureRetryMs - failureDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastNetworkFailure = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#registerFailure(...)</code> ，在任务执行失败时，提交任务结果给 TrafficShaper ，记录发生时间。在 <a href="#">「10. 任务执行器【执行任务】」</a> 会看到调用该方法。</li><li><code>#transmissionDelay(...)</code> ，计算提交延迟，单位：毫秒。<a href="#">「9. 任务接收线程【调度任务】」</a> 会看到调用该方法。</li></ul><h1>8. 任务接收执行器【处理任务】</h1><p>调用 <code>AcceptorExecutor#process(...)</code> 方法，添加任务到接收任务队列。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line">   acceptorQueue.add(<span class="keyword">new</span> TaskHolder&lt;ID, T&gt;(id, task, expiryTime));</div><div class="line">   acceptedTasks++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.eureka.util.batcher.TaskHolder</code> ，任务持有者，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskHolder</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ID id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务过期时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> expiryTime;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务提交时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> submitTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h1>9. 任务接收线程【调度任务】</h1><p>后台线程执行 <code>AcceptorRunner#run(...)</code> 方法，调度任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> scheduleTime = <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:             <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"> <span class="number">7</span>:             drainInputQueues();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:             <span class="comment">// 待执行任务数量</span></div><div class="line"><span class="number">10</span>:             <span class="keyword">int</span> totalItems = processingOrder.size();</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:             <span class="comment">// 计算调度时间</span></div><div class="line"><span class="number">13</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"><span class="number">14</span>:             <span class="keyword">if</span> (scheduleTime &lt; now) &#123;</div><div class="line"><span class="number">15</span>:                 scheduleTime = now + trafficShaper.transmissionDelay();</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:             <span class="comment">// 调度</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (scheduleTime &lt;= now) &#123;</div><div class="line"><span class="number">20</span>:                 <span class="comment">// 调度批量任务</span></div><div class="line"><span class="number">21</span>:                 assignBatchWork();</div><div class="line"><span class="number">22</span>:                 <span class="comment">// 调度单任务</span></div><div class="line"><span class="number">23</span>:                 assignSingleItemWork();</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             <span class="comment">// 1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// If no worker is requesting data or there is a delay injected by the traffic shaper,</span></div><div class="line"><span class="number">28</span>:             <span class="comment">// sleep for some time to avoid tight loop.</span></div><div class="line"><span class="number">29</span>:             <span class="keyword">if</span> (totalItems == processingOrder.size()) &#123;</div><div class="line"><span class="number">30</span>:                 Thread.sleep(<span class="number">10</span>);</div><div class="line"><span class="number">31</span>:             &#125;</div><div class="line"><span class="number">32</span>:         &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line"><span class="number">33</span>:             <span class="comment">// Ignore</span></div><div class="line"><span class="number">34</span>:         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">35</span>:             <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"><span class="number">36</span>:             logger.warn(<span class="string">"Discovery AcceptorThread error"</span>, e);</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 行 ：无限循环执行调度，直到关闭。</p></li><li><p>第 6 至 7 行 ：调用 <code>#drainInputQueues()</code> 方法，<strong>循环</strong>处理完输入队列( 接收队列 + 重新执行队列 )，<strong>直到</strong>有待执行的任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainInputQueues</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 处理完重新执行队列</span></div><div class="line"> <span class="number">4</span>:         drainReprocessQueue();</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 处理完接收队列</span></div><div class="line"> <span class="number">6</span>:         drainAcceptorQueue();</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:         <span class="comment">// 所有队列为空，等待 10 ms，看接收队列是否有新任务</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (!isShutdown.get()) &#123;</div><div class="line"><span class="number">10</span>:             <span class="comment">// If all queues are empty, block for a while on the acceptor queue</span></div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (reprocessQueue.isEmpty() &amp;&amp; acceptorQueue.isEmpty() &amp;&amp; pendingTasks.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:                 TaskHolder&lt;ID, T&gt; taskHolder = acceptorQueue.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:                     appendTaskHolder(taskHolder);</div><div class="line"><span class="number">15</span>:                 &#125;</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125; <span class="keyword">while</span> (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty()); <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 行 &amp;&amp; 第 18 行 ：<strong>循环</strong>，直到<strong>同时</strong>满足如下全部条件：</p><ul><li>重新执行队列( <code>reprocessQueue</code> ) 和接收队列( <code>acceptorQueue</code> )为空</li><li>待执行任务映射( <code>pendingTasks</code> )<strong>不为空</strong></li></ul></li><li><p>第 3 至 4 行 ：处理完重新执行队列( <code>reprocessQueue</code> )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainReprocessQueue</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">3</span>:     <span class="keyword">while</span> (!reprocessQueue.isEmpty() &amp;&amp; !isFull()) &#123;</div><div class="line"> <span class="number">4</span>:         TaskHolder&lt;ID, T&gt; taskHolder = reprocessQueue.pollLast(); <span class="comment">// 优先拿较新的任务</span></div><div class="line"> <span class="number">5</span>:         ID id = taskHolder.getId();</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (taskHolder.getExpiryTime() &lt;= now) &#123; <span class="comment">// 过期</span></div><div class="line"> <span class="number">7</span>:             expiredTasks++;</div><div class="line"> <span class="number">8</span>:         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pendingTasks.containsKey(id)) &#123; <span class="comment">// 已存在</span></div><div class="line"> <span class="number">9</span>:             overriddenTasks++;</div><div class="line"><span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">11</span>:             pendingTasks.put(id, taskHolder);</div><div class="line"><span class="number">12</span>:             processingOrder.addFirst(id); <span class="comment">// 提交到队头</span></div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="comment">// 如果待执行队列已满，清空重新执行队列，放弃较早的任务</span></div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (isFull()) &#123;</div><div class="line"><span class="number">17</span>:         queueOverflows += reprocessQueue.size();</div><div class="line"><span class="number">18</span>:         reprocessQueue.clear();</div><div class="line"><span class="number">19</span>:     &#125;</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 行 ：优先从重新执行任务的队尾拿较新的任务，从而实现保留更新的任务在待执行任务映射( <code>pendingTasks</code> ) 里。</li><li>第 12 行 ：添加任务编号到待执行队列( <code>processingOrder</code> ) 的头部。效果如下图：<img src="http://www.iocoder.cn/images/Eureka/2018_07_17/03.png" alt=""></li><li>第 15 至 18 行 ：如果待执行队列( <code>pendingTasks</code> )已满，清空重新执行队列( <code>processingOrder</code> )，放弃较早的任务。</li></ul></li><li><p>第 5 至 6 行 ：处理完接收队列( <code>acceptorQueue</code> )，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainAcceptorQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (!acceptorQueue.isEmpty()) &#123; <span class="comment">// 循环，直到接收队列为空</span></div><div class="line">      appendTaskHolder(acceptorQueue.poll());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTaskHolder</span><span class="params">(TaskHolder&lt;ID, T&gt; taskHolder)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果待执行队列已满，移除待处理队列，放弃较早的任务</span></div><div class="line">  <span class="keyword">if</span> (isFull()) &#123;</div><div class="line">      pendingTasks.remove(processingOrder.poll());</div><div class="line">      queueOverflows++;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加到待执行队列</span></div><div class="line">  TaskHolder&lt;ID, T&gt; previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);</div><div class="line">  <span class="keyword">if</span> (previousTask == <span class="keyword">null</span>) &#123;</div><div class="line">      processingOrder.add(taskHolder.getId());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      overriddenTasks++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 8 至 17 行 ：当所有队列为空，阻塞从接收队列( <code>acceptorQueue</code> ) 拉取任务 10 ms。若拉取到，添加到待执行队列( <code>processingOrder</code> )。</p></li></ul></li><li><p>第 12 至 16 行 ：计算可调度任务的最小时间( <code>scheduleTime</code> )。</p><ul><li>当 <code>scheduleTime</code> 小于当前时间，不重新计算，即此时需要延迟等待调度。</li><li>当 <code>scheduleTime</code> 大于等于当前时间，配合 <code>TrafficShaper#transmissionDelay(...)</code> 重新计算。</li></ul></li><li><p>第 19 行 ：当 <code>scheduleTime</code> 小于当前时间，执行任务的调度。</p></li><li><p>第 21 行 ：调用 <code>#assignBatchWork()</code> 方法，调度批量任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">assignBatchWork</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (hasEnoughTasksForNextBatch()) &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 获取 批量任务工作请求信号量</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">if</span> (batchWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line"> <span class="number">6</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">7</span>:             <span class="keyword">int</span> len = Math.min(maxBatchingSize, processingOrder.size());</div><div class="line"> <span class="number">8</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = <span class="keyword">new</span> ArrayList&lt;&gt;(len);</div><div class="line"> <span class="number">9</span>:             <span class="keyword">while</span> (holders.size() &lt; len &amp;&amp; !processingOrder.isEmpty()) &#123;</div><div class="line"><span class="number">10</span>:                 ID id = processingOrder.poll();</div><div class="line"><span class="number">11</span>:                 TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line"><span class="number">12</span>:                 <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">13</span>:                     holders.add(holder);</div><div class="line"><span class="number">14</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                     expiredTasks++;</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>:             <span class="comment">//</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (holders.isEmpty()) &#123; <span class="comment">// 未调度到批量任务，释放请求信号量</span></div><div class="line"><span class="number">20</span>:                 batchWorkRequests.release();</div><div class="line"><span class="number">21</span>:             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加批量任务到批量任务工作队列</span></div><div class="line"><span class="number">22</span>:                 batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">23</span>:                 batchWorkQueue.add(holders);</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:     &#125;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 行 ：调用 <code>#hasEnoughTasksForNextBatch()</code> 方法，判断是否有足够任务进行下一次批量任务调度：1）待执行任务( <code>processingOrder</code> )映射已满；或者 2）到达批量任务处理最大等待延迟。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEnoughTasksForNextBatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 待执行队列为空</span></div><div class="line">    <span class="keyword">if</span> (processingOrder.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 待执行任务映射已满</span></div><div class="line">    <span class="keyword">if</span> (pendingTasks.size() &gt;= maxBufferSize) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 到达批量任务处理最大等待延迟( 通过待处理队列的头部任务判断 )</span></div><div class="line">    TaskHolder&lt;ID, T&gt; nextHolder = pendingTasks.get(processingOrder.peek());</div><div class="line">    <span class="keyword">long</span> delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();</div><div class="line">    <span class="keyword">return</span> delay &gt;= maxBatchingDelay;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 5 至 17 行 ：获取批量任务( <code>holders</code> )。<strong>你会发现，本文说了半天的批量任务，实际是 List&lt;TaskHolder&lt;ID, T&gt;&gt; 哈</strong>。</p></li><li><p>第 4 行 ：获取批量任务工作请求信号量( <code>batchWorkRequests</code> ) 。在任务执行器的批量任务执行器，每次执行时，发出 <code>batchWorkRequests</code> 。<strong>每一个信号量需要保证获取到一个批量任务</strong>。</p></li><li><p>第 19 至 20 行 ：未调度到批量任务，释放请求信号量，<strong>代表请求实际未完成，每一个信号量需要保证获取到一个批量任务</strong>。</p></li><li><p>第 21 至 24 行 ：添加批量任务到批量任务工作队列。</p></li><li><p>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务。</p></li></ul></li><li><p>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务，和 <code>#assignBatchWork()</code> 方法<strong>类似</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignSingleItemWork</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!processingOrder.isEmpty()) &#123; <span class="comment">// 待执行任队列不为空</span></div><div class="line">      <span class="comment">// 获取 单任务工作请求信号量</span></div><div class="line">      <span class="keyword">if</span> (singleItemWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line">          <span class="comment">// 【循环】获取单任务</span></div><div class="line">          <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">          <span class="keyword">while</span> (!processingOrder.isEmpty()) &#123;</div><div class="line">              ID id = processingOrder.poll(); <span class="comment">// 一定不为空</span></div><div class="line">              TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line">              <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123;</div><div class="line">                  singleItemWorkQueue.add(holder);</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">              expiredTasks++;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 获取不到单任务，释放请求信号量</span></div><div class="line">          singleItemWorkRequests.release();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 26 至 31 行 ：当调度任务前的待执行任务数( <code>totalItems</code> )等于当前待执行队列( <code>processingOrder</code> )的任务数，意味着：1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</p></li></ul><h1>10. 任务执行器【执行任务】</h1><h2>10.1 批量任务工作线程</h2><p>批量任务工作后台线程( BatchWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">4</span>:         <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">  <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line">  <span class="number">6</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = getWork();</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">  <span class="number">9</span>:             metrics.registerExpiryTimes(holders);</div><div class="line"> <span class="number">10</span>: </div><div class="line"> <span class="number">11</span>:             <span class="comment">// 获得实际批量任务</span></div><div class="line"> <span class="number">12</span>:             List&lt;T&gt; tasks = getTasksOf(holders);</div><div class="line"> <span class="number">13</span>:             <span class="comment">// 调用处理器执行任务</span></div><div class="line"> <span class="number">14</span>:             ProcessingResult result = processor.process(tasks);</div><div class="line"> <span class="number">15</span>:             <span class="keyword">switch</span> (result) &#123;</div><div class="line"> <span class="number">16</span>:                 <span class="keyword">case</span> Success:</div><div class="line"> <span class="number">17</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">18</span>:                 <span class="keyword">case</span> Congestion:</div><div class="line"> <span class="number">19</span>:                 <span class="keyword">case</span> TransientError:</div><div class="line"> <span class="number">20</span>:                     taskDispatcher.reprocess(holders, result); <span class="comment">// 提交重新处理</span></div><div class="line"> <span class="number">21</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">22</span>:                 <span class="keyword">case</span> PermanentError:</div><div class="line"> <span class="number">23</span>:                     logger.warn(<span class="string">"Discarding &#123;&#125; tasks of &#123;&#125; due to permanent error"</span>, holders.size(), workerName);</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line"> <span class="number">27</span>:             metrics.registerTaskResult(result, tasks.size());</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>:     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"> <span class="number">30</span>:         <span class="comment">// Ignore</span></div><div class="line"> <span class="number">31</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">32</span>:         <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"> <span class="number">33</span>:         logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line"> <span class="number">34</span>:     &#125;</div><div class="line"> <span class="number">35</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 行 ：无限循环执行调度，直到关闭。</p></li><li><p>第 6 行 ：调用 <code>getWork()</code> 方法，获取<strong>一个</strong>批量任务直到成功。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> List&lt;TaskHolder&lt;ID, T&gt;&gt; getWork() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 发起请求信号量，并获得批量任务的工作队列</span></div><div class="line"> <span class="number">3</span>:     BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; workQueue = taskDispatcher.requestWorkItems();</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 【循环】获取批量任务，直到成功</span></div><div class="line"> <span class="number">5</span>:     List&lt;TaskHolder&lt;ID, T&gt;&gt; result;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">7</span>:         result = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">while</span> (!isShutdown.get() &amp;&amp; result == <span class="keyword">null</span>);</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 行 ：调用 <code>TaskDispatcher#requestWorkItems()</code> 方法，发起请求信号量，并获得批量任务的工作队列。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatcher.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作请求信号量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; requestWorkItems() &#123;</div><div class="line">   batchWorkRequests.release();</div><div class="line">   <span class="keyword">return</span> batchWorkQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>，批量任务工作队列( <code>batchWorkQueue</code> ) 和单任务工作队列( <code>singleItemWorkQueue</code> ) 是<strong>不同的队列</strong>。</li></ul></li><li><p>第 5 至 8 行 ：<strong>循环</strong>获取<strong>一个</strong>批量任务，直到成功。</p></li></ul></li><li><p>第 12 行 ：调用 <code>#getTasksOf(...)</code> 方法，获得<strong>实际</strong>批量任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">getTasksOf</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders)</span> </span>&#123;</div><div class="line">    List&lt;T&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(holders.size());</div><div class="line">    <span class="keyword">for</span> (TaskHolder&lt;ID, T&gt; holder : holders) &#123;</div><div class="line">        tasks.add(holder.getTask());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 14 至 24 行 ：调用处理器( TaskProcessor ) 执行任务。当任务执行结果为 <code>Congestion</code> 或 <code>TransientError</code> ，调用 <code>AcceptorExecutor#reprocess(...)</code> 提交<strong>整个批量任务</strong>重新处理，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprocess</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders, ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 重新执行队列</span></div><div class="line">   reprocessQueue.addAll(holders);</div><div class="line"></div><div class="line">   <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">   replayedTasks += holders.size();</div><div class="line">   </div><div class="line">   <span class="comment">// 提交任务结果给 TrafficShaper</span></div><div class="line">   trafficShaper.registerFailure(processingResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h2>10.2 单任务工作线程</h2><p>单任务工作后台线程( SingleTaskWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务，和 <code>BatchWorkerRunnable#run(...)</code> 基本类似，就不啰嗦了。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// SingleTaskWorkerRunnable.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">          <span class="comment">// 发起请求信号量，并获得单任务的工作队列</span></div><div class="line">          BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; workQueue = taskDispatcher.requestWorkItem();</div><div class="line">          TaskHolder&lt;ID, T&gt; taskHolder;</div><div class="line">          <span class="comment">// 【循环】获取单任务，直到成功</span></div><div class="line">          <span class="keyword">while</span> ((taskHolder = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS)) == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (isShutdown.get()) &#123;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">          metrics.registerExpiryTime(taskHolder);</div><div class="line">          <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">// 调用处理器执行任务</span></div><div class="line">              ProcessingResult result = processor.process(taskHolder.getTask());</div><div class="line">              <span class="keyword">switch</span> (result) &#123;</div><div class="line">                  <span class="keyword">case</span> Success:</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> Congestion:</div><div class="line">                  <span class="keyword">case</span> TransientError:</div><div class="line">                      taskDispatcher.reprocess(taskHolder, result); <span class="comment">// 提交重新处理</span></div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> PermanentError:</div><div class="line">                      logger.warn(<span class="string">"Discarding a task of &#123;&#125; due to permanent error"</span>, workerName);</div><div class="line">              &#125;</div><div class="line">              <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">              metrics.registerTaskResult(result, <span class="number">1</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      <span class="comment">// Ignore</span></div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">      <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line">      logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>666. 彩蛋</h1><p>😈 又是一篇长文。建议边看代码，边对照着整体流程图，理解实际不难。</p><p>当然，欢迎你有任何疑问，在我的公众号( <strong>芋道源码</strong> ) 留言。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/batch-tasks/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-override-status/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-override-status/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-override-status/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">2. 应用实例覆盖状态变更接口</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">2.1 更新应用实例覆盖状态</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">3. 应用实例覆盖状态删除接口</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">3.1 删除应用实例覆盖状态</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4. 应用实例覆盖状态映射</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.1 应用实例状态覆盖规则</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.2 注册场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.3 续租场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.4 下线场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.5 过期场景</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">5. 客户端调用接口</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>应用实例的覆盖状态属性</strong>。</p><p>这里要注意下，不是应用实例的状态( <code>status</code> )，而是覆盖状态( <code>overridestatus</code> ) 。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> InstanceStatus overriddenstatus = InstanceStatus.UNKNOWN;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略属性和方法</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用 Eureka-Server HTTP Restful 接口 <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code> 对应用实例覆盖状态的变更，从而达到<strong>主动</strong>的、<strong>强制</strong>的变更应用实例状态。注意，<strong>实际不会真的修改 Eureka-Client 应用实例的状态，而是修改在 Eureka-Server 注册的应用实例的状态</strong>。</p><p>通过这样的方式，Eureka-Client 在获取到注册信息时，并且配置 <code>eureka.shouldFilterOnlyUpInstances = true</code>，过滤掉非 <code>InstanceStatus.UP</code> 的应用实例，从而避免调动该实例，以达到应用实例的<strong>暂停服务( <code>InstanceStatus.OUT_OF_SERVICE</code> )，而无需关闭应用实例</strong>。</p><p>因此，大多数情况下，调用该接口的目的，将应用实例状态在 ( <code>InstanceStatus.UP</code> ) 和  ( <code>InstanceStatus.OUT_OF_SERVICE</code> ) 之间切换。引用官方代码上的注释如下：</p><blockquote><p><code>AbstractInstanceRegistry#statusUpdate</code> 方法注释<br>Updates the status of an instance.<br>Normally happens to put an instance between {@link InstanceStatus#OUT_OF_SERVICE} and {@link InstanceStatus#UP} to put the instance in and out of traffic.</p></blockquote><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><hr><p>接口 <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code> 实际是两个：</p><ul><li>PUT <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code></li><li>DELETE <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code></li></ul><p>下面，我们逐节分享这两接口的代码实现。</p><h1>2. 应用实例覆盖状态变更接口</h1><p>应用实例覆盖状态变更接口，映射 <code>InstanceResource#statusUpdate()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"status"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">statusUpdate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @QueryParam(<span class="string">"value"</span>)</span> String newStatus,</span></div><div class="line"><span class="function">       @<span class="title">HeaderParam</span><span class="params">(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 应用实例不存在</span></div><div class="line">       <span class="keyword">if</span> (registry.getInstanceByAppAndId(app.getName(), id) == <span class="keyword">null</span>) &#123;</div><div class="line">           logger.warn(<span class="string">"Instance not found: &#123;&#125;/&#123;&#125;"</span>, app.getName(), id);</div><div class="line">           <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 覆盖状态更新</span></div><div class="line">       <span class="keyword">boolean</span> isSuccess = registry.statusUpdate(app.getName(), id,</div><div class="line">               InstanceStatus.valueOf(newStatus), lastDirtyTimestamp,</div><div class="line">               <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">       <span class="comment">// 返回结果</span></div><div class="line">       <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">           logger.info(<span class="string">"Status updated: "</span> + app.getName() + <span class="string">" - "</span> + id</div><div class="line">                   + <span class="string">" - "</span> + newStatus);</div><div class="line">           <span class="keyword">return</span> Response.ok().build();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unable to update status: "</span> + app.getName() + <span class="string">" - "</span></div><div class="line">                   + id + <span class="string">" - "</span> + newStatus);</div><div class="line">           <span class="keyword">return</span> Response.serverError().build();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Error updating instance &#123;&#125; for status &#123;&#125;"</span>, id,</div><div class="line">               newStatus);</div><div class="line">       <span class="keyword">return</span> Response.serverError().build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>PeerAwareInstanceRegistryImpl#statusUpdate(...)</code> 方法，更新应用实例覆盖状态。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> InstanceStatus newStatus, String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) &#123;</div><div class="line">       <span class="comment">// Eureka-Server 集群同步</span></div><div class="line">       replicateToPeers(Action.StatusUpdate, appName, id, <span class="keyword">null</span>, newStatus, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用父类 <code>AbstractInstanceRegistry#statusUpdate(...)</code> 方法，更新应用实例覆盖状态。</li></ul></li></ul><h2>2.1 更新应用实例覆盖状态</h2><p>调用 <code>AbstractInstanceRegistry#statusUpdate(...)</code> 方法，更新应用实例覆盖状态，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                             InstanceStatus newStatus, String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:                             <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// TODO  为什么是读锁</span></div><div class="line"> <span class="number">7</span>:         read.lock();</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 添加 覆盖状态变更次数 到 监控</span></div><div class="line"> <span class="number">9</span>:         STATUS_UPDATE.increment(isReplication);</div><div class="line"><span class="number">10</span>:         <span class="comment">// 获得 租约</span></div><div class="line"><span class="number">11</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">12</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">null</span>;</div><div class="line"><span class="number">13</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:             lease = gMap.get(id);</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (lease == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">21</span>:             lease.renew();</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:             <span class="comment">// 应用实例信息不存在( 防御型编程 )</span></div><div class="line"><span class="number">24</span>:             InstanceInfo info = lease.getHolder();</div><div class="line"><span class="number">25</span>:             <span class="comment">// Lease is always created with its instance info object.</span></div><div class="line"><span class="number">26</span>:             <span class="comment">// This log statement is provided as a safeguard, in case this invariant is violated.</span></div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>:                 logger.error(<span class="string">"Found Lease without a holder for instance id &#123;&#125;"</span>, id);</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:             <span class="comment">//</span></div><div class="line"><span class="number">31</span>:             <span class="keyword">if</span> ((info != <span class="keyword">null</span>) &amp;&amp; !(info.getStatus().equals(newStatus))) &#123;</div><div class="line"><span class="number">32</span>:                 <span class="comment">// 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"><span class="number">33</span>:                 <span class="comment">// Mark service as UP if needed</span></div><div class="line"><span class="number">34</span>:                 <span class="keyword">if</span> (InstanceStatus.UP.equals(newStatus)) &#123;</div><div class="line"><span class="number">35</span>:                     lease.serviceUp();</div><div class="line"><span class="number">36</span>:                 &#125;</div><div class="line"><span class="number">37</span>:                 <span class="comment">// 添加到 应用实例覆盖状态映射</span></div><div class="line"><span class="number">38</span>:                 <span class="comment">// This is NAC overridden status</span></div><div class="line"><span class="number">39</span>:                 overriddenInstanceStatusMap.put(id, newStatus);</div><div class="line"><span class="number">40</span>:                 <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"><span class="number">41</span>:                 <span class="comment">// Set it for transfer of overridden status to replica on</span></div><div class="line"><span class="number">42</span>:                 <span class="comment">// replica start up</span></div><div class="line"><span class="number">43</span>:                 info.setOverriddenStatus(newStatus);</div><div class="line"><span class="number">44</span>:                 <span class="comment">// 设置 应用实例信息 数据不一致时间</span></div><div class="line"><span class="number">45</span>:                 <span class="keyword">long</span> replicaDirtyTimestamp = <span class="number">0</span>;</div><div class="line"><span class="number">46</span>:                 <span class="comment">// 设置 应用实例状态</span></div><div class="line"><span class="number">47</span>:                 info.setStatusWithoutDirty(newStatus);</div><div class="line"><span class="number">48</span>:                 <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">49</span>:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</div><div class="line"><span class="number">50</span>:                 &#125;</div><div class="line"><span class="number">51</span>:                 <span class="comment">// If the replication's dirty timestamp is more than the existing one, just update</span></div><div class="line"><span class="number">52</span>:                 <span class="comment">// it to the replica's.</span></div><div class="line"><span class="number">53</span>:                 <span class="keyword">if</span> (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) &#123;</div><div class="line"><span class="number">54</span>:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);</div><div class="line"><span class="number">55</span>:                 &#125;</div><div class="line"><span class="number">56</span>:                 <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">57</span>:                 info.setActionType(ActionType.MODIFIED);</div><div class="line"><span class="number">58</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">59</span>:                 <span class="comment">// 设置 最后更新时间</span></div><div class="line"><span class="number">60</span>:                 info.setLastUpdatedTimestamp();</div><div class="line"><span class="number">61</span>:                 <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">62</span>:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());</div><div class="line"><span class="number">63</span>:             &#125;</div><div class="line"><span class="number">64</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">65</span>:         &#125;</div><div class="line"><span class="number">66</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">67</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">68</span>:         read.unlock();</div><div class="line"><span class="number">69</span>:     &#125;</div><div class="line"><span class="number">70</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 6 至 7 行 ：TODO[0026] ：读锁</p></li><li><p>第 8 至 9 行 ：添加覆盖状态变更次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p></li><li><p>第 10 至 15 行 ：获得租约。</p></li><li><p>第 16 至 18 行 ：租约不存在，返回更新失败。</p></li><li><p>第 20 至 21 行 ：设置租约最后更新时间( 续租 )。</p></li><li><p>第 23 至 29 行 ：持有租约的应用实例不存在，理论来说不会出现，防御性编程。</p></li><li><p>第 31 行 ：<strong>应用实例当前状态和覆该状态不一致时才更新覆盖状态</strong>。</p></li><li><p>第 32 至 36 行 ：当覆盖状态是 <code>InstanceStatus.UP</code>，设置租约的开始服务的时间戳（只有第一次有效）。</p></li><li><p>第 37 至 39 行 ：添加到应用实例覆盖状态映射( <code>overriddenInstanceStatusMap</code> )。此处英文 <code>&quot;NAC&quot;</code> 可能是 <code>&quot;Network Access Control&quot;</code> 的缩写，感兴趣的可以看看 <a href="https://en.wikipedia.org/wiki/Network_Access_Control" rel="external nofollow noopener noreferrer" target="_blank">《Network Access Control》</a> 。<code>overriddenInstanceStatusMap</code> 属性代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 应用实例覆盖状态映射</span></div><div class="line"><span class="comment">* key：应用实例编号</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String, InstanceStatus&gt; overriddenInstanceStatusMap = CacheBuilder</div><div class="line">      .newBuilder().initialCapacity(<span class="number">500</span>)</div><div class="line">      .expireAfterAccess(<span class="number">1</span>, TimeUnit.HOURS)</div><div class="line">      .&lt;String, InstanceStatus&gt;build().asMap();</div></pre></td></tr></table></figure></p><ul><li>有效期 1 小时。每次访问后会刷新有效期，在后文你会看到对其的访问。</li></ul></li><li><p>第 40 至 43 行 ：设置应用实例的覆盖状态。用于 Eureka-Server 集群同步。</p></li><li><p>第 46 至 47 行 ：<strong>设置应用实例状态</strong>。设置后，Eureka-Client 拉取注册信息，被更新覆盖状态的应用实例就是设置的状态。</p></li><li><p>第 48 至 55 行 ：设置应用实例的数据不一致时间。用于 Eureka-Server 集群同步。</p></li><li><p>第 56 至 58 行 ：添加应用实例到最近租约变更记录队列。</p></li><li><p>第 59 至 60 行 ：设置应用实例的最后更新时间( <code>lastUpdatedTimestamp</code> )。<code>lastUpdatedTimestamp</code> 主要用于记录最后更新时间，无实际业务用途。</p></li><li><p>第 61 至 62 行 ：设置响应缓存过期。</p></li><li><p>第 64 行 ：返回更新成功。</p></li><li><p>第 68 行 ：释放读锁。</p></li></ul><h1>3. 应用实例覆盖状态删除接口</h1><p>当我们不需要应用实例的覆盖状态时，调度接口接口进行删除。关联官方 <code>issue#89</code> ：<a href="https://github.com/Netflix/eureka/issues/89" rel="external nofollow noopener noreferrer" target="_blank">Provide an API to remove all overridden status</a>。</p><p>应用实例覆盖状态删除接口，映射 <code>InstanceResource#deleteStatusUpdate()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"status"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">deleteStatusUpdate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"value"</span>)</span> String newStatusValue,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 应用实例不存在</span></div><div class="line">       <span class="keyword">if</span> (registry.getInstanceByAppAndId(app.getName(), id) == <span class="keyword">null</span>) &#123;</div><div class="line">           logger.warn(<span class="string">"Instance not found: &#123;&#125;/&#123;&#125;"</span>, app.getName(), id);</div><div class="line">           <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 覆盖状态删除</span></div><div class="line">       InstanceStatus newStatus = newStatusValue == <span class="keyword">null</span> ? InstanceStatus.UNKNOWN : InstanceStatus.valueOf(newStatusValue);</div><div class="line">       <span class="keyword">boolean</span> isSuccess = registry.deleteStatusOverride(app.getName(), id,</div><div class="line">               newStatus, lastDirtyTimestamp, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">       <span class="comment">// 返回结果</span></div><div class="line">       <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">           logger.info(<span class="string">"Status override removed: "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">           <span class="keyword">return</span> Response.ok().build();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unable to remove status override: "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">           <span class="keyword">return</span> Response.serverError().build();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Error removing instance's &#123;&#125; status override"</span>, id);</div><div class="line">       <span class="keyword">return</span> Response.serverError().build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>请求参数 <code>newStatusValue</code> ，设置应用实例的状态。大多数情况下，<code>newStatusValue</code> 要和应用实例实际的状态一致，因为该应用实例的 Eureka-Client 不会从 Eureka-Server 拉取到该应用状态 <code>newStatusValue</code> 。另外一种方式，不传递该参数，相当于 <code>UNKNOWN</code> 状态，这样，Eureka-Client 会主动向 Eureka-Server 再次发起注册，具体原因在 [「4.3 续租场景」] 详细解析，更加推荐的方式。</p></li><li><p>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params">                                   InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                   String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) &#123;</div><div class="line">       <span class="comment">// Eureka-Server 集群同步</span></div><div class="line">       replicateToPeers(Action.DeleteStatusOverride, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。</li></ul></li></ul><h2>3.1 删除应用实例覆盖状态</h2><p>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                                     InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:                                     String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">5</span>:                                     <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// TODO  为什么是读锁</span></div><div class="line"> <span class="number">8</span>:         read.lock();</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 添加 覆盖状态删除次数 到 监控</span></div><div class="line"><span class="number">10</span>:         STATUS_OVERRIDE_DELETE.increment(isReplication);</div><div class="line"><span class="number">11</span>:         <span class="comment">// 获得 租约</span></div><div class="line"><span class="number">12</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">13</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">null</span>;</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">15</span>:             lease = gMap.get(id);</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (lease == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">20</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">21</span>:             <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">22</span>:             lease.renew();</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:             <span class="comment">// 应用实例信息不存在( 防御型编程 )</span></div><div class="line"><span class="number">25</span>:             InstanceInfo info = lease.getHolder();</div><div class="line"><span class="number">26</span>:             <span class="comment">// Lease is always created with its instance info object.</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// This log statement is provided as a safeguard, in case this invariant is violated.</span></div><div class="line"><span class="number">28</span>:             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:                 logger.error(<span class="string">"Found Lease without a holder for instance id &#123;&#125;"</span>, id);</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:             <span class="comment">// 移除 应用实例覆盖状态</span></div><div class="line"><span class="number">33</span>:             InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);</div><div class="line"><span class="number">34</span>:             <span class="keyword">if</span> (currentOverride != <span class="keyword">null</span> &amp;&amp; info != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>:                 <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"><span class="number">36</span>:                 info.setOverriddenStatus(InstanceStatus.UNKNOWN);</div><div class="line"><span class="number">37</span>:                 <span class="comment">// 设置 应用实例状态</span></div><div class="line"><span class="number">38</span>:                 info.setStatusWithoutDirty(newStatus);</div><div class="line"><span class="number">39</span>:                 <span class="comment">// 设置 应用实例信息 数据不一致时间</span></div><div class="line"><span class="number">40</span>:                 <span class="keyword">long</span> replicaDirtyTimestamp = <span class="number">0</span>;</div><div class="line"><span class="number">41</span>:                 <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">42</span>:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</div><div class="line"><span class="number">43</span>:                 &#125;</div><div class="line"><span class="number">44</span>:                 <span class="comment">// If the replication's dirty timestamp is more than the existing one, just update</span></div><div class="line"><span class="number">45</span>:                 <span class="comment">// it to the replica's.</span></div><div class="line"><span class="number">46</span>:                 <span class="keyword">if</span> (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) &#123;</div><div class="line"><span class="number">47</span>:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);</div><div class="line"><span class="number">48</span>:                 &#125;</div><div class="line"><span class="number">49</span>:                 <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">50</span>:                 info.setActionType(ActionType.MODIFIED);</div><div class="line"><span class="number">51</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">52</span>:                 <span class="comment">// 设置 最后更新时间</span></div><div class="line"><span class="number">53</span>:                 info.setLastUpdatedTimestamp();</div><div class="line"><span class="number">54</span>:                 <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">55</span>:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());</div><div class="line"><span class="number">56</span>:             &#125;</div><div class="line"><span class="number">57</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">60</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">61</span>:         read.unlock();</div><div class="line"><span class="number">62</span>:     &#125;</div><div class="line"><span class="number">63</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 7 至 8 行 ：TODO[0026] ：写锁</li><li>第 9 至 10 行 ：添加覆盖状态删除次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 11 至 16 行 ：获得租约。</li><li>第 17 至 19 行 ：租约不存在，返回更新失败。</li><li>第 21 至 22 行 ：设置租约最后更新时间( 续租 )。</li><li>第 24 至 30 行 ：持有租约的应用实例不存在，理论来说不会出现，防御性编程。</li><li>第 32 至 33 行 ：移除出应用实例覆盖状态映射( <code>overriddenInstanceStatusMap</code> )。</li><li>第 34 行 ：<strong>应用实例的覆盖状态存在才设置状态</strong>。</li><li>第 35 至 36 行 ：设置应用实例的覆盖状态为 InstanceStatus.UNKNOWN。用于 Eureka-Server 集群同步。</li><li>第 37 至 38 行 ：设置应用实例的状态为 <code>newStatus</code>。设置后，Eureka-Client 拉取注册信息，被更新覆盖状态的应用实例就是设置的状态。</li><li>第 39 至 48 行 ：设置应用实例的数据不一致时间。用于 Eureka-Server 集群同步。</li><li>第 49 至 51 行 ：添加应用实例到最近租约变更记录队列。</li><li>第 52 至 53 行 ：设置应用实例的最后更新时间( <code>lastUpdatedTimestamp</code> )。<code>lastUpdatedTimestamp</code> 主要用于记录最后更新时间，无实际业务用途。</li><li>第 54 至 55 行 ：设置响应缓存过期。</li><li>第 57 行 ：返回更新成功。</li><li>第 61 行 ：释放读锁。</li></ul><h1>4. 应用实例覆盖状态映射</h1><p>虽然我们在上面代码，使用覆盖状态( <code>overridestatus</code> )设置到应用实例的状态( <code>status</code> )，<strong>实际调用 <code>AbstractInstanceRegistry#getOverriddenInstanceStatus(...)</code> 方法，根据应用实例状态覆盖规则( InstanceStatusOverrideRule )进行计算最终应用实例的状态</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="keyword">protected</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getOverriddenInstanceStatus</span><span class="params">(InstanceInfo r,</span></span></div><div class="line"><span class="function"><span class="params">                                                               Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                                               <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   InstanceStatusOverrideRule rule = getInstanceInfoOverrideRule();</div><div class="line">   logger.debug(<span class="string">"Processing override status using rule: &#123;&#125;"</span>, rule);</div><div class="line">   <span class="keyword">return</span> rule.apply(r, existingLease, isReplication).status();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> InstanceStatusOverrideRule <span class="title">getInstanceInfoOverrideRule</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#getInstanceInfoOverrideRule()</code> 方法，获取应用实例状态覆盖规则( InstanceStatusOverrideRule )。在 PeerAwareInstanceRegistryImpl 里该方法实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule instanceStatusOverrideRule;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PeerAwareInstanceRegistryImpl</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClient eurekaClient</span></span></div><div class="line"><span class="function"><span class="params">    )</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其它方法</span></div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.instanceStatusOverrideRule = <span class="keyword">new</span> FirstMatchWinsCompositeRule(</div><div class="line">        <span class="keyword">new</span> DownOrStartingRule(),</div><div class="line">        <span class="keyword">new</span> OverrideExistsRule(overriddenInstanceStatusMap), </div><div class="line">        <span class="keyword">new</span> LeaseExistsRule());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> InstanceStatusOverrideRule <span class="title">getInstanceInfoOverrideRule</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.instanceStatusOverrideRule;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h2>4.1 应用实例状态覆盖规则</h2><p><code>com.netflix.eureka.registry.rule.InstanceStatusOverrideRule</code> ，应用实例状态覆盖规则<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceStatusOverrideRule.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">     * Match this rule.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> instanceInfo The instance info whose status we care about. 关注状态的应用实例对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> existingLease Does the instance have an existing lease already? If so let's consider that. 已存在的租约</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> isReplication When overriding consider if we are under a replication mode from other servers. 是否是 Eureka-Server 发起的请求</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> A result with whether we matched and what we propose the status to be overriden to.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function">StatusOverrideResult <span class="title">apply</span><span class="params">(<span class="keyword">final</span> InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// StatusOverrideResult.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusOverrideResult</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StatusOverrideResult NO_MATCH = <span class="keyword">new</span> StatusOverrideResult(<span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StatusOverrideResult <span class="title">matchingStatus</span><span class="params">(InstanceInfo.InstanceStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatusOverrideResult(<span class="keyword">true</span>, status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Does the rule match?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> matches;</div><div class="line"></div><div class="line">    <span class="comment">// The status computed by the rule.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo.InstanceStatus status;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StatusOverrideResult</span><span class="params">(<span class="keyword">boolean</span> matches, InstanceInfo.InstanceStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.matches = matches;</div><div class="line">        <span class="keyword">this</span>.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> matches;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">status</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#apply(...)</code> 方法参数 <code>instanceInfo</code> 代表的是<strong>关注状态</strong>的应用实例，和方法参数 <code>existingLease</code> 里的应用实例不一定是同一个，在 <a href="#">「4.1.6 总结」</a> 详细解析。</li><li><code>com.netflix.eureka.registry.rule.StatusOverrideResult</code> ，状态覆盖结果。当匹配成功，返回 <code>matches = true</code> ；否则，返回 <code>matches = false</code> 。</li></ul><p><strong>实现类关系如下</strong>：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_10/01.png" alt=""></p><ul><li>AsgEnabledRule ，亚马逊 AWS 专用，跳过。</li></ul><h3>4.1.1 FirstMatchWinsCompositeRule</h3><p><code>com.netflix.eureka.registry.rule.FirstMatchWinsCompositeRule</code> ，<strong>复合</strong>规则，以第一个匹配成功为准。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMatchWinsCompositeRule</span> <span class="keyword">implements</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 复合规则集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule[] rules;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认规则</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule defaultRule;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String compositeRuleName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstMatchWinsCompositeRule</span><span class="params">(InstanceStatusOverrideRule... rules)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.rules = rules;</div><div class="line">        <span class="keyword">this</span>.defaultRule = <span class="keyword">new</span> AlwaysMatchInstanceStatusRule();</div><div class="line">        <span class="comment">// Let's build up and "cache" the rule name to be used by toString();</span></div><div class="line">        List&lt;String&gt; ruleNames = <span class="keyword">new</span> ArrayList&lt;&gt;(rules.length+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rules.length; ++i) &#123;</div><div class="line">            ruleNames.add(rules[i].toString());</div><div class="line">        &#125;</div><div class="line">        ruleNames.add(defaultRule.toString());</div><div class="line">        compositeRuleName = ruleNames.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                      Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                      <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        <span class="comment">// 使用复合规则，顺序匹配，直到匹配成功</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rules.length; ++i) &#123;</div><div class="line">            StatusOverrideResult result = <span class="keyword">this</span>.rules[i].apply(instanceInfo, existingLease, isReplication);</div><div class="line">            <span class="keyword">if</span> (result.matches()) &#123;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 使用默认规则</span></div><div class="line">        <span class="keyword">return</span> defaultRule.apply(instanceInfo, existingLease, isReplication);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.compositeRuleName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>rules</code> 属性，<strong>复合</strong>规则集合。在 PeerAwareInstanceRegistryImpl 里，我们可以看到该属性为 [ DownOrStartingRule , OverrideExistsRule , LeaseExistsRule ] 。</li><li><code>defaultRule</code> 属性，默认规则，值为 AlwaysMatchInstanceStatusRule 。</li><li><code>#apply()</code> 方法，优先使用<strong>复合</strong>规则( <code>rules</code> )，顺序匹配，直到匹配成功 。当未匹配成功，使用默认规则( <code>defaultRule</code> ) 。</li></ul><h3>4.1.2 DownOrStartingRule</h3><p><code>com.netflix.eureka.registry.rule.DownOrStartingRule</code> ，匹配 <code>InstanceInfo.InstanceStatus.DOWN</code> 或者 <code>InstanceInfo.InstanceStatus.STARTING</code> 状态。实现 <code>#apply(...)</code> 代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that</span></div><div class="line">   <span class="comment">// The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what</span></div><div class="line">   <span class="comment">// the client says. The same is the case with replica as well.</span></div><div class="line">   <span class="comment">// The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be</span></div><div class="line">   <span class="comment">// currently in SERVICE</span></div><div class="line">   <span class="keyword">if</span> ((!InstanceInfo.InstanceStatus.UP.equals(instanceInfo.getStatus()))</div><div class="line">           &amp;&amp; (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(instanceInfo.getStatus()))) &#123;</div><div class="line">       logger.debug(<span class="string">"Trusting the instance status &#123;&#125; from replica or instance for instance &#123;&#125;"</span>,</div><div class="line">               instanceInfo.getStatus(), instanceInfo.getId());</div><div class="line">       <span class="keyword">return</span> StatusOverrideResult.matchingStatus(instanceInfo.getStatus());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>，使用的是 <code>instanceInfo</code> 。</li></ul><h3>4.1.3 OverrideExistsRule</h3><p><code>com.netflix.eureka.registry.rule.OverrideExistsRule</code> ，匹配应用实例覆盖状态映射( <code>statusOverrides</code> ) 。实现 <code>#apply(...)</code> 代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideExistsRule</span> <span class="keyword">implements</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> Map&lt;String, InstanceInfo.InstanceStatus&gt; statusOverrides;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo, Lease&lt;InstanceInfo&gt; existingLease, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        InstanceInfo.InstanceStatus overridden = statusOverrides.get(instanceInfo.getId());</div><div class="line">        <span class="comment">// If there are instance specific overrides, then they win - otherwise the ASG status</span></div><div class="line">        <span class="keyword">if</span> (overridden != <span class="keyword">null</span>) &#123;</div><div class="line">            logger.debug(<span class="string">"The instance specific override for instance &#123;&#125; and the value is &#123;&#125;"</span>,</div><div class="line">                    instanceInfo.getId(), overridden.name());</div><div class="line">            <span class="keyword">return</span> StatusOverrideResult.matchingStatus(overridden);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>statusOverrides</code> 属性，应用实例覆盖状态映射。在 PeerAwareInstanceRegistryImpl 里，使用 <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> 属性赋值。</li><li>上文我们提到 <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code>  每次访问刷新有效期，如果调用到 OverrideExistsRule ，则会不断刷新。从 DownOrStartingRule 看到，<code>instanceInfo</code> 处于 <code>InstanceInfo.InstanceStatus.DOWN</code> 或者 <code>InstanceInfo.InstanceStatus.STARTING</code> 才不会继续调用 OverrideExistsRule 匹配，<code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> 才有可能过期。</li></ul><h3>4.1.4 LeaseExistsRule</h3><p><code>com.netflix.eureka.registry.rule.LeaseExistsRule</code> ，匹配已存在租约的应用实例的 <code>nstanceStatus.OUT_OF_SERVICE</code> 或者 <code>InstanceInfo.InstanceStatus.UP</code> 状态。实现 <code>#apply(...)</code> 代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// This is for backward compatibility until all applications have ASG</span></div><div class="line">   <span class="comment">// names, otherwise while starting up</span></div><div class="line">   <span class="comment">// the client status may override status replicated from other servers</span></div><div class="line">   <span class="keyword">if</span> (!isReplication) &#123; <span class="comment">// 非 Eureka-Server 请求</span></div><div class="line">       InstanceInfo.InstanceStatus existingStatus = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</div><div class="line">           existingStatus = existingLease.getHolder().getStatus();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Allow server to have its way when the status is UP or OUT_OF_SERVICE</span></div><div class="line">       <span class="keyword">if</span> ((existingStatus != <span class="keyword">null</span>)</div><div class="line">               &amp;&amp; (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)</div><div class="line">               || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) &#123;</div><div class="line">           logger.debug(<span class="string">"There is already an existing lease with status &#123;&#125;  for instance &#123;&#125;"</span>,</div><div class="line">                   existingLease.getHolder().getStatus().name(),</div><div class="line">                   existingLease.getHolder().getId());</div><div class="line">           <span class="keyword">return</span> StatusOverrideResult.matchingStatus(existingLease.getHolder().getStatus());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>，使用的是 <code>existingLease</code> ，并且非 Eureka-Server 请求。</li></ul><h3>4.1.5 AlwaysMatchInstanceStatusRule</h3><p><code>com.netflix.eureka.registry.rule.AlwaysMatchInstanceStatusRule</code> ，总是匹配<strong>关注状态的实例对象</strong>( <code>instanceInfo</code> )的状态。实现 <code>#apply(...)</code> 代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   logger.debug(<span class="string">"Returning the default instance status &#123;&#125; for instance &#123;&#125;"</span>, instanceInfo.getStatus(),</div><div class="line">           instanceInfo.getId());</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.matchingStatus(instanceInfo.getStatus());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>，使用的是 <code>instanceInfo</code> 。</li></ul><h3>4.1.6 总结</h3><p>我们将 PeerAwareInstanceRegistryImpl 的应用实例覆盖状态规则梳理如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_10/02.png" alt=""></p><ul><li>应用实例状态是<strong>最重要</strong>的属性，没有之一，因而在最终实例状态的计算，以<strong>可信赖</strong>为主。</li><li>DownOrStartingRule ，<code>instanceInfo</code> 处于 <code>STARTING</code> 或者 <code>DOWN</code> 状态，应用实例可能不适合提供服务( 被请求 )，考虑<strong>可信赖</strong>，返回 <code>instanceInfo</code> 的状态。</li><li>OverrideExistsRule ，当存在覆盖状态( <code>statusoverrides</code> ) ，使用该状态，比较好理解。</li><li>LeaseExistsRule ，来自 Eureka-Client 的请求( 非 Eureka-Server 集群请求)，当 Eureka-Server 的实例状态<strong>存在</strong>，并且处于 <code>UP</code> 或则 <code>OUT_OF_SERVICE</code> ，保留当前状态。原因，<strong>禁止 Eureka-Client 主动在这两个状态之间切换。如果要切换，使用应用实例覆盖状态变更与删除接口</strong>。</li><li>AlwaysMatchInstanceStatusRule ，使用 <code>instanceInfo</code> 的状态返回，以保证能匹配到状态。</li><li>在下文中，你会看到，<code>#getOverriddenInstanceStatus()</code> 方法会在<strong>注册</strong>和<strong>续租</strong>使用到。结合上图，我们在 <a href="#">「4.2 注册场景」</a> 和 <a href="#">「4.3 续租场景」</a> 也会详细解析。</li></ul><ul><li>在下文中，你会看到，<code>#getOverriddenInstanceStatus()</code> 方法会在<strong>注册</strong>和<strong>续租</strong>使用到，方法参数 <code>instanceInfo</code> 情况如下：<ul><li><strong>注册时</strong> ：请求参数 <code>instanceInfo</code> ，和 <code>existingLease</code> 的应用实例属性不相等( 如果考虑 Eureka-Server 的 <code>LastDirtyTimestamp</code> 更大的情况，则类似 <strong>续租时的情况</strong> ) 。</li><li><strong>续租时</strong> ：使用 Eureka-Server 的 <code>existingLease</code> 的应用实例，两者相等。</li><li><strong>总的来说，可以将 <code>instanceInfo</code> 理解成请求方的状态</strong>。</li></ul></li><li>DownOrStartingRule ，</li></ul><h2>4.2 注册场景</h2><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// （(省略代码) ）获取锁</span></div><div class="line">  <span class="number">4</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</div><div class="line">  <span class="number">5</span>:         <span class="comment">// (省略代码) 增加 注册次数 到 监控</span></div><div class="line">  <span class="number">6</span>:         <span class="comment">// (省略代码) 获得 应用实例信息 对应的 租约</span></div><div class="line">  <span class="number">7</span>:         Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</div><div class="line">  <span class="number">8</span>:         <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></div><div class="line">  <span class="number">9</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123; <span class="comment">// (省略代码) 已存在时，使用数据不一致的时间大的应用注册信息为有效的</span></div><div class="line"> <span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">11</span>:             <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line"> <span class="number">12</span>:             <span class="comment">// (省略代码) 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"> <span class="number">13</span>:         &#125;</div><div class="line"> <span class="number">14</span>:         <span class="comment">// 创建 租约</span></div><div class="line"> <span class="number">15</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</div><div class="line"> <span class="number">16</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123; <span class="comment">// 若租约已存在，设置 租约的开始服务的时间戳</span></div><div class="line"> <span class="number">17</span>:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</div><div class="line"> <span class="number">18</span>:         &#125;</div><div class="line"> <span class="number">19</span>:         <span class="comment">// 添加到 租约映射</span></div><div class="line"> <span class="number">20</span>:         gMap.put(registrant.getId(), lease);</div><div class="line"> <span class="number">21</span>:         <span class="comment">// (省略代码) 添加到 最近注册的调试队列</span></div><div class="line"> <span class="number">22</span>:         <span class="comment">// (省略代码) 添加到 应用实例覆盖状态映射（Eureka-Server 初始化使用）</span></div><div class="line"> <span class="number">23</span>:         <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"> <span class="number">24</span>:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">26</span>:             logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</div><div class="line"> <span class="number">27</span>:             registrant.setOverriddenStatus(overriddenStatusFromMap);</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:         <span class="comment">// 获得 应用实例状态</span></div><div class="line"> <span class="number">31</span>:         <span class="comment">// Set the status based on the overridden status rules</span></div><div class="line"> <span class="number">32</span>:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</div><div class="line"> <span class="number">33</span>:         <span class="comment">// 设置 应用实例状态</span></div><div class="line"> <span class="number">34</span>:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"> <span class="number">35</span>: </div><div class="line"> <span class="number">36</span>:         <span class="comment">// (省略代码) 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"> <span class="number">37</span>:         <span class="comment">// (省略代码) 设置 应用实例信息的操作类型 为 添加</span></div><div class="line"> <span class="number">38</span>:         <span class="comment">// (省略代码) 添加到 最近租约变更记录队列</span></div><div class="line"> <span class="number">39</span>:         <span class="comment">// (省略代码) 设置 租约的最后更新时间戳</span></div><div class="line"> <span class="number">40</span>:         <span class="comment">// (省略代码) 设置 响应缓存 过期</span></div><div class="line"> <span class="number">41</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">42</span>:         <span class="comment">// (省略代码) 释放锁</span></div><div class="line"> <span class="number">43</span>:     &#125;</div><div class="line"> <span class="number">44</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 7 行 ：获得<strong>已存在</strong>的租约( <code>existingLease</code> ) 。</li><li>第 15 行 ：创建<strong>新的</strong>租约( <code>lease</code> )。</li><li>第 24 至 28 行 ：设置应用实例的覆盖状态( <code>overridestatus</code> )，避免注册应用实例后，丢失覆盖状态。</li><li>第 30 至 32 行 ：<strong>获得应用实例最终状态</strong>。注意下，不考虑第 9 行代码的情况，<code>registrant</code> 和 <code>existingLease</code> 的应用实例不是同一个对象。</li><li>第 33 只 34 行 ：设置应用实例的状态。</li></ul><h2>4.3 续租场景</h2><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// （省略代码）增加 续租次数 到 监控</span></div><div class="line">  <span class="number">3</span>:     <span class="comment">// 获得 租约</span></div><div class="line">  <span class="number">4</span>:     Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line">  <span class="number">5</span>:     Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line">  <span class="number">6</span>:     <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:         leaseToRenew = gMap.get(id);</div><div class="line">  <span class="number">8</span>:     &#125;</div><div class="line">  <span class="number">9</span>:     <span class="comment">// （省略代码）租约不存在</span></div><div class="line"> <span class="number">10</span>:     <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">11</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">12</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">13</span>:         InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line"> <span class="number">14</span>:         <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">15</span>:             <span class="comment">// 获得 应用实例状态</span></div><div class="line"> <span class="number">16</span>:             InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line"> <span class="number">17</span>:                     instanceInfo, leaseToRenew, isReplication);</div><div class="line"> <span class="number">18</span>:             <span class="comment">// 应用实例状态未知，无法续约</span></div><div class="line"> <span class="number">19</span>:             <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line"> <span class="number">20</span>:                 logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line"> <span class="number">21</span>:                         + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line"> <span class="number">22</span>:                 RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"> <span class="number">23</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>:             <span class="comment">// 设置 应用实例状态</span></div><div class="line"> <span class="number">26</span>:             <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line"> <span class="number">27</span>:                 Object[] args = &#123;</div><div class="line"> <span class="number">28</span>:                         instanceInfo.getStatus().name(),</div><div class="line"> <span class="number">29</span>:                         instanceInfo.getOverriddenStatus().name(),</div><div class="line"> <span class="number">30</span>:                         instanceInfo.getId()</div><div class="line"> <span class="number">31</span>:                 &#125;;</div><div class="line"> <span class="number">32</span>:                 logger.info(</div><div class="line"> <span class="number">33</span>:                         <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line"> <span class="number">34</span>:                                 + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line"> <span class="number">35</span>:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"> <span class="number">36</span>:             &#125;</div><div class="line"> <span class="number">37</span>:         &#125;</div><div class="line"> <span class="number">38</span>:         <span class="comment">// （省略代码）新增 续租每分钟次数</span></div><div class="line"> <span class="number">39</span>:         <span class="comment">// （省略代码）设置 租约最后更新时间（续租）</span></div><div class="line"> <span class="number">40</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> <span class="number">41</span>:     &#125;</div><div class="line"> <span class="number">42</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 15 至 17 行 ：获得应用实例的<strong>最终状态</strong>。</li><li>第 18 至 24 行 ：应用实例的<strong>最终状态</strong>为 <code>UNKNOWN</code>，无法续约 。返回 <code>false</code> 后，请求方( Eureka-Client 或者 Eureka-Server 集群其他节点 )会发起注册，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析。<strong>为什么会是 <code>UNKNOWN</code> 呢</strong>？在 <a href="#">「3. 应用实例覆盖状态删除接口」</a> 传递应用实例状态为 <code>UNKNOWN</code> 。</li><li>第 25 至 36 行 ：应用实例的状态与<strong>最终状态</strong>不相等，使用<strong>最终状态</strong>覆盖应用实例的状态。<strong>为什么会不相等</strong>呢？<code>#renew(...)</code> 和 <code>#statusUpdate(...)</code> 可以无锁，并行执行，如果<ul><li><code>#renew(...)</code> 执行完第 16 行代码，获取到 <code>overriddenInstanceStatus</code> 后，恰巧 <code>#statusUpdate(...)</code> 执行完更新应用实例状态 <code>newStatus</code>，又恰好两者不相等，使用 <code>overriddenInstanceStatus</code> 覆盖掉应用实例的 <code>newStatus</code> 状态。</li><li><strong>那岂不是覆盖状态( <code>overriddenstatus</code> )反倒被覆盖</strong>？？？不会，在下一次心跳，应用实例的状态会被修正回来。当然，如果应用实例状态如果为 <code>UP</code> 或者 <code>STARTING</code> 不会被修正，也不应该被修正。</li></ul></li></ul><h2>4.4 下线场景</h2><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// 移除 应用实例覆盖状态映射</span></div><div class="line">    InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</div><div class="line">    <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</div><div class="line">        logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>4.5 过期场景</h2><p>同 <a href="#">「4.4 下线场景」</a> 相同。</p><h1>5. 客户端调用接口</h1><p>对应用实例覆盖状态的变更和删除接口调用，点击如下方法查看，非常易懂，本文就不啰嗦了：</p><ul><li><a href="https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractJerseyEurekaHttpClient#statusUpdate(...)</code></a></li><li><a href="https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractJerseyEurekaHttpClient#deleteStatusOverride(...)</code></a></li></ul><h1>666. 彩蛋</h1><p>猜测覆盖状态的花费了较长时间，梳理应用实例覆盖规则耗费大量脑细胞。</p><p>下一篇，让我鸡鸡动动的，Eureka-Server 集群同步走起！</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-override-status/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/stron
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（七）之增量获取</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2. 应用集合一致性哈希码</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2.1 计算公式</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2.2 合理性</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3. Eureka-Client 发起增量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.1 合并应用集合</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">4. Eureka-Server 接收全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.1 接收全量获取请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.2 最近租约变更记录队列</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.3 缓存读取</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 获取增量注册信息的过程</strong>。</p><p>前置阅读：<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》</a></p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/01.png" alt=""></p></blockquote><p>Eureka-Client 获取注册信息，分成<strong>全量获取</strong>和<strong>增量获取</strong>。默认配置下，Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，而后每 <strong>30</strong> 秒<strong>增量</strong>获取刷新<strong>本地缓存</strong>( 非“<strong>正常</strong>”情况下会是全量获取 )。</p><p>本文重点在于<strong>增量获取</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 应用集合一致性哈希码</h1><p><code>Applications.appsHashCode</code> ，应用集合<strong>一致性哈希码</strong>。</p><p><strong>增量</strong>获取注册的应用集合( Applications ) 时，Eureka-Client 会获取到：</p><ol><li>Eureka-Server 近期变化( 注册、下线 )的应用集合</li><li>Eureka-Server 应用集合一致性哈希码</li></ol><p>Eureka-Client 将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并后进行计算本地的应用集合一致性哈希码。若两个<strong>哈希码</strong>相等，意味着增量获取成功；若不相等，意味着增量获取失败，Eureka-Client 重新和 Eureka-Server <strong>全量</strong>获取应用集合。</p><p>Eureka 比较应用集合一致性哈希码，和日常我们通过哈希码比较两个对象是否相等类似。</p><h2>2.1 计算公式</h2><p><code>appsHashCode = ${status}_${count}_</code></p><ul><li><p>使用每个应用实例状态( <code>status</code> ) + 数量( <code>count</code> )拼接出一致性哈希码。若数量为 0 ，该应用实例状态不进行拼接。<strong>状态以字符串大小排序</strong>。</p></li><li><p>举个例子，8 个 UP ，0 个 DOWN ，则 <code>appsHashCode = UP_8_</code> 。8 个 UP ，2 个 DOWN ，则 <code>appsHashCode = DOWN_2_UP_8_</code> 。</p></li><li><p>实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getReconcileHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 计数集合 key：应用实例状态</span></div><div class="line">   TreeMap&lt;String, AtomicInteger&gt; instanceCountMap = <span class="keyword">new</span> TreeMap&lt;String, AtomicInteger&gt;();</div><div class="line">   populateInstanceCountMap(instanceCountMap);</div><div class="line">   <span class="comment">// 计算 hashcode</span></div><div class="line">   <span class="keyword">return</span> getReconcileHashCode(instanceCountMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#populateInstanceCountMap()</code> 方法，计算每个应用实例状态的数量。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateInstanceCountMap</span><span class="params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Application app : <span class="keyword">this</span>.getRegisteredApplications()) &#123;</div><div class="line">       <span class="keyword">for</span> (InstanceInfo info : app.getInstancesAsIsFromEureka()) &#123;</div><div class="line">           <span class="comment">// 计数</span></div><div class="line">           AtomicInteger instanceCount = instanceCountMap.computeIfAbsent(info.getStatus().name(),</div><div class="line">                   k -&gt; <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>));</div><div class="line">           instanceCount.incrementAndGet();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Application&gt; <span class="title">getRegisteredApplications</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Application&gt;(<span class="keyword">this</span>.applications);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;InstanceInfo&gt; <span class="title">getInstancesAsIsFromEureka</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;InstanceInfo&gt;(<span class="keyword">this</span>.instances);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>计数那块代码，使用 Integer 即可，无需使用 AtomicInteger 。</li></ul></li></ul></li><li><p>调用 <code>#getReconcileHashCode()</code> 方法，计算 <code>hashcode</code> 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getReconcileHashCode</span><span class="params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>&#123;</div><div class="line">   StringBuilder reconcileHashCode = <span class="keyword">new</span> StringBuilder(<span class="number">75</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, AtomicInteger&gt; mapEntry : instanceCountMap.entrySet()) &#123;</div><div class="line">       reconcileHashCode.append(mapEntry.getKey()).append(STATUS_DELIMITER) <span class="comment">// status</span></div><div class="line">               .append(mapEntry.getValue().get()).append(STATUS_DELIMITER); <span class="comment">// count</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> reconcileHashCode.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h2>2.2 合理性</h2><p><strong>本小节，建议你理解完全文后，再回到此处</strong><br><strong>本小节，建议你理解完全文后，再回到此处</strong><br><strong>本小节，建议你理解完全文后，再回到此处</strong></p><p>笔者刚看完应用集合一致性哈希算法的计算公式，处于一脸懵逼的状态。这么精简的方式真的能够校验出数据的一致性么？不晓得有多少读者跟笔者有一样的疑惑。下面我们来论证该算法的合理性( 一本正经的胡说八道 )。</p><p>一致性哈希值通过<strong>状态 + 数量</strong>来计算，那么是不是可能状态总数是一样多，实际分布在不同的应用？那么我们列举模型如下：</p><table><thead><tr><th></th><th>UP</th></tr></thead><tbody><tr><td>应用A</td><td>m</td></tr><tr><td>应用B</td><td>n</td></tr></tbody></table><p>如果此时应用A 下线了 c 个原应用实例，应用B 注册了 c 个信应用实例，那么处于 UP 状态的数量仍然是 m + n 个。</p><ul><li>正常情况下，Eureka-Client 从 Eureka-Server 获取到<strong>完整的增量变化</strong>并合并，此时应用情况如下表格所示，两者是一致的，一致性哈希算法<strong>合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m - c</td></tr><tr><td>应用B</td><td>n + c</td><td>n + c</td></tr></tbody></table><ul><li>异常情况下【1】，变更记录队列全部过期。那 Eureka-Client 从 Eureka-Server 获取到<strong>空的增量变化</strong>并合并，此时应用情况如下表格所示，两者应用是不相同的， 一致性哈希值却是相等的，一致性哈希算法<strong>不合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m</td></tr><tr><td>应用B</td><td>n + c</td><td>n</td></tr></tbody></table><ul><li>异常情况下【2】，变更记录队列部分过期，例如应用A 和 应用B 都剩余 w 条变更记录。那 Eureka-Client 从 Eureka-Server 获取到<strong>部分的增量变化</strong>并合并，两者应用是不相同的，此时应用情况如下表格所示，一致性哈希值却是相等的，一致性哈希算法<strong>不合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m - w</td></tr><tr><td>应用B</td><td>n + c</td><td>n + w</td></tr></tbody></table><p>What ？ 从异常情况【1】【2】可以看到，一致性哈希算法竟然是<strong>不合理</strong>的，那么我们手动来做一次最精简的实验。实验如下：</p><ul><li>模拟场景：异常情况【1】，m = n = c = 1 。简单粗暴。</li><li>特别配置<ul><li><code>eureka.retentionTimeInMSInDeltaQueue = 1</code> ，变更记录队列每条记录存活时长 1 ms。用以实现 Eureka-Client 请求不到完整的增量变化。</li><li><code>eureka.deltaRetentionTimerIntervalInMs = 1</code> ，变更记录队列每条记录过期定时任务执行频率 1 ms。用以实现 Eureka-Client 请求不到完整的增量变化。</li><li><code>eureka.shouldUseReadOnlyResponseCache = false</code> ，禁用响应缓存的只读缓存。用以避免等待缓存刷新。</li><li><code>eureka.waitTimeInMsWhenSyncEmpty = 1</code> ，</li></ul></li><li>实验过程<ol><li>00:00 启动 Eureka-Server</li><li>00:30 启动应用A ，向 Eureka-Server 注册</li><li>01:00 启动 Eureka-Client ，向 Eureka-Server 获取注册信息，等待获取到应用A</li><li>01:30 关闭应用A 。立即启动应用B ，向 Eureka-Server 注册</li><li>等待 5 分钟，Eureka-Client 无法获取到应用B</li><li>此时应用情况如下表格所示，两者应用是不相同的，一致性哈希值却是相等的，一致性哈希算法<strong>不合理。</strong></li></ol></li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>0</td><td>1</td></tr><tr><td>应用B</td><td>1</td><td>0</td></tr></tbody></table><p>🙂<strong>结论</strong>🙂</p><p>当然排除掉特别极端的场景，Eureka-Client 从 Eureka-Server 因为网络异常导致一直同步不到增量变化，又恰好应用关闭和开启满足状态统计数量。另外，变更记录队列记录过期时长为 300 秒，增量获取频率为 30 秒，获取的次数有 10 次左右。<strong>所以，应用集合一致性哈希码在绝大多数场景是合理的</strong>。<strong>笔者的YY</strong>，解决这个极小场景有如下方式：</p><ul><li>第一种，修改计算公式 <code>appsHashCode = MD5(${app_name}_${instance_id}_${status}_${count}_)</code> ，增加对应用名和应用实例编号敏感。</li><li>第二种，每 N 分钟进行一次全量获取注册信息。</li></ul><p>ps ：笔者怀着忐忑的心写完了这个小节，如果有不合理的地方，又或者有不同观点的胖友，欢迎一起探讨。谢谢。</p><p>TODO[0027][反思]：应用集合一致性哈希算法。</p><h1>3. Eureka-Client 发起增量获取</h1><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「2.4 发起获取注册信息」</a> 里，调用 <code>DiscoveryClient#getAndUpdateDelta(...)</code> 方法，<strong>增量</strong>获取注册信息，并<strong>刷新</strong>本地缓存，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndUpdateDelta</span><span class="params">(Applications applications)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="comment">// 增量获取注册信息</span></div><div class="line"> <span class="number">5</span>:     Applications delta = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());</div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</div><div class="line"> <span class="number">8</span>:         delta = httpResponse.getEntity();</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (delta == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 增量获取为空，全量获取</span></div><div class="line"><span class="number">13</span>:         logger.warn(<span class="string">"The server does not allow the delta revision to be applied because it is not safe. "</span></div><div class="line"><span class="number">14</span>:                 + <span class="string">"Hence got the full registry."</span>);</div><div class="line"><span class="number">15</span>:         getAndStoreFullRegistry();</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">17</span>:         logger.debug(<span class="string">"Got delta update with apps hashcode &#123;&#125;"</span>, delta.getAppsHashCode());</div><div class="line"><span class="number">18</span>:         String reconcileHashCode = <span class="string">""</span>;</div><div class="line"><span class="number">19</span>:         <span class="keyword">if</span> (fetchRegistryUpdateLock.tryLock()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                 <span class="comment">// 将变化的应用集合和本地缓存的应用集合进行合并</span></div><div class="line"><span class="number">22</span>:                 updateDelta(delta);</div><div class="line"><span class="number">23</span>:                 <span class="comment">// 计算本地的应用集合一致性哈希码</span></div><div class="line"><span class="number">24</span>:                 reconcileHashCode = getReconcileHashCode(applications);</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">26</span>:                 fetchRegistryUpdateLock.unlock();</div><div class="line"><span class="number">27</span>:             &#125;</div><div class="line"><span class="number">28</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">29</span>:             logger.warn(<span class="string">"Cannot acquire update lock, aborting getAndUpdateDelta"</span>);</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:         <span class="comment">// There is a diff in number of instances for some reason</span></div><div class="line"><span class="number">32</span>:         <span class="keyword">if</span> (!reconcileHashCode.equals(delta.getAppsHashCode()) <span class="comment">// 一致性哈希值不相等</span></div><div class="line"><span class="number">33</span>:                 || clientConfig.shouldLogDeltaDiff()) &#123; <span class="comment">//</span></div><div class="line"><span class="number">34</span>:             reconcileAndLogDifference(delta, reconcileHashCode);  <span class="comment">// this makes a remoteCall</span></div><div class="line"><span class="number">35</span>:         &#125;</div><div class="line"><span class="number">36</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">37</span>:         logger.warn(<span class="string">"Not updating application delta as another thread is updating it already"</span>);</div><div class="line"><span class="number">38</span>:         logger.debug(<span class="string">"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already"</span>, delta.getAppsHashCode());</div><div class="line"><span class="number">39</span>:     &#125;</div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 至 9 行 ：请求<strong>增量</strong>获取注册信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getDelta</span><span class="params">(String... regions)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> getApplicationsInternal(<span class="string">"apps/delta"</span>, regions);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#getApplicationsInternal(...)</code> 方法，GET 请求 Eureka-Server 的 <code>apps/detla</code> 接口，参数为 <code>regions</code> ，返回格式为 JSON ，实现增量获取注册信息。</li></ul></li><li><p>第 11 至 15 行 ：<strong>增量</strong>获取失败，调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。该方法在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「2.4.1 全量获取注册信息，并设置到本地缓存」</a> 有详细解析。</p></li><li><p>第 16 至 35 行 ：处理<strong>增量</strong>获取的结果。</p><ul><li>第 16 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 19 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 21 行 ：调用 <code>#updateDelta(...)</code> 方法，将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并。</li><li>第 31 至 35 行 ：一致性哈希值不相等，调用 <code>#reconcileAndLogDifference()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存，和 <code>#getAndStoreFullRegistry()</code> 基本类似。<ul><li>第 33 行 ：配置 <code>eureka.printDeltaFullDiff</code> ，是否打印增量和全量差异。默认值 ：<code>false</code> 。从目前代码实现上来看，暂时没有生效。<strong>注意</strong> ：开启该参数会导致每次<strong>增量</strong>获取后又发起<strong>全量</strong>获取，不要开启。</li></ul></li></ul></li></ul><h2>3.1 合并应用集合</h2><p>调用 <code>#updateDelta(...)</code> 方法，将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDelta</span><span class="params">(Applications delta)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">int</span> deltaCount = <span class="number">0</span>;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">for</span> (Application app : delta.getRegisteredApplications()) &#123; <span class="comment">// 循环增量（变化）应用集合</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"> <span class="number">5</span>:             Applications applications = getApplications();</div><div class="line"> <span class="number">6</span>:             <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">7</span>:             String instanceRegion = instanceRegionChecker.getInstanceRegion(instance);</div><div class="line"> <span class="number">8</span>:             <span class="keyword">if</span> (!instanceRegionChecker.isLocalRegion(instanceRegion)) &#123;</div><div class="line"> <span class="number">9</span>:                 Applications remoteApps = remoteRegionVsApps.get(instanceRegion);</div><div class="line"><span class="number">10</span>:                 <span class="keyword">if</span> (<span class="keyword">null</span> == remoteApps) &#123;</div><div class="line"><span class="number">11</span>:                     remoteApps = <span class="keyword">new</span> Applications();</div><div class="line"><span class="number">12</span>:                     remoteRegionVsApps.put(instanceRegion, remoteApps);</div><div class="line"><span class="number">13</span>:                 &#125;</div><div class="line"><span class="number">14</span>:                 applications = remoteApps;</div><div class="line"><span class="number">15</span>:             &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:             ++deltaCount;</div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (ActionType.ADDED.equals(instance.getActionType())) &#123; <span class="comment">// 添加</span></div><div class="line"><span class="number">19</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 logger.debug(<span class="string">"Added instance &#123;&#125; to the existing apps in region &#123;&#125;"</span>, instance.getId(), instanceRegion);</div><div class="line"><span class="number">24</span>:                 applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActionType.MODIFIED.equals(instance.getActionType())) &#123; <span class="comment">// 修改</span></div><div class="line"><span class="number">26</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">27</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">29</span>:                 &#125;</div><div class="line"><span class="number">30</span>:                 logger.debug(<span class="string">"Modified instance &#123;&#125; to the existing apps "</span>, instance.getId());</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:                 applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);</div><div class="line"><span class="number">33</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActionType.DELETED.equals(instance.getActionType())) &#123; <span class="comment">// 删除</span></div><div class="line"><span class="number">34</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">36</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">37</span>:                 &#125;</div><div class="line"><span class="number">38</span>:                 logger.debug(<span class="string">"Deleted instance &#123;&#125; to the existing apps "</span>, instance.getId());</div><div class="line"><span class="number">39</span>:                 applications.getRegisteredApplications(instance.getAppName()).removeInstance(instance);</div><div class="line"><span class="number">40</span>:             &#125;</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:     &#125;</div><div class="line"><span class="number">43</span>:     logger.debug(<span class="string">"The total number of instances fetched by the delta processor : &#123;&#125;"</span>, deltaCount);</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     getApplications().setVersion(delta.getVersion());</div><div class="line"><span class="number">46</span>:     <span class="comment">// 过滤、打乱应用集合</span></div><div class="line"><span class="number">47</span>:     getApplications().shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">50</span>:     <span class="keyword">for</span> (Applications applications : remoteRegionVsApps.values()) &#123;</div><div class="line"><span class="number">51</span>:         applications.setVersion(delta.getVersion());</div><div class="line"><span class="number">52</span>:         applications.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());</div><div class="line"><span class="number">53</span>:     &#125;</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 6 至 15 行 ：TODO[0009]：RemoteRegionRegistry</p></li><li><p>第 18 至 24 行 ：添加( ADDED )应用实例时，调用 <code>Application#addInstance(...)</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Application.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(InstanceInfo i)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 应用实例映射</span></div><div class="line">   instancesMap.put(i.getId(), i);</div><div class="line">   <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">       <span class="comment">// 移除原有实例</span></div><div class="line">       instances.remove(i);</div><div class="line">       <span class="comment">// 添加新实例</span></div><div class="line">       instances.add(i);</div><div class="line">       <span class="comment">// 设置 isDirty ，目前只用于 `#toString()` 方法打印，无业务逻辑</span></div><div class="line">       isDirty = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="comment">// 只使用 ID 计算 hashcode</span></div><div class="line">   String id = getId();</div><div class="line">   <span class="keyword">return</span> (id == <span class="keyword">null</span>) ? <span class="number">31</span> : (id.hashCode() + <span class="number">31</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; <span class="comment">// 只对比 ID</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   InstanceInfo other = (InstanceInfo) obj;</div><div class="line">   String id = getId();</div><div class="line">   <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">if</span> (other.getId() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!id.equals(other.getId())) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 25 至 32 行 ：修改( MODIFIED )应用实例时，<strong>同样</strong>调用 <code>Application#addInstance(...)</code> 方法。</p></li><li><p>第 33 至 40 行 ：删除( DELETED )应用实例时，调用 <code>Application#removeInstance(...)</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeInstance</span><span class="params">(InstanceInfo i)</span> </span>&#123;</div><div class="line">    removeInstance(i, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeInstance</span><span class="params">(InstanceInfo i, <span class="keyword">boolean</span> markAsDirty)</span> </span>&#123;</div><div class="line">    <span class="comment">// 移除 应用实例映射</span></div><div class="line">    instancesMap.remove(i.getId());</div><div class="line">    <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">        <span class="comment">// 移除 应用实例</span></div><div class="line">        instances.remove(i);</div><div class="line">        <span class="keyword">if</span> (markAsDirty) &#123;</div><div class="line">            <span class="comment">// 设置 isDirty ，目前只用于 `#toString()` 方法打印，无业务逻辑</span></div><div class="line">            isDirty = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 47 行 ：调用 <code>Applications#shuffleInstances(...)</code> 方法，根据配置 <code>eureka.shouldFilterOnlyUpInstances = true</code> ( 默认值 ：<code>true</code> ) 过滤只保留状态为开启( UP )的应用实例，并<strong>随机打乱</strong>应用实例顺序。打乱后，实现调用应用服务的随机性。代码比较易懂，点击<a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java#L286" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看方法实现。</p></li><li><p>第 49 至 53 行 ：TODO[0009]：RemoteRegionRegistry</p></li></ul><h1>4. Eureka-Server 接收全量获取</h1><h2>3.1 接收全量获取请求</h2><p><code>com.netflix.eureka.resources.ApplicationsResource</code>，处理<strong>所有</strong>应用的请求操作的 Resource ( Controller )。</p><p>接收增量获取请求，映射 <code>ApplicationsResource#getContainers()</code> 方法。</p><ul><li>和 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.1 接收全量获取请求」</a> 类似，就不重复啰嗦啦。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/225a81d9818d355503ad802363448eb29c374b6f/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java#L190" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的<strong>带中文注释</strong>代码。</li></ul><h2>3.2 最近租约变更记录队列</h2><p><code>AbstractInstanceRegistry.recentlyChangedQueue</code>，最近租约变更记录队列。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentlyChangedItem</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 最后更新时间戳</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 租约</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> Lease&lt;InstanceInfo&gt; leaseInfo;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RecentlyChangedItem</span><span class="params">(Lease&lt;InstanceInfo&gt; lease)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.leaseInfo = lease;</div><div class="line">       lastUpdateTime = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastUpdateTime;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Lease&lt;InstanceInfo&gt; <span class="title">getLeaseInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.leaseInfo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>当应用实例注册、下线、状态变更时，创建最近租约变更记录( RecentlyChangedItem ) 到队列。</p></li><li><p>后台任务定时<strong>顺序</strong>扫描队列，当 <code>lastUpdateTime</code> 超过一定时长后进行移除。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="keyword">this</span>.deltaRetentionTimer.schedule(getDeltaRetentionTask(),</div><div class="line">                serverConfig.getDeltaRetentionTimerIntervalInMs(),</div><div class="line">                serverConfig.getDeltaRetentionTimerIntervalInMs());</div><div class="line">                </div><div class="line"><span class="function"><span class="keyword">private</span> TimerTask <span class="title">getDeltaRetentionTask</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           Iterator&lt;RecentlyChangedItem&gt; it = recentlyChangedQueue.iterator();</div><div class="line">           <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">               <span class="keyword">if</span> (it.next().getLastUpdateTime() &lt; System.currentTimeMillis() - serverConfig.getRetentionTimeInMSInDeltaQueue()) &#123;</div><div class="line">                   it.remove();</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>配置 <code>eureka.deltaRetentionTimerIntervalInMs</code>， 移除队列里过期的租约变更记录的定时任务执行频率，单位：毫秒。默认值 ：30 * 1000 毫秒。</li><li>配置 <code>eureka.retentionTimeInMSInDeltaQueue</code>，租约变更记录过期时长，单位：毫秒。默认值 ： 3 * 60 * 1000 毫秒。</li></ul></li></ul><h2>3.3 缓存读取</h2><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.3 缓存读取」</a> 里，在 <code>#generatePayload()</code> 方法里，调用 <code>AbstractInstanceRegistry#getApplicationDeltas(...)</code> 方法，获取近期变化的应用集合，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltas</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 添加 增量获取次数 到 监控</span></div><div class="line">  <span class="number">3</span>:     GET_ALL_CACHE_MISS_DELTA.increment();</div><div class="line">  <span class="number">4</span>:     <span class="comment">// 初始化 变化的应用集合</span></div><div class="line">  <span class="number">5</span>:     Applications apps = <span class="keyword">new</span> Applications();</div><div class="line">  <span class="number">6</span>:     apps.setVersion(responseCache.getVersionDelta().get());</div><div class="line">  <span class="number">7</span>:     Map&lt;String, Application&gt; applicationInstancesMap = <span class="keyword">new</span> HashMap&lt;String, Application&gt;();</div><div class="line">  <span class="number">8</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">9</span>:         <span class="comment">// 获取写锁 TODO why？</span></div><div class="line"> <span class="number">10</span>:         write.lock();</div><div class="line"> <span class="number">11</span>:         <span class="comment">// 获取 最近租约变更记录队列</span></div><div class="line"> <span class="number">12</span>:         Iterator&lt;RecentlyChangedItem&gt; iter = <span class="keyword">this</span>.recentlyChangedQueue.iterator();</div><div class="line"> <span class="number">13</span>:         logger.debug(<span class="string">"The number of elements in the delta queue is :"</span> + <span class="keyword">this</span>.recentlyChangedQueue.size());</div><div class="line"> <span class="number">14</span>:         <span class="comment">// 拼装 变化的应用集合</span></div><div class="line"> <span class="number">15</span>:         <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line"> <span class="number">16</span>:             Lease&lt;InstanceInfo&gt; lease = iter.next().getLeaseInfo();</div><div class="line"> <span class="number">17</span>:             InstanceInfo instanceInfo = lease.getHolder();</div><div class="line"> <span class="number">18</span>:             Object[] args = &#123;instanceInfo.getId(), instanceInfo.getStatus().name(), instanceInfo.getActionType().name()&#125;;</div><div class="line"> <span class="number">19</span>:             logger.debug(<span class="string">"The instance id %s is found with status %s and actiontype %s"</span>, args);</div><div class="line"> <span class="number">20</span>:             Application app = applicationInstancesMap.get(instanceInfo.getAppName());</div><div class="line"> <span class="number">21</span>:             <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">22</span>:                 app = <span class="keyword">new</span> Application(instanceInfo.getAppName());</div><div class="line"> <span class="number">23</span>:                 applicationInstancesMap.put(instanceInfo.getAppName(), app);</div><div class="line"> <span class="number">24</span>:                 apps.addApplication(app);</div><div class="line"> <span class="number">25</span>:             &#125;</div><div class="line"> <span class="number">26</span>:             app.addInstance(decorateInstanceInfo(lease));</div><div class="line"> <span class="number">27</span>:         &#125;</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:         <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">30</span>:         <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</div><div class="line"> <span class="number">31</span>:         <span class="keyword">if</span> (!disableTransparentFallback) &#123;</div><div class="line"> <span class="number">32</span>:             Applications allAppsInLocalRegion = getApplications(<span class="keyword">false</span>);</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:             <span class="keyword">for</span> (RemoteRegionRegistry remoteRegistry : <span class="keyword">this</span>.regionNameVSRemoteRegistry.values()) &#123;</div><div class="line"> <span class="number">35</span>:                 Applications applications = remoteRegistry.getApplicationDeltas();</div><div class="line"> <span class="number">36</span>:                 <span class="keyword">for</span> (Application application : applications.getRegisteredApplications()) &#123;</div><div class="line"> <span class="number">37</span>:                     Application appInLocalRegistry =</div><div class="line"> <span class="number">38</span>:                             allAppsInLocalRegion.getRegisteredApplications(application.getName());</div><div class="line"> <span class="number">39</span>:                     <span class="keyword">if</span> (appInLocalRegistry == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">40</span>:                         apps.addApplication(application);</div><div class="line"> <span class="number">41</span>:                     &#125;</div><div class="line"> <span class="number">42</span>:                 &#125;</div><div class="line"> <span class="number">43</span>:             &#125;</div><div class="line"> <span class="number">44</span>:         &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:         <span class="comment">// 获取全量应用集合，通过它计算一致性哈希值</span></div><div class="line"> <span class="number">47</span>:         Applications allApps = getApplications(!disableTransparentFallback);</div><div class="line"> <span class="number">48</span>:         apps.setAppsHashCode(allApps.getReconcileHashCode());</div><div class="line"> <span class="number">49</span>:         <span class="keyword">return</span> apps;</div><div class="line"> <span class="number">50</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">51</span>:         write.unlock();</div><div class="line"> <span class="number">52</span>:     &#125;</div><div class="line"> <span class="number">53</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 至 3 行 ：添加增量获取次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 4 行 ：初始化变化( 增量 )的应用集合( <code>apps</code> )。</li><li>第 9 行 ：TODO[0026] ：写锁</li><li>第 11 至 13 行 ：获取最近租约变更记录队列( <code>最近租约变更记录队列</code> )。</li><li>第 14 至 27 行 ：拼装变化的应用集合( <code>apps</code> )。</li><li>第 29 至 44 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 46 至 48 行 ：调用 <code>#getApplications(...)</code> 方法，获取<strong>全量</strong>应用集合( <code>allApps</code> )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.3.1 获得注册的应用集合」</a> 有详细解析。后通过 <code>allApps</code> 计算一致性哈希值。通过这个全量应用集合的哈希值，Eureka-Client 获取到增量应用集合并合并后，就可以比对啦。</li><li>第 51 行 ：释放写锁。</li></ul><h1>666. 彩蛋</h1><p>在汉堡王写完这篇热情的博客。为什么用“热情”这个字眼呢？大夏天的，竟然不开空调的！对的，没有开空调，简直是个小火炉。恩，不过静心写完这篇文章，让我还是挺嗨皮的。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（六）之全量获取</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-fetch-all/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-fetch-all/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2. Eureka-Client 发起全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.1 初始化全量获取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.2 定时获取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.3 刷新注册信息缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.4 发起获取注册信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3. Eureka-Server 接收全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.1 接收全量获取请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.2 响应缓存 ResponseCache</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.3 缓存读取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.4 主动过期读写缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.5 被动过期读写缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.6 定时刷新只读缓存</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 获取全量注册信息的过程</strong>。</p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/01.png" alt=""></p></blockquote><p>Eureka-Client 获取注册信息，分成<strong>全量获取</strong>和<strong>增量获取</strong>。默认配置下，Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，而后每 <strong>30</strong> 秒<strong>增量</strong>获取刷新<strong>本地缓存</strong>( 非“<strong>正常</strong>”情况下会是全量获取 )。</p><p>本文重点在于<strong>全量获取</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. Eureka-Client 发起全量获取</h1><p>本小节调用关系如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/03.png" alt=""></p><h2>2.1 初始化全量获取</h2><p>Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，首先代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Applications 在本地的缓存</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</div><div class="line"></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">                    </div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">     </div><div class="line">    <span class="comment">// 【3.2.5】初始化应用集合在本地的缓存</span></div><div class="line">    localRegionApps.set(<span class="keyword">new</span> Applications());</div><div class="line">     </div><div class="line">    <span class="comment">// ... 省略无关代码     </span></div><div class="line">     </div><div class="line">    <span class="comment">// 【3.2.12】从 Eureka-Server 拉取注册信息</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">        fetchRegistryFromBackup();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// ... 省略无关代码       </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.discovery.shared.Applications</code>，注册的应用集合。较为容易理解，点击 <a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 链接查看带中文注释的类，这里就不啰嗦了。Applications 与 InstanceInfo 类关系如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/02.png" alt=""></p></li><li><p>配置 <code>eureka.shouldFetchRegistry = true</code>，开启从 Eureka-Server 获取注册信息。默认值：<code>true</code> 。</p></li><li><p>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server <strong>全量</strong>获取注册信息，在 <a href="#">「2.4 发起获取注册信息」</a> 详细解析。</p></li></ul><h2>2.2 定时获取</h2><p>Eureka-Client 在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">初始化</a>过程中，创建<strong>获取注册信息</strong>线程，<strong>固定间隔</strong>向 Eureka-Server 发起<strong>获取注册信息</strong>( fetch )，<strong>刷新</strong>本地注册信息<strong>缓存</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">               Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">               </div><div class="line">    <span class="comment">// 【3.2.9】初始化线程池</span></div><div class="line">    <span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></div><div class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">         <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                 .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">                 .setDaemon(<span class="keyword">true</span>)</div><div class="line">                 .build());</div><div class="line">    </div><div class="line">    cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">         <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">         <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">         <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                 .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</div><div class="line">                 .setDaemon(<span class="keyword">true</span>)</div><div class="line">                 .build()</div><div class="line">     );  <span class="comment">// use direct handoff</span></div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// 【3.2.14】初始化定时任务</span></div><div class="line">    initScheduledTasks();</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line">       <span class="comment">// registry cache refresh timer</span></div><div class="line">       <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"cacheRefresh"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       cacheRefreshExecutor,</div><div class="line">                       registryFetchIntervalSeconds,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> CacheRefreshThread()</div><div class="line">               ),</div><div class="line">               registryFetchIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>初始化定时任务代码，和<strong>续租</strong>的定时任务代码类似，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析，这里不重复分享。</p></li><li><p><code>com.netflix.discovery.DiscoveryClient.CacheRefreshThread</code>，注册信息缓存刷新任务，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheRefreshThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        refreshRegistry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>#refreshRegistry(false)</code> 方法，刷新注册信息缓存，在 <a href="#">「2.3 刷新注册信息缓存」</a> 详细解析。</li></ul></li></ul><h2>2.3 刷新注册信息缓存</h2><p>调用 <code>#refreshRegistry(false)</code> 方法，刷新注册信息缓存，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">refreshRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// TODO 芋艿：TODO[0009]：RemoteRegionRegistry</span></div><div class="line">  <span class="number">4</span>:         <span class="keyword">boolean</span> isFetchingRemoteRegionRegistries = isFetchingRemoteRegionRegistries();</div><div class="line">  <span class="number">5</span>: </div><div class="line">  <span class="number">6</span>:         <span class="keyword">boolean</span> remoteRegionsModified = <span class="keyword">false</span>;</div><div class="line">  <span class="number">7</span>:         <span class="comment">// This makes sure that a dynamic change to remote regions to fetch is honored.</span></div><div class="line">  <span class="number">8</span>:         String latestRemoteRegions = clientConfig.fetchRegistryForRemoteRegions();</div><div class="line">  <span class="number">9</span>:         <span class="keyword">if</span> (<span class="keyword">null</span> != latestRemoteRegions) &#123;</div><div class="line"> <span class="number">10</span>:             String currentRemoteRegions = remoteRegionsToFetch.get();</div><div class="line"> <span class="number">11</span>:             <span class="keyword">if</span> (!latestRemoteRegions.equals(currentRemoteRegions)) &#123;</div><div class="line"> <span class="number">12</span>:                 <span class="comment">// Both remoteRegionsToFetch and AzToRegionMapper.regionsToFetch need to be in sync</span></div><div class="line"> <span class="number">13</span>:                 <span class="keyword">synchronized</span> (instanceRegionChecker.getAzToRegionMapper()) &#123;</div><div class="line"> <span class="number">14</span>:                     <span class="keyword">if</span> (remoteRegionsToFetch.compareAndSet(currentRemoteRegions, latestRemoteRegions)) &#123;</div><div class="line"> <span class="number">15</span>:                         String[] remoteRegions = latestRemoteRegions.split(<span class="string">","</span>);</div><div class="line"> <span class="number">16</span>:                         remoteRegionsRef.set(remoteRegions);</div><div class="line"> <span class="number">17</span>:                         instanceRegionChecker.getAzToRegionMapper().setRegionsToFetch(remoteRegions);</div><div class="line"> <span class="number">18</span>:                         remoteRegionsModified = <span class="keyword">true</span>;</div><div class="line"> <span class="number">19</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">20</span>:                         logger.info(<span class="string">"Remote regions to fetch modified concurrently,"</span> +</div><div class="line"> <span class="number">21</span>:                                 <span class="string">" ignoring change from &#123;&#125; to &#123;&#125;"</span>, currentRemoteRegions, latestRemoteRegions);</div><div class="line"> <span class="number">22</span>:                     &#125;</div><div class="line"> <span class="number">23</span>:                 &#125;</div><div class="line"> <span class="number">24</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">25</span>:                 <span class="comment">// Just refresh mapping to reflect any DNS/Property change</span></div><div class="line"> <span class="number">26</span>:                 instanceRegionChecker.getAzToRegionMapper().refreshMapping();</div><div class="line"> <span class="number">27</span>:             &#125;</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:         <span class="keyword">boolean</span> success = fetchRegistry(remoteRegionsModified);</div><div class="line"> <span class="number">31</span>:         <span class="keyword">if</span> (success) &#123;</div><div class="line"> <span class="number">32</span>:             <span class="comment">// 设置 注册信息的应用实例数</span></div><div class="line"> <span class="number">33</span>:             registrySize = localRegionApps.get().size();</div><div class="line"> <span class="number">34</span>:             <span class="comment">// 设置 最后获取注册信息时间</span></div><div class="line"> <span class="number">35</span>:             lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();</div><div class="line"> <span class="number">36</span>:         &#125;</div><div class="line"> <span class="number">37</span>: </div><div class="line"> <span class="number">38</span>:         <span class="comment">// 打印日志</span></div><div class="line"> <span class="number">39</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"> <span class="number">40</span>:             StringBuilder allAppsHashCodes = <span class="keyword">new</span> StringBuilder();</div><div class="line"> <span class="number">41</span>:             allAppsHashCodes.append(<span class="string">"Local region apps hashcode: "</span>);</div><div class="line"> <span class="number">42</span>:             allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());</div><div class="line"> <span class="number">43</span>:             allAppsHashCodes.append(<span class="string">", is fetching remote regions? "</span>);</div><div class="line"> <span class="number">44</span>:             allAppsHashCodes.append(isFetchingRemoteRegionRegistries);</div><div class="line"> <span class="number">45</span>:             <span class="keyword">for</span> (Map.Entry&lt;String, Applications&gt; entry : remoteRegionVsApps.entrySet()) &#123;</div><div class="line"> <span class="number">46</span>:                 allAppsHashCodes.append(<span class="string">", Remote region: "</span>);</div><div class="line"> <span class="number">47</span>:                 allAppsHashCodes.append(entry.getKey());</div><div class="line"> <span class="number">48</span>:                 allAppsHashCodes.append(<span class="string">" , apps hashcode: "</span>);</div><div class="line"> <span class="number">49</span>:                 allAppsHashCodes.append(entry.getValue().getAppsHashCode());</div><div class="line"> <span class="number">50</span>:             &#125;</div><div class="line"> <span class="number">51</span>:             logger.debug(<span class="string">"Completed cache refresh task for discovery. All Apps hash code is &#123;&#125; "</span>,</div><div class="line"> <span class="number">52</span>:                     allAppsHashCodes.toString());</div><div class="line"> <span class="number">53</span>:         &#125;</div><div class="line"> <span class="number">54</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">55</span>:         logger.error(<span class="string">"Cannot fetch registry from server"</span>, e);</div><div class="line"> <span class="number">56</span>:     &#125;        </div><div class="line"> <span class="number">57</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 至 28 行 ：TODO[0009]：RemoteRegionRegistry</p></li><li><p>第 30 行 ：调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server 获取注册信息，在 <a href="#">「2.4 发起获取注册信息」</a> 详细解析。</p></li><li><p>第 31 至 36 行 ：获取注册信息成功，设置注册信息的应用实例数，最后获取注册信息时间。变量代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册信息的应用实例数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> registrySize = <span class="number">0</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功从 Eureka-Server 拉取注册信息时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulRegistryFetchTimestamp = -<span class="number">1</span>;</div></pre></td></tr></table></figure></p></li><li><p>第 38 至 53 行 ：打印调试日志。</p></li><li><p>第 54 至 56 行 ：打印<strong>异常</strong>日志。</p></li></ul><h2>2.4 发起获取注册信息</h2><p>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server 获取注册信息( 根据条件判断，可能是<strong>全量</strong>，也可能是<strong>增量</strong> )，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 获取 本地缓存的注册的应用实例集合</span></div><div class="line"> <span class="number">6</span>:         <span class="comment">// If the delta is disabled or if it is the first time, get all</span></div><div class="line"> <span class="number">7</span>:         <span class="comment">// applications</span></div><div class="line"> <span class="number">8</span>:         Applications applications = getApplications();</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// 全量获取</span></div><div class="line"><span class="number">11</span>:         <span class="keyword">if</span> (clientConfig.shouldDisableDelta() <span class="comment">// 禁用增量获取</span></div><div class="line"><span class="number">12</span>:                 || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</div><div class="line"><span class="number">13</span>:                 || forceFullRegistryFetch</div><div class="line"><span class="number">14</span>:                 || (applications == <span class="keyword">null</span>) <span class="comment">// 空</span></div><div class="line"><span class="number">15</span>:                 || (applications.getRegisteredApplications().size() == <span class="number">0</span>) <span class="comment">// 空</span></div><div class="line"><span class="number">16</span>:                 || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></div><div class="line"><span class="number">17</span>:         &#123;</div><div class="line"><span class="number">18</span>:             logger.info(<span class="string">"Disable delta property : &#123;&#125;"</span>, clientConfig.shouldDisableDelta());</div><div class="line"><span class="number">19</span>:             logger.info(<span class="string">"Single vip registry refresh property : &#123;&#125;"</span>, clientConfig.getRegistryRefreshSingleVipAddress());</div><div class="line"><span class="number">20</span>:             logger.info(<span class="string">"Force full registry fetch : &#123;&#125;"</span>, forceFullRegistryFetch);</div><div class="line"><span class="number">21</span>:             logger.info(<span class="string">"Application is null : &#123;&#125;"</span>, (applications == <span class="keyword">null</span>));</div><div class="line"><span class="number">22</span>:             logger.info(<span class="string">"Registered Applications size is zero : &#123;&#125;"</span>,</div><div class="line"><span class="number">23</span>:                     (applications.getRegisteredApplications().size() == <span class="number">0</span>));</div><div class="line"><span class="number">24</span>:             logger.info(<span class="string">"Application version is -1: &#123;&#125;"</span>, (applications.getVersion() == -<span class="number">1</span>));</div><div class="line"><span class="number">25</span>:             <span class="comment">// 执行 全量获取</span></div><div class="line"><span class="number">26</span>:             getAndStoreFullRegistry();</div><div class="line"><span class="number">27</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">28</span>:             <span class="comment">// 执行 增量获取</span></div><div class="line"><span class="number">29</span>:             getAndUpdateDelta(applications);</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:         <span class="comment">// 设置 应用集合 hashcode</span></div><div class="line"><span class="number">32</span>:         applications.setAppsHashCode(applications.getReconcileHashCode());</div><div class="line"><span class="number">33</span>:         <span class="comment">// 打印 本地缓存的注册的应用实例数量</span></div><div class="line"><span class="number">34</span>:         logTotalInstances();</div><div class="line"><span class="number">35</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">36</span>:         logger.error(PREFIX + appPathIdentifier + <span class="string">" - was unable to refresh its cache! status = "</span> + e.getMessage(), e);</div><div class="line"><span class="number">37</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">38</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">39</span>:         <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">40</span>:             tracer.stop();</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:     &#125;</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>:     <span class="comment">// Notify about cache refresh before updating the instance remote status</span></div><div class="line"><span class="number">45</span>:     onCacheRefreshed();</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>:     <span class="comment">// Update remote status based on refreshed data held in the cache</span></div><div class="line"><span class="number">48</span>:     updateInstanceRemoteStatus();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:     <span class="comment">// registry was fetched successfully, so return true</span></div><div class="line"><span class="number">51</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">52</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 5 至 8 行 ：获取本地缓存的注册的应用实例集合，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> localRegionApps.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 10 至 26 行 ：<strong>全量</strong>获取注册信息。</p><ul><li>第 11 行 ：配置 <code>eureka.disableDelta = true</code> ，禁用<strong>增量</strong>获取注册信息。默认值：<code>false</code> 。</li><li>第 12 行 ：TODO[0010]：getRegistryRefreshSingleVipAddress</li><li>第 13 行 ：方法参数 <code>forceFullRegistryFetch</code> 强制<strong>全量</strong>获取注册信息。</li><li>第 14 至 15 行 ：本地缓存为空。</li><li>第 25 至 26 行 ：调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。下文详细解析。</li></ul></li><li><p>第 27 至 30 行 ：<strong>增量</strong>获取注册信息，并刷新本地缓存，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</p></li><li><p>第 31 至 32 行 ：计算应用集合 <code>hashcode</code> 。该变量用于校验<strong>增量</strong>获取的注册信息和 Eureka-Server <strong>全量</strong>的注册信息是否一致( 完整 )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</p></li><li><p>第 33 至 34 行 ：打印调试日志，输出本地缓存的注册的应用实例数量。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logTotalInstances</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">       <span class="keyword">int</span> totInstances = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Application application : getApplications().getRegisteredApplications()) &#123;</div><div class="line">           totInstances += application.getInstancesAsIsFromEureka().size();</div><div class="line">       &#125;</div><div class="line">       logger.debug(<span class="string">"The total number of all instances in the client now is &#123;&#125;"</span>, totInstances);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 44 至 45 行 ：触发 CacheRefreshedEvent 事件，事件监听器执行。目前 Eureka 未提供默认的该事件监听器。</p><ul><li><p><code>#onCacheRefreshed()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Eureka 事件监听器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;EurekaEventListener&gt; eventListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCacheRefreshed</span><span class="params">()</span> </span>&#123;</div><div class="line">    fireEvent(<span class="keyword">new</span> CacheRefreshedEvent());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">(<span class="keyword">final</span> EurekaEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (EurekaEventListener listener : eventListeners) &#123;</div><div class="line">        listener.onEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p><strong>笔者的YY</strong> ：你可以实现自定义的事件监听器监听 CacheRefreshedEvent 事件，以达到<strong>持久化</strong>最新的注册信息到存储器( 例如，本地文件 )，通过这样的方式，配合实现 BackupRegistry 接口读取存储器。BackupRegistry 接口调用如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 【3.2.12】从 Eureka-Server 拉取注册信息</span></div><div class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">    fetchRegistryFromBackup();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul></li><li><p>第47 至 48 行 ：更新<strong>本地缓存</strong>的当前应用实例在 Eureka-Server 的状态。</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> InstanceInfo.InstanceStatus lastRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN; </div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateInstanceRemoteStatus</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="comment">// Determine this instance's status for this app and set to UNKNOWN if not found</span></div><div class="line"> <span class="number">5</span>:     InstanceInfo.InstanceStatus currentRemoteInstanceStatus = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (instanceInfo.getAppName() != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>:         Application app = getApplication(instanceInfo.getAppName());</div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">9</span>:             InstanceInfo remoteInstanceInfo = app.getByInstanceId(instanceInfo.getId());</div><div class="line"><span class="number">10</span>:             <span class="keyword">if</span> (remoteInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">11</span>:                 currentRemoteInstanceStatus = remoteInstanceInfo.getStatus();</div><div class="line"><span class="number">12</span>:             &#125;</div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (currentRemoteInstanceStatus == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">16</span>:         currentRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// Notify if status changed</span></div><div class="line"><span class="number">20</span>:     <span class="keyword">if</span> (lastRemoteInstanceStatus != currentRemoteInstanceStatus) &#123;</div><div class="line"><span class="number">21</span>:         onRemoteStatusChanged(lastRemoteInstanceStatus, currentRemoteInstanceStatus);</div><div class="line"><span class="number">22</span>:         lastRemoteInstanceStatus = currentRemoteInstanceStatus;</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 至 14 行 ：从注册信息中获取当前应用在 Eureka-Server 的状态。</p></li><li><p>第 19 至 23 行 ：对比<strong>本地缓存</strong>和<strong>最新的</strong>的当前应用实例在 Eureka-Server 的状态，若不同，更新<strong>本地缓存</strong>( <strong>注意，只更新该缓存变量，不更新本地当前应用实例的状态( <code>instanceInfo.status</code> )</strong> )，触发 StatusChangeEvent 事件，事件监听器执行。目前 Eureka 未提供默认的该事件监听器。<code>#onRemoteStatusChanged(...)</code> 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoteStatusChanged</span><span class="params">(InstanceInfo.InstanceStatus oldStatus, InstanceInfo.InstanceStatus newStatus)</span> </span>&#123;</div><div class="line">   fireEvent(<span class="keyword">new</span> StatusChangeEvent(oldStatus, newStatus));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>TODO[0024] ：client和server不同状态的原因</p></li></ul></li></ul><h3>2.4.1 全量获取注册信息，并设置到本地缓存</h3><p>调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。下实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     logger.info(<span class="string">"Getting all instance registry info from the eureka server"</span>);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// 全量获取注册信息</span></div><div class="line"> <span class="number">7</span>:     Applications apps = <span class="keyword">null</span>;</div><div class="line"> <span class="number">8</span>:     EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></div><div class="line"> <span class="number">9</span>:             ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</div><div class="line"><span class="number">10</span>:             : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</div><div class="line"><span class="number">12</span>:         apps = httpResponse.getEntity();</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>:     logger.info(<span class="string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:     <span class="comment">// 设置到本地缓存</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">if</span> (apps == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"The application is null for some reason. Not storing this information"</span>);</div><div class="line"><span class="number">19</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">20</span>:         localRegionApps.set(<span class="keyword">this</span>.filterAndShuffle(apps));</div><div class="line"><span class="number">21</span>:         logger.debug(<span class="string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:         logger.warn(<span class="string">"Not updating applications as another thread is updating it already"</span>);</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 6 至 14 行 ：<strong>全量</strong>获取注册信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getApplications</span><span class="params">(String... regions)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> getApplicationsInternal(<span class="string">"apps/"</span>, regions);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getApplicationsInternal</span><span class="params">(String urlPath, String[] regions)</span> </span>&#123;</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   String regionsParamValue = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       WebResource webResource = jerseyClient.resource(serviceUrl).path(urlPath);</div><div class="line">       <span class="keyword">if</span> (regions != <span class="keyword">null</span> &amp;&amp; regions.length &gt; <span class="number">0</span>) &#123;</div><div class="line">           regionsParamValue = StringUtil.join(regions);</div><div class="line">           webResource = webResource.queryParam(<span class="string">"regions"</span>, regionsParamValue);</div><div class="line">       &#125;</div><div class="line">       Builder requestBuilder = webResource.getRequestBuilder();</div><div class="line">       addExtraHeaders(requestBuilder);</div><div class="line">       response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class); <span class="comment">// JSON</span></div><div class="line"></div><div class="line">       Applications applications = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (response.getStatus() == Status.OK.getStatusCode() &amp;&amp; response.hasEntity()) &#123;</div><div class="line">           applications = response.getEntity(Applications.class);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus(), Applications.class)</div><div class="line">               .headers(headersOf(response))</div><div class="line">               .entity(applications)</div><div class="line">               .build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP GET &#123;&#125;/&#123;&#125;?&#123;&#125;; statusCode=&#123;&#125;"</span>,</div><div class="line">                   serviceUrl, urlPath,</div><div class="line">                   regionsParamValue == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"regions="</span> + regionsParamValue,</div><div class="line">                   response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus()</div><div class="line">           );</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#getApplications(...)</code> 方法，GET 请求 Eureka-Server 的 <code>apps/</code> 接口，参数为 <code>regions</code> ，返回格式为 JSON ，实现<strong>全量获取注册信息</strong>。</li></ul></li><li><p>第 16 至 24 行 ：设置到本地注册信息<strong>缓存</strong>。</p><ul><li>第 19 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 20 行 ：调用 <code>#filterAndShuffle(...)</code> 方法，根据配置 <code>eureka.shouldFilterOnlyUpInstances = true</code> ( 默认值 ：<code>true</code> ) 过滤只保留状态为开启( UP )的应用实例，并<strong>随机打乱</strong>应用实例顺序。打乱后，实现调用应用服务的随机性。代码比较易懂，点击<a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L1603" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看方法实现。</li></ul></li></ul><h1>3. Eureka-Server 接收全量获取</h1><h2>3.1 接收全量获取请求</h2><p><code>com.netflix.eureka.resources.ApplicationsResource</code>，处理<strong>所有</strong>应用的请求操作的 Resource ( Controller )。</p><p>接收全量获取请求，映射 <code>ApplicationsResource#getContainers()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@GET</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">getContainers</span><span class="params">(@PathParam(<span class="string">"version"</span>)</span> String version,</span></div><div class="line"><span class="function"> 3:                               @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT)</span> String acceptHeader,</span></div><div class="line"><span class="function"> 4:                               @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT_ENCODING)</span> String acceptEncoding,</span></div><div class="line"><span class="function"> 5:                               @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept,</span></div><div class="line"><span class="function"> 6:                               @Context UriInfo uriInfo,</span></div><div class="line"><span class="function"> 7:                               @Nullable @<span class="title">QueryParam</span><span class="params">(<span class="string">"regions"</span>)</span> String regionsStr) </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">boolean</span> isRemoteRegionRequested = <span class="keyword">null</span> != regionsStr &amp;&amp; !regionsStr.isEmpty();</div><div class="line"><span class="number">10</span>:     String[] regions = <span class="keyword">null</span>;</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (!isRemoteRegionRequested) &#123;</div><div class="line"><span class="number">12</span>:         EurekaMonitors.GET_ALL.increment();</div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:         regions = regionsStr.toLowerCase().split(<span class="string">","</span>);</div><div class="line"><span class="number">15</span>:         Arrays.sort(regions); <span class="comment">// So we don't have different caches for same regions queried in different order.</span></div><div class="line"><span class="number">16</span>:         EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 判断是否可以访问</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Check if the server allows the access to the registry. The server can</span></div><div class="line"><span class="number">21</span>:     <span class="comment">// restrict access if it is not</span></div><div class="line"><span class="number">22</span>:     <span class="comment">// ready to serve traffic depending on various reasons.</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">if</span> (!registry.shouldAllowAccess(isRemoteRegionRequested)) &#123;</div><div class="line"><span class="number">24</span>:         <span class="keyword">return</span> Response.status(Status.FORBIDDEN).build();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     <span class="comment">// API 版本</span></div><div class="line"><span class="number">28</span>:     CurrentRequestVersion.set(Version.toEnum(version));</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>:     <span class="comment">// 返回数据格式</span></div><div class="line"><span class="number">31</span>:     KeyType keyType = Key.KeyType.JSON;</div><div class="line"><span class="number">32</span>:     String returnMediaType = MediaType.APPLICATION_JSON;</div><div class="line"><span class="number">33</span>:     <span class="keyword">if</span> (acceptHeader == <span class="keyword">null</span> || !acceptHeader.contains(HEADER_JSON_VALUE)) &#123;</div><div class="line"><span class="number">34</span>:         keyType = Key.KeyType.XML;</div><div class="line"><span class="number">35</span>:         returnMediaType = MediaType.APPLICATION_XML;</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:     <span class="comment">// 响应缓存键( KEY )</span></div><div class="line"><span class="number">39</span>:     Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</div><div class="line"><span class="number">40</span>:             ResponseCacheImpl.ALL_APPS,</div><div class="line"><span class="number">41</span>:             keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</div><div class="line"><span class="number">42</span>:     );</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>:     <span class="comment">//</span></div><div class="line"><span class="number">45</span>:     Response response;</div><div class="line"><span class="number">46</span>:     <span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</div><div class="line"><span class="number">47</span>:         response = Response.ok(responseCache.getGZIP(cacheKey))</div><div class="line"><span class="number">48</span>:                 .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</div><div class="line"><span class="number">49</span>:                 .header(HEADER_CONTENT_TYPE, returnMediaType)</div><div class="line"><span class="number">50</span>:                 .build();</div><div class="line"><span class="number">51</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">52</span>:         response = Response.ok(responseCache.get(cacheKey))</div><div class="line"><span class="number">53</span>:                 .build();</div><div class="line"><span class="number">54</span>:     &#125;</div><div class="line"><span class="number">55</span>:     <span class="keyword">return</span> response;</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 8 至 17 行 ：TODO[0009]：RemoteRegionRegistry</p></li><li><p>第 19 至 25 行 ：Eureka-Server 启动完成，但是未处于就绪( Ready )状态，不接受请求全量应用注册信息的请求，例如，Eureka-Server 启动时，未能从其他 Eureka-Server 集群的节点获取到应用注册信息。</p></li><li><p>第 27 至 28 行 ：设置 API 版本号。<strong>默认</strong>最新 API 版本为 V2。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Version &#123;</div><div class="line">    V1, V2;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Version <span class="title">toEnum</span><span class="params">(String v)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Version version : Version.values()) &#123;</div><div class="line">            <span class="keyword">if</span> (version.name().equalsIgnoreCase(v)) &#123;</div><div class="line">                <span class="keyword">return</span> version;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//Defaults to v2</span></div><div class="line">        <span class="keyword">return</span> V2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 30 至 36 行 ：设置返回数据格式，默认 JSON 。</p></li><li><p>第 38 至 42 行 ：创建响应缓存( ResponseCache ) 的键( KEY )，在 <a href="#">「3.2.1 缓存键」</a>详细解析。</p></li><li><p>第 44 至 55 行 ：从响应缓存读取<strong>全量</strong>注册信息，在 <a href="#">「3.3 缓存读取」</a>详细解析。</p></li></ul><h2>3.2 响应缓存 ResponseCache</h2><p><code>com.netflix.eureka.registry.ResponseCache</code>，响应缓存<strong>接口</strong>，接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">get</span><span class="params">(Key key)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">byte</span>[] getGZIP(Key key);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">AtomicLong <span class="title">getVersionDelta</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">AtomicLong <span class="title">getVersionDeltaWithRegions</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>其中，<code>#getVersionDelta()</code> 和 <code>#getVersionDeltaWithRegions()</code> 已经废弃。这里保留的原因主要是考虑兼容性。判断依据来自如下代码：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVersion</span><span class="params">(Long version)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.versionDelta = version;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltas</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其它无关代码</span></div><div class="line">    apps.setVersion(responseCache.getVersionDelta().get()); <span class="comment">// 唯一调用到 ResponseCache#getVersionDelta() 方法的地方</span></div><div class="line">    <span class="comment">// ... 省略其它无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>#get()</code> ：获得缓存。</p></li><li><p><code>#getGZIP()</code> ：获得缓存，并 GZIP 。</p></li><li><p><code>#invalidate()</code> ：过期缓存。</p></li></ul><h3>3.2.1 缓存键</h3><p><code>com.netflix.eureka.registry.Key</code>，缓存键。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> KeyType &#123;</div><div class="line">        JSON, XML</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * An enum to define the entity that is stored in this cache for this key.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> EntityType &#123;</div><div class="line">        Application, VIP, SVIP</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String entityName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] regions;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求参数类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KeyType requestType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求 API 版本号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Version requestVersion;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * hashKey</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hashKey;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体类型</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EntityType&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EntityType entityType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EurekaAccept&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaAccept eurekaAccept;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regions = regions;</div><div class="line">        <span class="keyword">this</span>.entityType = entityType;</div><div class="line">        <span class="keyword">this</span>.entityName = entityName;</div><div class="line">        <span class="keyword">this</span>.requestType = type;</div><div class="line">        <span class="keyword">this</span>.requestVersion = v;</div><div class="line">        <span class="keyword">this</span>.eurekaAccept = eurekaAccept;</div><div class="line">        hashKey = <span class="keyword">this</span>.entityType + <span class="keyword">this</span>.entityName + (<span class="keyword">null</span> != <span class="keyword">this</span>.regions ? Arrays.toString(<span class="keyword">this</span>.regions) : <span class="string">""</span>)</div><div class="line">                + requestType.name() + requestVersion.name() + <span class="keyword">this</span>.eurekaAccept.name();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regions = regions;</div><div class="line">        <span class="keyword">this</span>.entityType = entityType;</div><div class="line">        <span class="keyword">this</span>.entityName = entityName;</div><div class="line">        <span class="keyword">this</span>.requestType = type;</div><div class="line">        <span class="keyword">this</span>.requestVersion = v;</div><div class="line">        <span class="keyword">this</span>.eurekaAccept = eurekaAccept;</div><div class="line">        hashKey = <span class="keyword">this</span>.entityType + <span class="keyword">this</span>.entityName + (<span class="keyword">null</span> != <span class="keyword">this</span>.regions ? Arrays.toString(<span class="keyword">this</span>.regions) : <span class="string">""</span>)</div><div class="line">                + requestType.name() + requestVersion.name() + <span class="keyword">this</span>.eurekaAccept.name();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        String hashKey = getHashKey();</div><div class="line">        <span class="keyword">return</span> hashKey.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Key) &#123;</div><div class="line">            <span class="keyword">return</span> getHashKey().equals(((Key) other).getHashKey());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.2.2 响应缓存实现类</h3><p><code>com.netflix.eureka.registry.ResponseCacheImpl</code>，响应缓存实现类。</p><p>在 ResponseCacheImpl 里，将缓存拆分成两层 ：</p><ul><li><strong>只读缓存</strong>( <code>readOnlyCacheMap</code> )</li><li><strong>固定过期</strong> + <strong>固定大小</strong>的<strong>读写缓存</strong>( <code>readWriteCacheMap</code> )</li></ul><p>默认配置下，<strong>缓存读取策略</strong>如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/04.png" alt=""></p><p><strong>缓存过期策略</strong>如下：</p><ul><li>应用实例注册、下线、过期时，<strong>只只只</strong>过期 <code>readWriteCacheMap</code> 。</li><li><code>readWriteCacheMap</code> 写入一段时间( 可配置 )后自动过期。</li><li><strong>定时</strong>任务对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。</li></ul><p><strong>注意</strong>：应用实例注册、下线、过期时，不会很快刷新到 <code>readWriteCacheMap</code> 缓存里。默认配置下，最大延迟在 30 秒。</p><p><strong>为什么可以使用缓存？</strong></p><p>在 <a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" rel="external nofollow noopener noreferrer" target="_blank">CAP</a> 的选择上，Eureka 选择了 AP ，不同于 Zookeeper 选择了 CP 。</p><p>推荐阅读：</p><ul><li><a href="http://dockone.io/article/78" rel="external nofollow noopener noreferrer" target="_blank">《为什么不应该使用ZooKeeper做服务发现》</a></li><li><a href="http://blog.spring-cloud.io/blog/sc-eureka.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix Eureka源码导读与原理分析》「4. 作为服务注册中心，Eureka比Zookeeper好在哪里」</a></li></ul><h2>3.3 缓存读取</h2><p>调用 <code>ResponseCacheImpl#get(...)</code> 方法( <code>#getGzip(...)</code> 类似 )，读取缓存，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Key, Value&gt; readOnlyCacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Key, Value&gt;();</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> LoadingCache&lt;Key, Value&gt; readWriteCacheMap;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">return</span> get(key, shouldUseReadOnlyResponseCache);</div><div class="line"> <span class="number">7</span>: &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>: <span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</div><div class="line"><span class="number">10</span>:     Value payload = getValue(key, useReadOnlyCache);</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (payload == <span class="keyword">null</span> || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="keyword">return</span> payload.getPayload();</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>: &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>: <span class="function">Value <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</div><div class="line"><span class="number">19</span>:     Value payload = <span class="keyword">null</span>;</div><div class="line"><span class="number">20</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:         <span class="keyword">if</span> (useReadOnlyCache) &#123;</div><div class="line"><span class="number">22</span>:             <span class="keyword">final</span> Value currentPayload = readOnlyCacheMap.get(key);</div><div class="line"><span class="number">23</span>:             <span class="keyword">if</span> (currentPayload != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">24</span>:                 payload = currentPayload;</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>:                 payload = readWriteCacheMap.get(key);</div><div class="line"><span class="number">27</span>:                 readOnlyCacheMap.put(key, payload);</div><div class="line"><span class="number">28</span>:             &#125;</div><div class="line"><span class="number">29</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">30</span>:             payload = readWriteCacheMap.get(key);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>:     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">33</span>:         logger.error(<span class="string">"Cannot get value for key :"</span> + key, t);</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>:     <span class="keyword">return</span> payload;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 5 至 7 行 ：调用 <code>#get(key, useReadOnlyCache)</code> 方法，读取缓存。其中 <code>shouldUseReadOnlyResponseCache</code> 通过配置 <code>eureka.shouldUseReadOnlyResponseCache = true</code> (默认值 ：<code>true</code> ) 开启只读缓存。如果你对数据的一致性有相对高的要求，可以关闭这个开关，当然因为少了 <code>readOnlyCacheMap</code> ，性能会有一定的下降。</p></li><li><p>第 9 至 16 行 ：调用 <code>getValue(key, useReadOnlyCache)</code> 方法，读取缓存。从 <code>readOnlyCacheMap</code> 和 <code>readWriteCacheMap</code> 变量可以看到缓存值的类为 <code>com.netflix.eureka.registry.ResponseCacheImpl.Value</code> ，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 原始值</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String payload;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * GZIP 压缩后的值</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] gzipped;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String payload)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.payload = payload;</div><div class="line">       <span class="keyword">if</span> (!EMPTY_PAYLOAD.equals(payload)) &#123;</div><div class="line">           <span class="comment">// ... 省略 GZIP 压缩代码</span></div><div class="line">           gzipped = bos.toByteArray();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           gzipped = <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getPayload</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> payload;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] getGzipped() &#123;</div><div class="line">       <span class="keyword">return</span> gzipped;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 21 至 31 行 ：读取缓存。</p><ul><li><p>第 21 至 28 行 ：先读取 <code>readOnlyCacheMap</code> 。读取不到，读取 <code>readWriteCacheMap</code> ，并设置到 <code>readOnlyCacheMap</code> 。</p></li><li><p>第 29 至 31 行 ：读取 <code>readWriteCacheMap</code> 。</p></li><li><p><code>readWriteCacheMap</code> 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.readWriteCacheMap =</div><div class="line">      CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>)</div><div class="line">              .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</div><div class="line">              .removalListener(<span class="keyword">new</span> RemovalListener&lt;Key, Value&gt;() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Key, Value&gt; notification)</span> </span>&#123;</div><div class="line">                      <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line">                      Key removedKey = notification.getKey();</div><div class="line">                      <span class="keyword">if</span> (removedKey.hasRegions()) &#123;</div><div class="line">                          Key cloneWithNoRegions = removedKey.cloneWithoutRegions();</div><div class="line">                          regionSpecificKeys.remove(cloneWithNoRegions, removedKey);</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;)</div><div class="line">              .build(<span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> Value <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                      <span class="comment">// // TODO[0009]：RemoteRegionRegistry</span></div><div class="line">                      <span class="keyword">if</span> (key.hasRegions()) &#123;</div><div class="line">                          Key cloneWithNoRegions = key.cloneWithoutRegions();</div><div class="line">                          regionSpecificKeys.put(cloneWithNoRegions, key);</div><div class="line">                      &#125;</div><div class="line">                      Value value = generatePayload(key);</div><div class="line">                      <span class="keyword">return</span> value;</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure></p><ul><li><code>readWriteCacheMap</code> 最大缓存数量为 1000 。</li><li>调用 <code>#generatePayload(key)</code> 方法，生成缓存值。</li></ul></li></ul></li><li><p><code>#generatePayload(key)</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Value <span class="title">generatePayload</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Stopwatch tracer = <span class="keyword">null</span>;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">4</span>:         String payload;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">switch</span> (key.getEntityType()) &#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">case</span> Application:</div><div class="line"> <span class="number">7</span>:                 <span class="keyword">boolean</span> isRemoteRegionRequested = key.hasRegions();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:                 <span class="keyword">if</span> (ALL_APPS.equals(key.getName())) &#123;</div><div class="line"><span class="number">10</span>:                     <span class="keyword">if</span> (isRemoteRegionRequested) &#123; <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">11</span>:                         tracer = serializeAllAppsWithRemoteRegionTimer.start();</div><div class="line"><span class="number">12</span>:                         payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));</div><div class="line"><span class="number">13</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:                         tracer = serializeAllAppsTimer.start();</div><div class="line"><span class="number">15</span>:                         payload = getPayLoad(key, registry.getApplications());</div><div class="line"><span class="number">16</span>:                     &#125;</div><div class="line"><span class="number">17</span>:                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ALL_APPS_DELTA.equals(key.getName())) &#123;</div><div class="line"><span class="number">18</span>:                     <span class="comment">// ... 省略增量获取相关的代码</span></div><div class="line"><span class="number">19</span>:                  &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:                     tracer = serializeOneApptimer.start();</div><div class="line"><span class="number">21</span>:                     payload = getPayLoad(key, registry.getApplication(key.getName()));</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>:             <span class="comment">// ... 省略部分代码 </span></div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">return</span> <span class="keyword">new</span> Value(payload);</div><div class="line"><span class="number">27</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             tracer.stop();</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 10 至 12 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 13 至 16 行 ：调用 <code>AbstractInstanceRegistry#getApplications()</code> 方法，获得注册的应用集合。后调用 <code>#getPayLoad()</code> 方法，将注册的应用集合转换成缓存值。🙂 这两个方法代码较多，下面详细解析。</li><li>第 17 至 18 行 ：获取增量注册信息的缓存值，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li></ul></li></ul><h3>3.3.1 获得注册的应用集合</h3><p>调用 <code>AbstractInstanceRegistry#getApplications()</code> 方法，获得注册的应用集合，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] EMPTY_STR_ARRAY = <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</div><div class="line"> <span class="number">7</span>:    <span class="keyword">if</span> (disableTransparentFallback) &#123; <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">8</span>:        <span class="keyword">return</span> getApplicationsFromLocalRegionOnly();</div><div class="line"> <span class="number">9</span>:    &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>:        <span class="keyword">return</span> getApplicationsFromAllRemoteRegions();  <span class="comment">// Behavior of falling back to remote region can be disabled.</span></div><div class="line"><span class="number">11</span>:    &#125;</div><div class="line"><span class="number">12</span>: &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromLocalRegionOnly</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">15</span>:    <span class="keyword">return</span> getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 6 至 8 行 ：TODO[0009]：RemoteRegionRegistry</p></li><li><p>第 9 至 16 行 ：调用 <code>#getApplicationsFromMultipleRegions(...)</code> 方法，获得注册的应用集合，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">boolean</span> includeRemoteRegion = <span class="keyword">null</span> != remoteRegions &amp;&amp; remoteRegions.length != <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     logger.debug(<span class="string">"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;"</span>,</div><div class="line"> <span class="number">5</span>:             includeRemoteRegion, Arrays.toString(remoteRegions));</div><div class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (includeRemoteRegion) &#123;</div><div class="line"> <span class="number">7</span>:         GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">9</span>:         GET_ALL_CACHE_MISS.increment();</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>:     <span class="comment">// 获得获得注册的应用集合</span></div><div class="line"><span class="number">12</span>:     Applications apps = <span class="keyword">new</span> Applications();</div><div class="line"><span class="number">13</span>:     apps.setVersion(<span class="number">1L</span>);</div><div class="line"><span class="number">14</span>:     <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123;</div><div class="line"><span class="number">15</span>:         Application app = <span class="keyword">null</span>;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (entry.getValue() != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123;</div><div class="line"><span class="number">19</span>:                 Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue();</div><div class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:                     app = <span class="keyword">new</span> Application(lease.getHolder().getAppName());</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 app.addInstance(decorateInstanceInfo(lease));</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">27</span>:             apps.addApplication(app);</div><div class="line"><span class="number">28</span>:         &#125;</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">31</span>:     <span class="keyword">if</span> (includeRemoteRegion) &#123;</div><div class="line"><span class="number">32</span>:         <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</div><div class="line"><span class="number">33</span>:             RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</div><div class="line"><span class="number">34</span>:             <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</div><div class="line"><span class="number">35</span>:                 Applications remoteApps = remoteRegistry.getApplications();</div><div class="line"><span class="number">36</span>:                 <span class="keyword">for</span> (Application application : remoteApps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</div><div class="line"><span class="number">38</span>:                         logger.info(<span class="string">"Application &#123;&#125;  fetched from the remote region &#123;&#125;"</span>,</div><div class="line"><span class="number">39</span>:                                 application.getName(), remoteRegion);</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>:                         Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());</div><div class="line"><span class="number">42</span>:                         <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">43</span>:                             appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</div><div class="line"><span class="number">44</span>:                             apps.addApplication(appInstanceTillNow);</div><div class="line"><span class="number">45</span>:                         &#125;</div><div class="line"><span class="number">46</span>:                         <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</div><div class="line"><span class="number">47</span>:                             appInstanceTillNow.addInstance(instanceInfo);</div><div class="line"><span class="number">48</span>:                         &#125;</div><div class="line"><span class="number">49</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">50</span>:                         logger.debug(<span class="string">"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a "</span></div><div class="line"><span class="number">51</span>:                                         + <span class="string">"whitelist and this app is not in the whitelist."</span>,</div><div class="line"><span class="number">52</span>:                                 application.getName(), remoteRegion);</div><div class="line"><span class="number">53</span>:                     &#125;</div><div class="line"><span class="number">54</span>:                 &#125;</div><div class="line"><span class="number">55</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">56</span>:                 logger.warn(<span class="string">"No remote registry available for the remote region &#123;&#125;"</span>, remoteRegion);</div><div class="line"><span class="number">57</span>:             &#125;</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:     &#125;</div><div class="line"><span class="number">60</span>:     <span class="comment">// 设置 应用集合 hashcode</span></div><div class="line"><span class="number">61</span>:     apps.setAppsHashCode(apps.getReconcileHashCode());</div><div class="line"><span class="number">62</span>:     <span class="keyword">return</span> apps;</div><div class="line"><span class="number">63</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 至 第 10 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 11 至 29 行 ：获得获得注册的应用集合。</li><li>第 30 至 59 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 61 行 ：计算应用集合 <code>hashcode</code> 。该变量用于校验<strong>增量</strong>获取的注册信息和 Eureka-Server <strong>全量</strong>的注册信息是否一致( 完整 )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li></ul></li></ul><h3>3.3.2 转换成缓存值</h3><p>调用 <code>#getPayLoad()</code> 方法，将注册的应用集合转换成缓存值，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Generate pay load with both JSON and XML formats for all applications.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getPayLoad</span><span class="params">(Key key, Applications apps)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获得编码器</span></div><div class="line">   EncoderWrapper encoderWrapper = serverCodecs.getEncoder(key.getType(), key.getEurekaAccept());</div><div class="line">   String result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 编码</span></div><div class="line">       result = encoderWrapper.encode(apps);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.error(<span class="string">"Failed to encode the payload for all apps"</span>, e);</div><div class="line">       <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</div><div class="line">       logger.debug(<span class="string">"New application cache entry &#123;&#125; with apps hashcode &#123;&#125;"</span>, key.toStringCompact(), apps.getAppsHashCode());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>3.4 主动过期读写缓存</h2><p>应用实例注册、下线、过期时，调用 <code>ResponseCacheImpl#invalidate()</code> 方法，主动过期读写缓存( <code>readWriteCacheMap</code> )，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Key.KeyType type : Key.KeyType.values()) &#123;</div><div class="line">       <span class="keyword">for</span> (Version v : Version.values()) &#123;</div><div class="line">           invalidate(</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, appName, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, appName, type, v, EurekaAccept.compact),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.compact),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.compact)</div><div class="line">           );</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != vipAddress) &#123;</div><div class="line">               invalidate(<span class="keyword">new</span> Key(Key.EntityType.VIP, vipAddress, type, v, EurekaAccept.full));</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != secureVipAddress) &#123;</div><div class="line">               invalidate(<span class="keyword">new</span> Key(Key.EntityType.SVIP, secureVipAddress, type, v, EurekaAccept.full));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#invalidate(keys)</code> 方法，逐个过期每个缓存键值，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(Key... keys)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Key key : keys) &#123;</div><div class="line">       logger.debug(<span class="string">"Invalidating the response cache key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;, &#123;&#125;"</span>, key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());</div><div class="line">       <span class="comment">// 过期读写缓存</span></div><div class="line">       readWriteCacheMap.invalidate(key);</div><div class="line">       <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line">       Collection&lt;Key&gt; keysWithRegions = regionSpecificKeys.get(key);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != keysWithRegions &amp;&amp; !keysWithRegions.isEmpty()) &#123;</div><div class="line">           <span class="keyword">for</span> (Key keysWithRegion : keysWithRegions) &#123;</div><div class="line">               logger.debug(<span class="string">"Invalidating the response cache key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</div><div class="line">                       key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());</div><div class="line">               readWriteCacheMap.invalidate(keysWithRegion);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h2>3.5 被动过期读写缓存</h2><p>读写缓存( <code>readWriteCacheMap</code> ) 写入后，一段时间自动过期，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds())</div></pre></td></tr></table></figure></p><ul><li>配置 <code>eureka.responseCacheAutoExpirationInSeconds</code> ，设置写入过期时长。默认值 ：180 秒。</li></ul><h2>3.6 定时刷新只读缓存</h2><p><strong>定时</strong>任务对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// ... 省略无关代码 </span></div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">long</span> responseCacheUpdateIntervalMs = serverConfig.getResponseCacheUpdateIntervalMs();</div><div class="line"> <span class="number">5</span>:     <span class="comment">// ... 省略无关代码</span></div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (shouldUseReadOnlyResponseCache) &#123;</div><div class="line"> <span class="number">8</span>:         timer.schedule(getCacheUpdateTask(),</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">new</span> Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)</div><div class="line"><span class="number">10</span>:                         + responseCacheUpdateIntervalMs),</div><div class="line"><span class="number">11</span>:                 responseCacheUpdateIntervalMs);</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="comment">// ... 省略无关代码</span></div><div class="line"><span class="number">15</span>: &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="function"><span class="keyword">private</span> TimerTask <span class="title">getCacheUpdateTask</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</div><div class="line"><span class="number">19</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">20</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">21</span>:             logger.debug(<span class="string">"Updating the client cache from response cache"</span>);</div><div class="line"><span class="number">22</span>:             <span class="keyword">for</span> (Key key : readOnlyCacheMap.keySet()) &#123; <span class="comment">// 循环 readOnlyCacheMap 的缓存键</span></div><div class="line"><span class="number">23</span>:                 <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">24</span>:                     Object[] args = &#123;key.getEntityType(), key.getName(), key.getVersion(), key.getType()&#125;;</div><div class="line"><span class="number">25</span>:                     logger.debug(<span class="string">"Updating the client cache from response cache for key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>, args);</div><div class="line"><span class="number">26</span>:                 &#125;</div><div class="line"><span class="number">27</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">28</span>:                     CurrentRequestVersion.set(key.getVersion());</div><div class="line"><span class="number">29</span>:                     Value cacheValue = readWriteCacheMap.get(key);</div><div class="line"><span class="number">30</span>:                     Value currentCacheValue = readOnlyCacheMap.get(key);</div><div class="line"><span class="number">31</span>:                     <span class="keyword">if</span> (cacheValue != currentCacheValue) &#123; <span class="comment">// 不一致时，进行替换</span></div><div class="line"><span class="number">32</span>:                         readOnlyCacheMap.put(key, cacheValue);</div><div class="line"><span class="number">33</span>:                     &#125;</div><div class="line"><span class="number">34</span>:                 &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line"><span class="number">35</span>:                     logger.error(<span class="string">"Error while updating the client cache from response cache for key &#123;&#125;"</span>, key.toStringCompact(), th);</div><div class="line"><span class="number">36</span>:                 &#125;</div><div class="line"><span class="number">37</span>:             &#125;</div><div class="line"><span class="number">38</span>:         &#125;</div><div class="line"><span class="number">39</span>:     &#125;;</div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 7 至 12 行 ：初始化定时任务。配置 <code>eureka.responseCacheUpdateIntervalMs</code>，设置任务执行频率，默认值 ：30 * 1000 毫秒。</li><li>第 17 至 39 行 ：创建定时任务。<ul><li>第 22 行 ：循环 <code>readOnlyCacheMap</code> 的缓存键。<strong>为什么不循环 <code>readWriteCacheMap</code> 呢</strong>？ <code>readOnlyCacheMap</code> 的缓存过期依赖  <code>readWriteCacheMap</code>，因此缓存键会更多。</li><li>第 28 行 至 33 行 ：对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。</li></ul></li></ul><h1>666. 彩蛋</h1><p>比预期，比想想，长老多老多的一篇文章。细思极恐。</p><p>估计下一篇增量获取会简洁很多。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-fetch-all/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（五）之过期</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-evict/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-evict/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-evict/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">2. 为什么需要过期</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">3. EvictionTask</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">4. 过期逻辑</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 过期超时续租的租约</strong>。</p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_22/01.png" alt=""></p></blockquote><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 为什么需要过期</h1><p>正常情况下，应用实例下线时候会主动向 Eureka-Server 发起下线请求。但实际情况下，应用实例可能异常崩溃，又或者是网络异常等原因，导致下线请求无法被成功提交。</p><p>介于这种情况，通过 Eureka-Client 心跳延长租约，配合 Eureka-Server 清理超时的租约解决上述异常。</p><h1>3. EvictionTask</h1><p><code>com.netflix.eureka.registry.AbstractInstanceRegistry.EvictionTask</code>，清理租约过期任务。在 Eureka-Server 启动时，初始化 EvictionTask 定时执行，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 清理租约过期任务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EvictionTask&gt; evictionTaskRef = <span class="keyword">new</span> AtomicReference&lt;EvictionTask&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="comment">// 初始化 清理租约过期任务</span></div><div class="line">   <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</div><div class="line">       evictionTaskRef.get().cancel();</div><div class="line">   &#125;</div><div class="line">   evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</div><div class="line">   evictionTimer.schedule(evictionTaskRef.get(),</div><div class="line">           serverConfig.getEvictionIntervalTimerInMs(),</div><div class="line">           serverConfig.getEvictionIntervalTimerInMs());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>配置 <code>eureka.evictionIntervalTimerInMs</code> ，清理租约过期任务执行频率，单位：毫秒。默认，60000 毫秒。</p></li><li><p>EvictionTask 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvictionTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 获取 补偿时间毫秒数</span></div><div class="line">           <span class="keyword">long</span> compensationTimeMs = getCompensationTimeMs();</div><div class="line">           logger.info(<span class="string">"Running the evict task with compensationTime &#123;&#125;ms"</span>, compensationTimeMs);</div><div class="line">           <span class="comment">// 清理过期租约逻辑</span></div><div class="line">           evict(compensationTimeMs);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           logger.error(<span class="string">"Could not run the evict task"</span>, e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#compensationTimeMs()</code> 方法，获得补偿时间毫秒数。计算公式 = 当前时间 - 最后任务执行时间 - 任务执行频率。为什么需要补偿时间毫秒数，在 <a href="#">「4. 过期逻辑」<code>Lease#isisExpired(additionalLeaseMs)</code> 方法</a> 揭晓。<code>#compensationTimeMs()</code> 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后任务执行时间</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastExecutionNanosRef = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> currNanos = getCurrentTimeNano();</div><div class="line">    <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</div><div class="line">    <span class="keyword">if</span> (lastNanos == <span class="number">0L</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</div><div class="line">    <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</div><div class="line">    <span class="keyword">return</span> compensationTime &lt;= <span class="number">0L</span> ? <span class="number">0L</span> : compensationTime;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>由于 JVM GC ，又或是时间偏移( clock skew ) 等原因，定时器执行实际比预期会<strong>略有延迟</strong>。笔者在本机<strong>低负载</strong>运行，大概 10 ms 内。</p><blockquote><p>compute a compensation time defined as the actual time this task was executed since the prev iteration, vs the configured amount of time for execution. This is useful for cases where changes in time (due to clock skew or gc for example) causes the actual eviction task to execute later than the desired time according to the configured cycle.</p></blockquote></li></ul></li><li><p>调用 <code>#evict(compensationTime)</code> 方法，执行清理过期租约逻辑，在 <a href="#">「4. 过期逻辑」</a> 详细解析。</p></li></ul></li></ul><h1>4. 过期逻辑</h1><p>调用 <code>#evict(compensationTime)</code> 方法，执行清理过期租约逻辑，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     logger.debug(<span class="string">"Running the evict task"</span>);</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</div><div class="line"> <span class="number">5</span>:         logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</div><div class="line"> <span class="number">6</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>:     &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="comment">// 获得 所有过期的租约</span></div><div class="line"><span class="number">10</span>:     <span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></div><div class="line"><span class="number">11</span>:     <span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// the impact should be evenly distributed across all applications.</span></div><div class="line"><span class="number">13</span>:     List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">14</span>:     <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</div><div class="line"><span class="number">15</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</div><div class="line"><span class="number">16</span>:         <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">17</span>:             <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</div><div class="line"><span class="number">18</span>:                 Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</div><div class="line"><span class="number">19</span>:                 <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">20</span>:                     expiredLeases.add(lease);</div><div class="line"><span class="number">21</span>:                 &#125;</div><div class="line"><span class="number">22</span>:             &#125;</div><div class="line"><span class="number">23</span>:         &#125;</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:     <span class="comment">// 计算 最大允许清理租约数量</span></div><div class="line"><span class="number">27</span>:     <span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></div><div class="line"><span class="number">28</span>:     <span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></div><div class="line"><span class="number">29</span>:     <span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</div><div class="line"><span class="number">30</span>:     <span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">31</span>:     <span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:     <span class="comment">// 计算 清理租约数量</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</div><div class="line"><span class="number">35</span>:     <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:         logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:         <span class="comment">// 逐个过期</span></div><div class="line"><span class="number">39</span>:         Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</div><div class="line"><span class="number">41</span>:             <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></div><div class="line"><span class="number">42</span>:             <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</div><div class="line"><span class="number">43</span>:             Collections.swap(expiredLeases, i, next);</div><div class="line"><span class="number">44</span>:             Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:             String appName = lease.getHolder().getAppName();</div><div class="line"><span class="number">47</span>:             String id = lease.getHolder().getId();</div><div class="line"><span class="number">48</span>:             EXPIRED.increment();</div><div class="line"><span class="number">49</span>:             logger.warn(<span class="string">"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">50</span>:             internalCancel(appName, id, <span class="keyword">false</span>);</div><div class="line"><span class="number">51</span>:         &#125;</div><div class="line"><span class="number">52</span>:     &#125;</div><div class="line"><span class="number">53</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 至 7 行 ：判断允许执行清理过期租约逻辑，主要和<strong>自我保护机制</strong>有关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</p></li><li><p>第 9 至 24 行 ：获得<strong>所有过期</strong>的租约集合。</p><ul><li><p>第 19 行 ：调用 <code>Lease#isisExpired(additionalLeaseMs)</code> 方法，判断租约是否过期，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lease.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">   lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>😈<strong>注意</strong>：在不考虑 <code>additionalLeaseMs</code> 参数的情况下，租约过期时间比预期多了<strong>一个</strong> <code>duration</code>，原因在于 <code>#renew()</code> 方法错误的设置 <code>lastUpdateTimestamp = System.currentTimeMillis() + duration</code>，正确的设置应该是 <code>lastUpdateTimestamp = System.currentTimeMillis()</code> 。</p><blockquote><p>Note that due to renew() doing the 'wrong&quot; thing and setting lastUpdateTimestamp to +duration more than what it should be, the expiry will actually be 2 * duration. <strong>This is a minor bug and should only affect instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will not be fixed</strong>.</p></blockquote></li><li><p>TODO[0023]：additionalLeaseMs</p></li></ul></li></ul></li><li><p>第 26 至 34 行 ：计算<strong>最大允许</strong>清理租约的数量，后计算允许清理租约的数量。</p><ul><li><p>😈<strong>注意</strong>：即使 Eureka-Server 关闭<strong>自我保护机制</strong>，如果使用<code>renewalPercentThreshold = 0.85</code> 默认配置，结果会是<strong>分批逐步</strong>过期。举个例子：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 假设 20 个租约，其中有 10 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第一轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">20</span> * <span class="number">0.85</span>) = <span class="number">17</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">20</span> - <span class="number">17</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">10</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第一轮执行结束，剩余 17 个租约，其中有 7 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">17</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">17</span> * <span class="number">0.85</span>) = <span class="number">14</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">17</span> - <span class="number">14</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">7</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第二轮执行结束，剩余 14 个租约，其中有 4 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第三轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">14</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">14</span> * <span class="number">0.85</span>) = <span class="number">11</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">14</span> - <span class="number">11</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">4</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第三轮执行结束，剩余 11 个租约，其中有 1 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第四轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">11</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">11</span> * <span class="number">0.85</span>) = <span class="number">9</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">11</span> - <span class="number">9</span> = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">1</span>;</div><div class="line"><span class="comment">// 第四轮执行结束，剩余 10 个租约，其中有 0 个租约过期。结束。</span></div></pre></td></tr></table></figure></p><ul><li>结论：是否开启自我保护的差别，在于是否执行清理过期租约逻辑。如果想关闭<strong>分批逐步</strong>过期，设置 <code>renewalPercentThreshold = 0</code> 。</li></ul></li><li><p>由于 JVM GC ，或是本地时间差异原因，可能自我保护机制的阀值 <code>expectedNumberOfRenewsPerMin</code>、<code>numberOfRenewsPerMinThreshold</code> 不够正确，在<strong>过期</strong>这个相对“危险”的操作，<strong>重新计算自我保护</strong>的阀值。</p></li></ul></li><li><p>第 35 至 51 行 ：<strong>随机</strong>清理过期的租约。由于租约是按照<strong>应用顺序</strong>添加到数组，通过随机的方式，<strong>尽量避免单个应用被全部过期</strong>。</p><ul><li>第 39 行 ：传入当前时间为种子生成随机，避免 Java 的伪随机情况。在 <a href="http://www.cnblogs.com/greatfish/p/5845924.html" rel="external nofollow noopener noreferrer" target="_blank">《为什么说Java中的随机数都是伪随机数？》</a> 有详细解析。</li><li>第 41 至 43 行 ：随机调换后面的元素到当前位置( <code>i</code> )。</li></ul></li><li><p>第 50 行 ：调用 <code>#internalCancel()</code> 方法，下线已过期的租约，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》「3.2 下线应用实例信息」</a> 有详细解析。</p></li></ul><h1>666. 彩蛋</h1><p>😫 原本觉得比较容易的一篇文章，结果消耗了比想象中的时间，可能有四个小时。主要卡在补偿时间，目前也没弄懂。如果有知道的胖友，麻烦告知下。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-evict/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-self-preservation/</id>
    <published>2018-06-14T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-self-preservation/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">2. 定义</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3. 实现</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3.1 触发条件</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3.2 计算公式</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">3.3 计算时机</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>自我保护机制</strong>，为应用实例过期下线做铺垫。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1>2. 定义</h1><p>自我保护机制定义如下：</p><blockquote><p>FROM <a href="http://www.itmuch.com/spring-cloud-sum/understanding-eureka-self-preservation/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立 —— 《理解Eureka的自我保护模式》</a><br>当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p></blockquote><p><strong>为什么使用自动保护机制</strong> ？你也可以从周立兄的<strong>这篇文章得到答案</strong>，这里笔者就不一本正经的胡说八道了。</p><h1>3. 实现</h1><p>首先，我们来看下在自动保护机制里扮演<strong>重要</strong>角色的两个变量：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 期望最小每分钟续租次数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> numberOfRenewsPerMinThreshold;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 期望最大每分钟续租次数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> expectedNumberOfRenewsPerMin;</div></pre></td></tr></table></figure></p><ul><li><code>expectedNumberOfRenewsPerMin</code> ，期望<strong>最大</strong>每分钟<strong>续租</strong>次数。</li><li><code>numberOfRenewsPerMinThreshold</code> ，期望<strong>最小</strong>每分钟<strong>续租</strong>次数。</li></ul><h2>3.1 触发条件</h2><p>当每分钟心跳次数( <code>renewsLastMin</code> ) <strong>小于</strong> <code>numberOfRenewsPerMinThreshold</code> 时，并且开启自动保护模式开关( <code>eureka.enableSelfPreservation = true</code> ) 时，<strong>触发自动保护机制，不再自动过期租约</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</div><div class="line">       logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略过期租约逻辑</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</div><div class="line">       <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>3.2 计算公式</h2><p>计算公式如下：</p><ul><li><code>expectedNumberOfRenewsPerMin</code> = 当前注册的应用实例数 <code>x</code> 2</li><li><code>numberOfRenewsPerMinThreshold</code> = <code>expectedNumberOfRenewsPerMin</code> <code>*</code> 续租百分比( <code>eureka.renewalPercentThreshold</code> )</li></ul><p><strong>为什么乘以 2</strong></p><p>默认情况下，注册的应用实例每半分钟续租一次，那么一分钟心跳<strong>两次</strong>，因此 x 2 。</p><p>这块会有一些硬编码的情况，<strong>因此不太建议修改应用实例的续租频率</strong>。</p><p><strong>为什么乘以续租百分比</strong></p><p>低于这个百分比，意味着开启自我保护机制。</p><p>默认情况下，<code>eureka.renewalPercentThreshold = 0.85</code> 。</p><p>如果你真的调整了<strong>续租频率</strong>，可以等比去续租百分比，以保证合适的触发自我保护机制的阀值。另外，你需要注意，续租频率是 Client 级别，续租百分比是 Server 级别。</p><h2>3.3 计算时机</h2><p>目前有<strong>四</strong>个地方会计算 <code>numberOfRenewsPerMinThreshold</code> 、 <code>expectedNumberOfRenewsPerMin</code>，我们逐小节来看。</p><h3>3.3.1 Eureka-Server 初始化</h3><p>Eureka-Server 在启动时，从 Eureka-Server 集群获取注册信息，并<strong>首次</strong>初始化 <code>numberOfRenewsPerMinThreshold</code> 、 <code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaBootStrap.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略其它代码</span></div><div class="line"></div><div class="line">    <span class="comment">// 【2.2.10】从其他 Eureka-Server 拉取注册信息</span></div><div class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></div><div class="line">    <span class="keyword">int</span> registryCount = registry.syncUp();</div><div class="line">    registry.openForTraffic(applicationInfoManager, registryCount);</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">   <span class="comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span></div><div class="line">   <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</div><div class="line">   <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line">           (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">           </div><div class="line">   <span class="comment">// ... 省略其它代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.3.2 定时重置</h3><p>Eureka-Server <strong>定时</strong>重新计算 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</div><div class="line">   timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">                      <span class="meta">@Override</span></div><div class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                          updateRenewalThreshold();</div><div class="line">                      &#125;</div><div class="line">                  &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</div><div class="line">           serverConfig.getRenewalThresholdUpdateIntervalMs());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 自我保护机锁</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* 当计算如下参数时使用：</span></div><div class="line"><span class="comment">*  1. &#123;<span class="doctag">@link</span> #numberOfRenewsPerMinThreshold&#125;</span></div><div class="line"><span class="comment">*  2. &#123;<span class="doctag">@link</span> #expectedNumberOfRenewsPerMin&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRenewalThreshold</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 计算 应用实例数</span></div><div class="line">       Applications apps = eurekaClient.getApplications();</div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</div><div class="line">           <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.isRegisterable(instance)) &#123;</div><div class="line">                   ++count;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 计算 expectedNumberOfRenewsPerMin 、 numberOfRenewsPerMinThreshold 参数</span></div><div class="line">       <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">           <span class="comment">// Update threshold only if the threshold is greater than the</span></div><div class="line">           <span class="comment">// current expected threshold of if the self preservation is disabled.</span></div><div class="line">           <span class="keyword">if</span> ((count * <span class="number">2</span>) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</div><div class="line">                   || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</div><div class="line">               <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</div><div class="line">               <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) ((count * <span class="number">2</span>) * serverConfig.getRenewalPercentThreshold());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       logger.info(<span class="string">"Current renewal threshold is : &#123;&#125;"</span>, numberOfRenewsPerMinThreshold);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot update renewal threshold"</span>, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>配置 <code>eureka.renewalThresholdUpdateIntervalMs</code> 参数，定时重新计算。默认，15 分钟。</li><li><strong>代码块</strong> <code>!this.isSelfPreservationModeEnabled()</code> ：当<strong>未开启</strong>自我保护机制时，每次都进行重新计算。事实上，这两个参数不仅仅自我保护机制会使用到，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集 <code>numberOfRenewsPerMinThreshold</code>、<code>expectedNumberOfRenewsPerMin</code>。</li><li><strong>代码块</strong> <code>(count * 2) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</code> ：当<strong>开启</strong>自我保护机制时，应用实例每分钟最大心跳数( <code>count * 2</code> ) 小于期望<strong>最小</strong>每分钟<strong>续租</strong>次数( <code>serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold</code> )，不重新计算。<strong>如果重新计算，自动保护机制会每次定时执行后失效</strong>。</li></ul><h3>3.3.3 应用实例注册</h3><p>应用实例注册时，增加 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line">    <span class="comment">// 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></div><div class="line">             <span class="comment">// (1</span></div><div class="line">             <span class="comment">// for 30 seconds, 2 for a minute)</span></div><div class="line">             <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</div><div class="line">             <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line">                     (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.3.4 应用实例下线</h3><p>应用实例下线时，减少 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code> 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params">                     <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">                     </div><div class="line">   <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line">               <span class="comment">// Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute)</span></div><div class="line">               <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin - <span class="number">2</span>;</div><div class="line">               <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>666. 彩蛋</h1><p>😈 终于完整理解 Eureka-Server 自我保护机制，满足。噶~~~~~~</p><p>推荐另一篇 Eureka-Server 自我保护机制源码分析文章：<a href="https://segmentfault.com/a/1190000009795944" rel="external nofollow noopener noreferrer" target="_blank">《理解eureka的自我保护机制》</a> 。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-self-preservation/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/str
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（三）之下线</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-cancel/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-cancel/</id>
    <published>2018-06-07T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-cancel/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">2. Eureka-Client 发起下线</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">3. Eureka-Server 接收下线</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">3.1 接收下线请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">3.2 下线应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 下线应用实例的过程</strong>。</p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="../../../images/Eureka/2018_06_08/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1>2. Eureka-Client 发起下线</h1><p>应用实例关闭时，Eureka-Client 向 Eureka-Server 发起下线应用实例。需要满足如下条件才可发起：</p><ul><li>配置 <code>eureka.registration.enabled = true</code> ，应用实例开启注册开关。默认为 <code>false</code> 。</li><li>配置 <code>eureka.shouldUnregisterOnShutdown = true</code> ，应用实例开启关闭时下线开关。默认为 <code>true</code> 。</li></ul><p>实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="comment">// If APPINFO was registered</span></div><div class="line">    <span class="keyword">if</span> (applicationInfoManager != <span class="keyword">null</span></div><div class="line">         &amp;&amp; clientConfig.shouldRegisterWithEureka() <span class="comment">// eureka.registration.enabled = true</span></div><div class="line">         &amp;&amp; clientConfig.shouldUnregisterOnShutdown()) &#123; <span class="comment">// eureka.shouldUnregisterOnShutdown = true</span></div><div class="line">        applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);</div><div class="line">        unregister();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法，设置应用实例为关闭( DOWN )。</p></li><li><p>调用 <code>#unregister()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// It can be null if shouldRegisterWithEureka == false</span></div><div class="line">   <span class="keyword">if</span>(eurekaTransport != <span class="keyword">null</span> &amp;&amp; eurekaTransport.registrationClient != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           logger.info(<span class="string">"Unregistering ..."</span>);</div><div class="line">           EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());</div><div class="line">           logger.info(PREFIX + appPathIdentifier + <span class="string">" - deregister  status: "</span> + httpResponse.getStatusCode());</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           logger.error(PREFIX + appPathIdentifier + <span class="string">" - de-registration failed"</span> + e.getMessage(), e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">cancel</span><span class="params">(String appName, String id)</span> </span>&#123;</div><div class="line">    String urlPath = <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">    ClientResponse response = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line">        addExtraHeaders(resourceBuilder);</div><div class="line">        response = resourceBuilder.delete(ClientResponse.class);</div><div class="line">        <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"Jersey HTTP DELETE &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">            response.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#cancel(...)</code> 方法，<code>DELETE</code> 请求 Eureka-Server 的 <code>apps/${APP_NAME}/${INSTANCE_INFO_ID}</code> 接口，实现应用实例信息的下线。</li></ul></li></ul><h1>3. Eureka-Server 接收下线</h1><h2>3.1 接收下线请求</h2><p><code>com.netflix.eureka.resources.InstanceResource</code>，处理<strong>单个</strong>应用实例信息的请求操作的 Resource ( Controller )。</p><p>下线应用实例信息的请求，映射 <code>InstanceResource#cancelLease()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">cancelLease</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</div><div class="line">   <span class="comment">// 下线</span></div><div class="line">   <span class="keyword">boolean</span> isSuccess = registry.cancel(app.getName(), id, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (isSuccess) &#123; <span class="comment">// 下线成功</span></div><div class="line">       logger.debug(<span class="string">"Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">       <span class="keyword">return</span> Response.ok().build();</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 下线成功</span></div><div class="line">       logger.info(<span class="string">"Not Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">       <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>PeerAwareInstanceRegistryImpl#cancel(...)</code> 方法，下线应用实例。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                       <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (<span class="keyword">super</span>.cancel(appName, id, isReplication)) &#123; <span class="comment">// 下线</span></div><div class="line"> <span class="number">5</span>:         <span class="comment">// Eureka-Server 复制</span></div><div class="line"> <span class="number">6</span>:         replicateToPeers(Action.Cancel, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 减少 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">10</span>:                 <span class="comment">// Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute)</span></div><div class="line"><span class="number">11</span>:                 <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin - <span class="number">2</span>;</div><div class="line"><span class="number">12</span>:                 <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">13</span>:             &#125;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">18</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 行 ：调用父类 <code>AbstractInstanceRegistry#cancel(...)</code> 方法，下线应用实例信息。</li><li>第 6 行 ：Eureka-Server 复制下线操作，在TODO[0021]：集群同步。</li><li>第 7 至 14 行 ：减少 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code>，自我保护机制相关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</li></ul></li></ul><h2>3.2 下线应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#cancel(...)</code> 方法，下线应用实例信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">return</span> internalCancel(appName, id, isReplication);</div><div class="line"> <span class="number">4</span>: &#125;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 获得锁 TODO 芋艿：疑问</span></div><div class="line"> <span class="number">9</span>:         read.lock();</div><div class="line"><span class="number">10</span>:         <span class="comment">// 增加 取消注册次数 到 监控</span></div><div class="line"><span class="number">11</span>:         CANCEL.increment(isReplication);</div><div class="line"><span class="number">12</span>:         <span class="comment">// 移除 租约映射</span></div><div class="line"><span class="number">13</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">14</span>:         Lease&lt;InstanceInfo&gt; leaseToCancel = <span class="keyword">null</span>;</div><div class="line"><span class="number">15</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">16</span>:             leaseToCancel = gMap.remove(id);</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:         <span class="comment">// 添加到 最近取消注册的调试队列</span></div><div class="line"><span class="number">19</span>:         <span class="keyword">synchronized</span> (recentCanceledQueue) &#123;</div><div class="line"><span class="number">20</span>:             recentCanceledQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + <span class="string">"("</span> + id + <span class="string">")"</span>));</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:         <span class="comment">// 移除 应用实例覆盖状态映射</span></div><div class="line"><span class="number">23</span>:         InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</div><div class="line"><span class="number">24</span>:         <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">25</span>:             logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</div><div class="line"><span class="number">26</span>:         &#125;</div><div class="line"><span class="number">27</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (leaseToCancel == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             CANCEL_NOT_FOUND.increment(isReplication); <span class="comment">// 添加 取消注册不存在 到 监控</span></div><div class="line"><span class="number">30</span>:             logger.warn(<span class="string">"DS: Registry: cancel failed because Lease is not registered for: &#123;&#125;/&#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">31</span>:             <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 失败</span></div><div class="line"><span class="number">32</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">33</span>:             <span class="comment">// 设置 租约的取消注册时间戳</span></div><div class="line"><span class="number">34</span>:             leaseToCancel.cancel();</div><div class="line"><span class="number">35</span>:             <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">36</span>:             InstanceInfo instanceInfo = leaseToCancel.getHolder();</div><div class="line"><span class="number">37</span>:             String vip = <span class="keyword">null</span>;</div><div class="line"><span class="number">38</span>:             String svip = <span class="keyword">null</span>;</div><div class="line"><span class="number">39</span>:             <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">40</span>:                 instanceInfo.setActionType(ActionType.DELETED);</div><div class="line"><span class="number">41</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(leaseToCancel));</div><div class="line"><span class="number">42</span>:                 instanceInfo.setLastUpdatedTimestamp();</div><div class="line"><span class="number">43</span>:                 vip = instanceInfo.getVIPAddress();</div><div class="line"><span class="number">44</span>:                 svip = instanceInfo.getSecureVipAddress();</div><div class="line"><span class="number">45</span>:             &#125;</div><div class="line"><span class="number">46</span>:             <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">47</span>:             invalidateCache(appName, vip, svip);</div><div class="line"><span class="number">48</span>:             logger.info(<span class="string">"Cancelled instance &#123;&#125;/&#123;&#125; (replication=&#123;&#125;)"</span>, appName, id, isReplication);</div><div class="line"><span class="number">49</span>:             <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 成功</span></div><div class="line"><span class="number">50</span>:         &#125;</div><div class="line"><span class="number">51</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">52</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">53</span>:         read.unlock();</div><div class="line"><span class="number">54</span>:     &#125;</div><div class="line"><span class="number">55</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 9 行 ：TODO 为什么是读锁。</p></li><li><p>第 10 至 11 行 ：增加下线次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p></li><li><p>第 12 至 17 行 ：移除租约映射( <code>registry</code> )。</p></li><li><p>第 18 至 21 行 ：添加到最近下线的<strong>调试</strong>队列( <code>recentCanceledQueue</code> )，用于 Eureka-Server 运维界面的显示，无实际业务逻辑使用。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近取消注册的调试队列</span></div><div class="line"><span class="comment">* key ：添加时的时间戳</span></div><div class="line"><span class="comment">* value ：字符串 = 应用名(应用实例信息编号)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt; recentCanceledQueue;</div></pre></td></tr></table></figure></p></li><li><p>第 22 至 26 行 ：移除应用实例覆盖状态映射。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li><p>第 27 至 31 行 ：租约不存在，返回下线失败( <code>false</code> )。</p></li><li><p>第 34 行 ：调用 <code>Lease#cancel()</code> 方法，取消租约。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lease.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (evictionTimestamp &lt;= <span class="number">0</span>) &#123;</div><div class="line">       evictionTimestamp = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 35 至 45 行 ：设置应用实例信息的<strong>操作类型为添加</strong>，并添加到最近租约变更记录队列( <code>recentlyChangedQueue</code> )。<code>recentlyChangedQueue</code> 用于注册信息的<strong>增量</strong>获取，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self">《应用实例注册发现 （七）之增量获取》</a>详细解析。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div></pre></td></tr></table></figure></p></li><li><p>第 47 行 ：设置响应缓存( ResponseCache )过期，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a>详细解析。</p></li><li><p>第 49 行 ：返回下线失败( <code>false</code> )。</p></li><li><p>第 53 行 ：释放锁。</p></li></ul><h1>666. 彩蛋</h1><p>水更一篇，下一篇<strong>租约过期</strong>！走起。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-cancel/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（二）之续租</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-renew/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-renew/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-renew/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2. Eureka-Client 发起续租</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.1 初始化定时任务</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.2 HeartbeatThread</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.3 TimedSupervisorTask</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3. Eureka-Server 接收续租</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3.1 接收续租请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3.2 续租应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 续租应用实例的过程</strong>。</p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="http://www.iocoder.cn/images/Eureka/2018_06_01/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1>2. Eureka-Client 发起续租</h1><p>Eureka-Client 向 Eureka-Server 发起注册应用实例成功后获得租约 ( Lease )。Eureka-Client <strong>固定间隔</strong>向 Eureka-Server 发起<strong>续租</strong>( renew )，避免租约过期。</p><p>默认情况下，租约有效期为 90 秒，续租频率为 30 秒。两者比例为 1 : 3 ，保证在网络异常等情况下，有三次重试的机会。</p><h2>2.1 初始化定时任务</h2><p>Eureka-Client 在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">初始化</a>过程中，创建<strong>心跳</strong>线程，<strong>固定间隔</strong>向 Eureka-Server 发起<strong>续租</strong>( renew )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">               Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">               <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                       .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">                       .setDaemon(<span class="keyword">true</span>)</div><div class="line">                       .build());</div><div class="line"></div><div class="line">    heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">              <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">              <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                      .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</div><div class="line">                      .setDaemon(<span class="keyword">true</span>)</div><div class="line">                      .build()</div><div class="line">    );  <span class="comment">// use direct handoff</span></div><div class="line">      </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">  </div><div class="line">    <span class="comment">// 【3.2.14】初始化定时任务</span></div><div class="line">    initScheduledTasks();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); <span class="comment">// 续租频率</span></div><div class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); <span class="comment">//</span></div><div class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</div><div class="line"></div><div class="line">        <span class="comment">// Heartbeat timer</span></div><div class="line">        scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"heartbeat"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       heartbeatExecutor,</div><div class="line">                       renewalIntervalInSecs,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> HeartbeatThread()</div><div class="line">               ),</div><div class="line">               renewalIntervalInSecs, TimeUnit.SECONDS);</div><div class="line">               </div><div class="line">          <span class="comment">// ... 省略无关代码</span></div><div class="line">     &#125;</div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>scheduler</code>，定时任务服务，用于定时触发心跳( 续租 )。细心如你，会发现任务提交的方式是 <code>ScheduledExecutorService#schedule(...)</code> 方法，<strong>只延迟执行一次心跳，说好的固定频率执行心跳呢</strong>！！！答案在 <a href="#">「2.3 TimedSupervisorTask」</a> 揭晓。</li><li><code>heartbeatExecutor</code>，心跳任务执行线程池。为什么有 <code>scheduler</code> 的情况下，还有 <code>heartbeatExecutor</code> ？？？答案也在 <a href="#">「2.3 TimedSupervisorTask」</a> 揭晓。</li><li>HeartbeatThread，心跳线程，在<a href="#">「2.2 TimedSupervisorTask」</a> 详细解析。</li></ul><h2>2.2 HeartbeatThread</h2><p><code>com.netflix.discovery.DiscoveryClient.HeartbeatThread</code>，心跳线程，<strong>实现</strong>执行 Eureka-Client 向 Eureka-Server 发起<strong>续租</strong>( renew )请求。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功向 Eureka-Server 心跳时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulHeartbeatTimestamp = -<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (renew()) &#123;</div><div class="line">           lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#renew</code> 方法，执行续租逻辑。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">   EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</div><div class="line">       logger.debug(<span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">       <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</div><div class="line">           REREGISTER_COUNTER.increment();</div><div class="line">           logger.info(<span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, PREFIX + appPathIdentifier, instanceInfo.getAppName());</div><div class="line">           <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</div><div class="line">           <span class="comment">// 发起注册</span></div><div class="line">           <span class="keyword">boolean</span> success = register();</div><div class="line">           <span class="keyword">if</span> (success) &#123;</div><div class="line">               instanceInfo.unsetIsDirty(timestamp);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> success;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, PREFIX + appPathIdentifier, e);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>AbstractJerseyEurekaHttpClient#sendHeartBeat(...)</code> 方法，发起<strong>续租请求</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;InstanceInfo&gt; <span class="title">sendHeartBeat</span><span class="params">(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus)</span> </span>&#123;</div><div class="line">   String urlPath = <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       WebResource webResource = jerseyClient.resource(serviceUrl)</div><div class="line">               .path(urlPath)</div><div class="line">               .queryParam(<span class="string">"status"</span>, info.getStatus().toString())</div><div class="line">               .queryParam(<span class="string">"lastDirtyTimestamp"</span>, info.getLastDirtyTimestamp().toString());</div><div class="line">       <span class="keyword">if</span> (overriddenStatus != <span class="keyword">null</span>) &#123;</div><div class="line">           webResource = webResource.queryParam(<span class="string">"overriddenstatus"</span>, overriddenStatus.name());</div><div class="line">       &#125;</div><div class="line">       Builder requestBuilder = webResource.getRequestBuilder();</div><div class="line">       addExtraHeaders(requestBuilder);</div><div class="line">       response = requestBuilder.put(ClientResponse.class);</div><div class="line">       EurekaHttpResponseBuilder&lt;InstanceInfo&gt; eurekaResponseBuilder = anEurekaHttpResponse(response.getStatus(), InstanceInfo.class).headers(headersOf(response));</div><div class="line">       <span class="keyword">if</span> (response.hasEntity()) &#123;</div><div class="line">           eurekaResponseBuilder.entity(response.getEntity(InstanceInfo.class));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> eurekaResponseBuilder.build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP PUT &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>PUT 请求 Eureka-Server 的 <code>apps/${APP_NAME}/${INSTANCE_INFO_ID}</code> 接口，参数为 <code>status</code>、<code>lastDirtyTimestamp</code>、<code>overriddenstatus</code>，实现续租。</li></ul></li><li><p>调用 <code>AbstractJerseyEurekaHttpClient#register(...)</code> 方法，当 Eureka-Server <strong>不存在租约</strong>时，重新发起注册，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》</a>有详细解析。</p></li></ul></li></ul><h2>2.3 TimedSupervisorTask</h2><p><code>com.netflix.discovery.TimedSupervisorTask</code>，监管<strong>定时任务</strong>的任务。</p><blockquote><p>A supervisor task that schedules subtasks while enforce a timeout.</p></blockquote><p>创建 TimedSupervisorTask 代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedSupervisorTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter timeoutCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter rejectedCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter throwableCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongGauge threadPoolLevelGauge;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行子任务线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 子任务执行超时时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 子任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前任子务执行频率</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong delay;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最大子任务执行频率</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 子任务执行超时情况下使用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDelay;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimedSupervisorTask</span><span class="params">(String name, ScheduledExecutorService scheduler, ThreadPoolExecutor executor,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> expBackOffBound, Runnable task)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">        <span class="keyword">this</span>.timeoutMillis = timeUnit.toMillis(timeout);</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.delay = <span class="keyword">new</span> AtomicLong(timeoutMillis);</div><div class="line">        <span class="keyword">this</span>.maxDelay = timeoutMillis * expBackOffBound;</div><div class="line"></div><div class="line">        <span class="comment">// Initialize the counters and register.</span></div><div class="line">        timeoutCounter = Monitors.newCounter(<span class="string">"timeouts"</span>);</div><div class="line">        rejectedCounter = Monitors.newCounter(<span class="string">"rejectedExecutions"</span>);</div><div class="line">        throwableCounter = Monitors.newCounter(<span class="string">"throwables"</span>);</div><div class="line">        threadPoolLevelGauge = <span class="keyword">new</span> LongGauge(MonitorConfig.builder(<span class="string">"threadPoolUsed"</span>).build());</div><div class="line">        Monitors.registerObject(name, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>scheduler</code> ，定时任务服务，用于定时【<strong>发起</strong>】子任务。</li><li><code>executor</code> ，执行子任务线程池，用于【<strong>提交</strong>】子任务执行。</li><li><code>task</code> ，子任务。</li><li><code>timeoutMillis</code> ，子任务执行超时时间，单位：毫秒。</li><li><code>delay</code> ，当前子任务执行频率，单位：毫秒。值等于 <code>timeout</code> 参数。</li><li><code>maxDelay</code> ，<strong>最大</strong>子任务执行频率，单位：毫秒。值等于 <code>timeout * expBackOffBound</code> 参数。</li></ul><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_01/02.png" alt=""></p><ul><li><code>scheduler</code> 初始化延迟执行 TimedSupervisorTask 。</li><li>TimedSupervisorTask 执行时，提交 <code>task</code> 到 <code>executor</code> 执行任务。<ul><li>当 <code>task</code> 执行正常，TimedSupervisorTask <strong>再次</strong>提交<strong>自己</strong>到<code>scheduler</code> 延迟 <code>timeoutMillis</code> 执行。</li><li>当 <code>task</code> 执行超时，重新计算延迟时间( 不允许超过 <code>maxDelay</code> )，<strong>再次</strong>提交<strong>自己</strong>到<code>scheduler</code> 延迟执行。</li></ul></li></ul><p>实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TimedSupervisorTask.java</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     Future&lt;?&gt; future = <span class="keyword">null</span>;</div><div class="line">  <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">5</span>:         <span class="comment">// 提交 任务</span></div><div class="line">  <span class="number">6</span>:         future = executor.submit(task);</div><div class="line">  <span class="number">7</span>:         <span class="comment">//</span></div><div class="line">  <span class="number">8</span>:         threadPoolLevelGauge.set((<span class="keyword">long</span>) executor.getActiveCount());</div><div class="line">  <span class="number">9</span>:         <span class="comment">// 等待任务 执行完成 或 超时</span></div><div class="line"> <span class="number">10</span>:         future.get(timeoutMillis, TimeUnit.MILLISECONDS);  <span class="comment">// block until done or timeout</span></div><div class="line"> <span class="number">11</span>:         <span class="comment">// 设置 下一次任务执行频率</span></div><div class="line"> <span class="number">12</span>:         delay.set(timeoutMillis);</div><div class="line"> <span class="number">13</span>:         <span class="comment">//</span></div><div class="line"> <span class="number">14</span>:         threadPoolLevelGauge.set((<span class="keyword">long</span>) executor.getActiveCount());</div><div class="line"> <span class="number">15</span>:     &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line"> <span class="number">16</span>:         logger.error(<span class="string">"task supervisor timed out"</span>, e);</div><div class="line"> <span class="number">17</span>:         timeoutCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">18</span>: </div><div class="line"> <span class="number">19</span>:         <span class="comment">// 设置 下一次任务执行频率</span></div><div class="line"> <span class="number">20</span>:         <span class="keyword">long</span> currentDelay = delay.get();</div><div class="line"> <span class="number">21</span>:         <span class="keyword">long</span> newDelay = Math.min(maxDelay, currentDelay * <span class="number">2</span>);</div><div class="line"> <span class="number">22</span>:         delay.compareAndSet(currentDelay, newDelay);</div><div class="line"> <span class="number">23</span>: </div><div class="line"> <span class="number">24</span>:     &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (executor.isShutdown() || scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">26</span>:             logger.warn(<span class="string">"task supervisor shutting down, reject the task"</span>, e);</div><div class="line"> <span class="number">27</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">28</span>:             logger.error(<span class="string">"task supervisor rejected the task"</span>, e);</div><div class="line"> <span class="number">29</span>:         &#125;</div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:         rejectedCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">32</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (executor.isShutdown() || scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">34</span>:             logger.warn(<span class="string">"task supervisor shutting down, can't accept the task"</span>);</div><div class="line"> <span class="number">35</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">36</span>:             logger.error(<span class="string">"task supervisor threw an exception"</span>, e);</div><div class="line"> <span class="number">37</span>:         &#125;</div><div class="line"> <span class="number">38</span>: </div><div class="line"> <span class="number">39</span>:         throwableCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">40</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">41</span>:         <span class="comment">// 取消 未完成的任务</span></div><div class="line"> <span class="number">42</span>:         <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">43</span>:             future.cancel(<span class="keyword">true</span>);</div><div class="line"> <span class="number">44</span>:         &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:         <span class="comment">// 调度 下次任务</span></div><div class="line"> <span class="number">47</span>:         <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">48</span>:             scheduler.schedule(<span class="keyword">this</span>, delay.get(), TimeUnit.MILLISECONDS);</div><div class="line"> <span class="number">49</span>:         &#125;</div><div class="line"> <span class="number">50</span>:     &#125;</div><div class="line"> <span class="number">51</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 5 至 6 行 ：提交子任务 <code>task</code> 到执行子任务线程池 <code>executor</code> 。</li><li>第 9 至 10 行 ：等待子任务 <code>task</code> 执行完成或执行超时。</li><li>第 11 至 12 行 ：子任务 <code>task</code> 执行完成，设置下一次执行延迟 <code>delay</code> 。</li><li>第 19 至 22 行 ：子任务 <code>task</code> 执行超时，重新计算下一次执行延迟 <code>delay</code> 。计算公式为 <code>Math.min(maxDelay, currentDelay * 2)</code> 。如果多次超时，超时时间不断乘以 2 ，不允许超过最大延迟时间( <code>maxDelay</code> )。</li><li>第 41 至 44 行 ：<strong>强制</strong>取消未完成的子任务。</li><li>第 46 至 49 行 ：调度下一次 TimedSupervisorTask 。</li></ul><h1>3. Eureka-Server 接收续租</h1><h2>3.1 接收续租请求</h2><p><code>com.netflix.eureka.resources.InstanceResource</code>，处理<strong>单个</strong>应用实例信息的请求操作的 Resource ( Controller )。</p><p>续租应用实例信息的请求，映射 <code>InstanceResource#renewLease()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@PUT</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:         @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function"> 4:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</span></div><div class="line"><span class="function"> 5:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</span></div><div class="line"><span class="function"> 6:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">boolean</span> isFromReplicaNode = <span class="string">"true"</span>.equals(isReplication);</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 续租</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 续租失败</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// Not found in the registry, immediately ask for a register</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">if</span> (!isSuccess) &#123;</div><div class="line"><span class="number">14</span>:         logger.warn(<span class="string">"Not Found (Renew): &#123;&#125; - &#123;&#125;"</span>, app.getName(), id);</div><div class="line"><span class="number">15</span>:         <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:     <span class="comment">// 比较 InstanceInfo 的 lastDirtyTimestamp 属性</span></div><div class="line"><span class="number">19</span>:     <span class="comment">// Check if we need to sync based on dirty time stamp, the client</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// instance might have changed some value</span></div><div class="line"><span class="number">21</span>:     Response response = <span class="keyword">null</span>;</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span> &amp;&amp; serverConfig.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"><span class="number">23</span>:         response = <span class="keyword">this</span>.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);</div><div class="line"><span class="number">24</span>:         <span class="comment">// Store the overridden status since the validation found out the node that replicates wins</span></div><div class="line"><span class="number">25</span>:         <span class="keyword">if</span> (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()</div><div class="line"><span class="number">26</span>:                 &amp;&amp; (overriddenStatus != <span class="keyword">null</span>)</div><div class="line"><span class="number">27</span>:                 &amp;&amp; !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))</div><div class="line"><span class="number">28</span>:                 &amp;&amp; isFromReplicaNode) &#123;</div><div class="line"><span class="number">29</span>:             registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 成功</span></div><div class="line"><span class="number">32</span>:         response = Response.ok().build();</div><div class="line"><span class="number">33</span>:     &#125;</div><div class="line"><span class="number">34</span>:     logger.debug(<span class="string">"Found (Renew): &#123;&#125; - &#123;&#125;; reply status=&#123;&#125;"</span> + app.getName(), id, response.getStatus());</div><div class="line"><span class="number">35</span>:     <span class="keyword">return</span> response;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 8 至 9 行 ：调用 <code>PeerAwareInstanceRegistryImpl#renew(...)</code> 方法，续租。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.renew(appName, id, isReplication)) &#123; <span class="comment">// 续租</span></div><div class="line">       <span class="comment">// Eureka-Server 复制</span></div><div class="line">       replicateToPeers(Action.Heartbeat, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用父类 <code>AbstractInstanceRegistry#renew(...)</code> 方法，注册应用实例信息。</li></ul></li><li><p>第 11 至 16 行 ：续租失败，返回 404 响应。当 Eureka-Client 收到 404 响应后，会重新发起 InstanceInfo 的注册。</p></li><li><p>第 18 至 30 行 ：比较请求的 <code>lastDirtyTimestamp</code> 和 Server 的 InstanceInfo 的 <code>lastDirtyTimestamp</code> 属性差异，需要配置 <code>eureka.syncWhenTimestampDiffers = true</code> ( 默认开启 )。</p><ul><li><p>第 23 行 ：调用 <code>#validateDirtyTimestamp(...)</code> 方法，比较 <code>lastDirtyTimestamp</code> 的差异。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceResource.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Response <span class="title">validateDirtyTimestamp</span><span class="params">(Long lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 获取 InstanceInfo</span></div><div class="line">  <span class="number">3</span>:     InstanceInfo appInfo = registry.getInstanceByAppAndId(app.getName(), id, <span class="keyword">false</span>);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (appInfo != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">5</span>:         <span class="keyword">if</span> ((lastDirtyTimestamp != <span class="keyword">null</span>) &amp;&amp; (!lastDirtyTimestamp.equals(appInfo.getLastDirtyTimestamp()))) &#123;</div><div class="line">  <span class="number">6</span>:             Object[] args = &#123;id, appInfo.getLastDirtyTimestamp(), lastDirtyTimestamp, isReplication&#125;;</div><div class="line">  <span class="number">7</span>:             <span class="comment">// 请求 的 较大</span></div><div class="line">  <span class="number">8</span>:             <span class="keyword">if</span> (lastDirtyTimestamp &gt; appInfo.getLastDirtyTimestamp()) &#123;</div><div class="line">  <span class="number">9</span>:                 logger.debug(<span class="string">"Time to sync, since the last dirty timestamp differs -"</span></div><div class="line"> <span class="number">10</span>:                                 + <span class="string">" ReplicationInstance id : &#123;&#125;,Registry : &#123;&#125; Incoming: &#123;&#125; Replication: &#123;&#125;"</span>, args);</div><div class="line"> <span class="number">11</span>:                 <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line"> <span class="number">12</span>:             <span class="comment">// Server 的 较大</span></div><div class="line"> <span class="number">13</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appInfo.getLastDirtyTimestamp() &gt; lastDirtyTimestamp) &#123;</div><div class="line"> <span class="number">14</span>:                 <span class="comment">// In the case of replication, send the current instance info in the registry for the</span></div><div class="line"> <span class="number">15</span>:                 <span class="comment">// replicating node to sync itself with this one.</span></div><div class="line"> <span class="number">16</span>:                 <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">17</span>:                     logger.debug(</div><div class="line"> <span class="number">18</span>:                             <span class="string">"Time to sync, since the last dirty timestamp differs -"</span></div><div class="line"> <span class="number">19</span>:                                     + <span class="string">" ReplicationInstance id : &#123;&#125;,Registry : &#123;&#125; Incoming: &#123;&#125; Replication: &#123;&#125;"</span>,</div><div class="line"> <span class="number">20</span>:                             args);</div><div class="line"> <span class="number">21</span>:                     <span class="keyword">return</span> Response.status(Status.CONFLICT).entity(appInfo).build();</div><div class="line"> <span class="number">22</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">23</span>:                     <span class="keyword">return</span> Response.ok().build();</div><div class="line"> <span class="number">24</span>:                 &#125;</div><div class="line"> <span class="number">25</span>:             &#125;</div><div class="line"> <span class="number">26</span>:         &#125;</div><div class="line"> <span class="number">27</span>: </div><div class="line"> <span class="number">28</span>:     &#125;</div><div class="line"> <span class="number">29</span>:     <span class="keyword">return</span> Response.ok().build();</div><div class="line"> <span class="number">30</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 7 至 11 行 ：请求的 <code>lastDirtyTimestamp</code> 较大，<strong>意味着请求方( 可能是 Eureka-Client ，也可能是 Eureka-Server 集群内的其他 Server )存在 InstanceInfo 和 Eureka-Server 的 InstanceInfo 的数据不一致，返回 404 响应。请求方收到 404 响应后重新发起注册</strong>。</li><li>第 16 至 21 行 ：TODO[0021]：集群同步</li><li>第 22 至 24 行 ：Server 的 <code>lastDirtyTimestamp</code> 较大，并且请求方为 Eureka-Client，续租成功，返回 200 成功响应。</li><li>第 29 行 ：<code>lastDirtyTimestamp</code> 一致，返回 200 成功响应。</li></ul></li><li><p>第 24 至 30 行 ：TODO[0021]：集群同步</p></li></ul></li><li><p>第 31 至 33 行 ：续租成功，返回 200 成功响应。</p></li></ul><h2>3.2 续租应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#renew(...)</code> 方法，续租应用实例信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 增加 续租次数 到 监控</span></div><div class="line"> <span class="number">3</span>:     RENEW.increment(isReplication);</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 获得 租约</span></div><div class="line"> <span class="number">5</span>:     Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"> <span class="number">6</span>:     Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">8</span>:         leaseToRenew = gMap.get(id);</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>:         RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"><span class="number">13</span>:         logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">14</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">15</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>:         InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></div><div class="line"><span class="number">19</span>:             <span class="comment">// override status</span></div><div class="line"><span class="number">20</span>:             InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line"><span class="number">21</span>:                     instanceInfo, leaseToRenew, isReplication);</div><div class="line"><span class="number">22</span>:             <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line"><span class="number">23</span>:                 logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line"><span class="number">24</span>:                         + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line"><span class="number">25</span>:                 RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"><span class="number">26</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">27</span>:             &#125;</div><div class="line"><span class="number">28</span>:             <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line"><span class="number">29</span>:                 Object[] args = &#123;</div><div class="line"><span class="number">30</span>:                         instanceInfo.getStatus().name(),</div><div class="line"><span class="number">31</span>:                         instanceInfo.getOverriddenStatus().name(),</div><div class="line"><span class="number">32</span>:                         instanceInfo.getId()</div><div class="line"><span class="number">33</span>:                 &#125;;</div><div class="line"><span class="number">34</span>:                 logger.info(</div><div class="line"><span class="number">35</span>:                         <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line"><span class="number">36</span>:                                 + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line"><span class="number">37</span>:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"><span class="number">38</span>:             &#125;</div><div class="line"><span class="number">39</span>:         &#125;</div><div class="line"><span class="number">40</span>:         <span class="comment">// 新增 续租每分钟次数</span></div><div class="line"><span class="number">41</span>:         renewsLastMin.increment();</div><div class="line"><span class="number">42</span>:         <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">43</span>:         leaseToRenew.renew();</div><div class="line"><span class="number">44</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">45</span>:     &#125;</div><div class="line"><span class="number">46</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 至 3 行 ：增加续租次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p></li><li><p>第 4 至 9 行 ：获得租约( Lease )。</p></li><li><p>第 10 至 14 行 ：租约不存在，返回续租失败( <code>false</code> )。</p></li><li><p>第 19 至 21 行 ：获得应用实例的<strong>最终状态</strong>。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li><p>第 22 至 27 行 ：应用实例的<strong>最终状态</strong>为 <code>UNKNOWN</code>，无法续约，返回 <code>false</code> 。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li><p>第 28 至 37 行 ：应用实例的状态与<strong>最终状态</strong>不相等，使用<strong>最终状态</strong>覆盖应用实例的状态。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li><p>第 40 至 41 行 ：新增续租每分钟次数( <code>renewsLastMin</code> )。<code>com.netflix.eureka.util.MeasuredRate</code>，速度测量类，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 续租每分钟次数</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> MeasuredRate renewsLastMin;</div><div class="line"></div><div class="line"><span class="comment">// MeasuredRate.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasuredRate</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 上一个间隔次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前间隔次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong currentBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 间隔</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sampleInterval;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Timer timer;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isActive;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeasuredRate</span><span class="params">(<span class="keyword">long</span> sampleInterval)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.sampleInterval = sampleInterval;</div><div class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"Eureka-MeasureRateTimer"</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">this</span>.isActive = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isActive) &#123;</div><div class="line">            timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">// Zero out the current bucket.</span></div><div class="line">                        lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                        logger.error(<span class="string">"Cannot reset the Measured Rate"</span>, e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, sampleInterval, sampleInterval);</div><div class="line"></div><div class="line">            isActive = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isActive) &#123;</div><div class="line">            timer.cancel();</div><div class="line">            isActive = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the count in the last sample interval.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastBucket.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Increments the count in the current sample interval.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        currentBucket.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>timer</code> ，定时器，负责每个 <code>sampleInterval</code> 间隔重置<strong>当前次数</strong>( <code>currentBucket</code> )，并将<strong>原当前次数</strong>设置到<strong>上一个次数</strong>( <code>lastBucket</code> )。</li><li><code>#increment()</code> 方法，返回<strong>当前次数</strong>( <code>currentBucket</code> )。</li><li><code>#getCount()</code> 方法，返回<strong>上一个次数</strong>( <code>lastBucket</code> )。</li><li><code>renewsLastMin</code> 有如下用途：<ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集<strong>续租每分钟次数</strong>。</li><li>Eureka-Server 运维界面的显示<strong>续租每分钟次数</strong>。</li><li>自我保护机制，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现 （四）之自我保护机制》</a> 详细解析。</li></ul></li></ul></li><li><p>第 42 至 43 行 ：调用 <code>Lease#renew()</code> 方法，设置租约最后更新时间( 续租 )，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">    lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 44 行 ：返回续租成功( <code>true</code> )。</p></li><li><p><strong>整个过程修改的租约的过期时间，即使并发请求，也不会对数据的一致性产生不一致的影响，因此像注册操作一样加锁</strong>。</p></li></ul><h1>666. 彩蛋</h1><p>效率比想象的低一些，加油继续更新下一篇。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-renew/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（一）之注册</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-register/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-register/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-register/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2. Eureka-Client 发起注册</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.1 应用实例信息复制器</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.2 刷新应用实例信息</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.3 发起注册应用实例</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3. Eureka-Server 接收注册</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.1 接收注册请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.2 Lease</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.3 注册应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 注册应用实例的过程</strong>。</p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. Eureka-Client 发起注册</h1><p>Eureka-Client 向 Eureka-Server 发起注册应用实例需要符合如下条件：</p><ul><li>配置 <code>eureka.registration.enabled = true</code>，Eureka-Client 向 Eureka-Server 发起注册应用实例的<strong>开关</strong>。</li><li>InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致。</li></ul><p>每次 InstanceInfo 发生<strong>属性变化</strong>时，标记 <code>isInstanceInfoDirty</code> 属性为 <code>true</code>，表示 InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致，需要注册。另外，InstanceInfo 刚被创建时，在 Eureka-Server 不存在，也会被注册。</p><p>当符合条件时，InstanceInfo 不会立即向 Eureka-Server 注册，而是后台线程<strong>定时</strong>注册。</p><p>当 InstanceInfo 的状态( <code>status</code> ) 属性发生变化时，并且配置 <code>eureka.shouldOnDemandUpdateStatusChange = true</code> 时，立即向 Eureka-Server 注册。<strong>因为状态属性非常重要，一般情况下建议开启，当然默认情况也是开启的</strong>。</p><p>Let's Go。让我们看看代码的实现。</p><h2>2.1 应用实例信息复制器</h2><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryClient</span> <span class="keyword">implements</span> <span class="title">EurekaClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ApplicationInfoManager.StatusChangeListener statusChangeListener;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息复制器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InstanceInfoReplicator instanceInfoReplicator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">        </div><div class="line">            <span class="comment">// ... 省略无关代码</span></div><div class="line">            </div><div class="line">            <span class="comment">// 创建 应用实例信息复制器</span></div><div class="line">            <span class="comment">// InstanceInfo replicator</span></div><div class="line">            instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    instanceInfo,</div><div class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</div><div class="line">                    <span class="number">2</span>); <span class="comment">// burstSize</span></div><div class="line"></div><div class="line">            <span class="comment">// 创建 应用实例状态变更监听器</span></div><div class="line">            statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</div><div class="line">                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</div><div class="line">                        <span class="comment">// log at warn level if DOWN was involved</span></div><div class="line">                        logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">                    &#125;</div><div class="line">                    instanceInfoReplicator.onDemandUpdate();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="comment">// 注册 应用实例状态变更监听器</span></div><div class="line">            <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</div><div class="line">                applicationInfoManager.registerStatusChangeListener(statusChangeListener);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 开启 应用实例信息复制器</span></div><div class="line">            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.discovery.InstanceInfoReplicator</code>，应用实例信息复制器。</p><ul><li><p>调用 <code>InstanceInfoReplicator#start(...)</code> 方法，<strong>开启</strong>应用实例信息复制器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InstanceInfoReplicator.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo instanceInfo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行频率，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicationIntervalSeconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行任务的 Future</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Future&gt; scheduledPeriodicRef;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否开启调度</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean started;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter; <span class="comment">// 限流相关，跳过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> burstSize; <span class="comment">// 限流相关，跳过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> allowedRatePerMinute; <span class="comment">// 限流相关，跳过</span></div><div class="line"></div><div class="line">    InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, <span class="keyword">int</span> replicationIntervalSeconds, <span class="keyword">int</span> burstSize) &#123;</div><div class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</div><div class="line">        <span class="keyword">this</span>.instanceInfo = instanceInfo;</div><div class="line">        <span class="keyword">this</span>.scheduler = Executors.newScheduledThreadPool(<span class="number">1</span>,</div><div class="line">                <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                        .setNameFormat(<span class="string">"DiscoveryClient-InstanceInfoReplicator-%d"</span>)</div><div class="line">                        .setDaemon(<span class="keyword">true</span>)</div><div class="line">                        .build());</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.scheduledPeriodicRef = <span class="keyword">new</span> AtomicReference&lt;Future&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.started = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">this</span>.rateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">this</span>.replicationIntervalSeconds = replicationIntervalSeconds;</div><div class="line">        <span class="keyword">this</span>.burstSize = burstSize;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.allowedRatePerMinute = <span class="number">60</span> * <span class="keyword">this</span>.burstSize / <span class="keyword">this</span>.replicationIntervalSeconds;</div><div class="line">        logger.info(<span class="string">"InstanceInfoReplicator onDemand update allowed rate per min is &#123;&#125;"</span>, allowedRatePerMinute);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initialDelayMs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            <span class="comment">// 设置 应用实例信息 数据不一致</span></div><div class="line">            instanceInfo.setIsDirty();  <span class="comment">// for initial register</span></div><div class="line">            <span class="comment">// 提交任务，并设置该任务的 Future</span></div><div class="line">            Future next = scheduler.schedule(<span class="keyword">this</span>, initialDelayMs, TimeUnit.SECONDS);</div><div class="line">            scheduledPeriodicRef.set(next);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isInstanceInfoDirty = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Long lastDirtyTimestamp;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setIsDirty</span><span class="params">()</span> </span>&#123;</div><div class="line">   isInstanceInfoDirty = <span class="keyword">true</span>;</div><div class="line">   lastDirtyTimestamp = System.currentTimeMillis();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>执行 <code>instanceInfo.setIsDirty()</code> 代码块，因为 <strong>InstanceInfo 刚被创建时，在 Eureka-Server 不存在，也会被注册</strong>。</li><li>调用 <code>ScheduledExecutorService#schedule(...)</code> 方法，延迟 <code>initialDelayMs</code> 毫秒执行<strong>一次</strong>任务。为什么此处设置 <code>scheduledPeriodicRef</code> ？在 <code>InstanceInfoReplicator#onDemandUpdate()</code> 方法会看到具体用途。</li></ul></li><li><p><strong>定时</strong>检查 InstanceInfo 的状态( <code>status</code> ) 属性是否发生变化。<strong>若是</strong>，发起注册。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 刷新 应用实例信息</span></div><div class="line">       discoveryClient.refreshInstanceInfo();</div><div class="line">       <span class="comment">// 判断 应用实例信息 是否数据不一致</span></div><div class="line">       Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</div><div class="line">       <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">// 发起注册</span></div><div class="line">           discoveryClient.register();</div><div class="line">           <span class="comment">// 设置 应用实例信息 数据一致</span></div><div class="line">           instanceInfo.unsetIsDirty(dirtyTimestamp);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 提交任务，并设置该任务的 Future</span></div><div class="line">       Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">       scheduledPeriodicRef.set(next);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">setIsDirtyWithTime</span><span class="params">()</span> </span>&#123;</div><div class="line">   setIsDirty();</div><div class="line">   <span class="keyword">return</span> lastDirtyTimestamp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unsetIsDirty</span><span class="params">(<span class="keyword">long</span> unsetDirtyTimestamp)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (lastDirtyTimestamp &lt;= unsetDirtyTimestamp) &#123;</div><div class="line">       isInstanceInfoDirty = <span class="keyword">false</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>DiscoveryClient#refreshInstanceInfo()</code> 方法，刷新应用实例信息。<strong>此处可能导致应用实例信息数据不一致</strong>，在<a href="#">「2.2」刷新应用实例信息</a> 详细解析。</li><li>调用 <code>DiscoveryClient#register()</code> 方法，<strong>Eureka-Client 向 Eureka-Server 注册应用实例</strong>。</li><li>调用 <code>ScheduledExecutorService#schedule(...)</code> 方法，再次延迟执行任务，并设置 <code>scheduledPeriodicRef</code>。通过这样的方式，不断<strong>循环</strong>定时执行任务。</li></ul></li></ul></li><li><p><code>com.netflix.appinfo.ApplicationInfoManager.StatusChangeListener</code> <strong>内部类</strong>，监听应用实例信息状态的变更。</p><ul><li><p>调用 <code>ApplicationInfoManager#registerStatusChangeListener(...)</code> 方法，注册应用实例状态变更监听器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfoManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, StatusChangeListener&gt; listeners;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStatusChangeListener</span><span class="params">(StatusChangeListener listener)</span> </span>&#123;</div><div class="line">        listeners.put(listener.getId(), listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><strong>业务里</strong>，调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法，设置应用实例信息的状态，从而<strong>通知</strong> <code>InstanceInfoReplicator#onDemandUpdate()</code> 方法的调用。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setInstanceStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</div><div class="line">   InstanceStatus next = instanceStatusMapper.map(status);</div><div class="line">   <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   InstanceStatus prev = instanceInfo.setStatus(next);</div><div class="line">   <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (StatusChangeListener listener : listeners.values()) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               listener.notify(<span class="keyword">new</span> StatusChangeEvent(prev, next));</div><div class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">               logger.warn(<span class="string">"failed to notify listener: &#123;&#125;"</span>, listener.getId(), e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InstanceStatus <span class="title">setStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.status != status) &#123;</div><div class="line">       InstanceStatus prev = <span class="keyword">this</span>.status;</div><div class="line">       <span class="keyword">this</span>.status = status;</div><div class="line">       <span class="comment">// 设置 应用实例信息 数据一致</span></div><div class="line">       setIsDirty();</div><div class="line">       <span class="keyword">return</span> prev;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>InstanceInfoReplicator#onDemandUpdate()</code>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDemandUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123; <span class="comment">// 限流相关，跳过</span></div><div class="line">       scheduler.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               logger.debug(<span class="string">"Executing on-demand update of local InstanceInfo"</span>);</div><div class="line">               <span class="comment">// 取消任务</span></div><div class="line">               Future latestPeriodic = scheduledPeriodicRef.get();</div><div class="line">               <span class="keyword">if</span> (latestPeriodic != <span class="keyword">null</span> &amp;&amp; !latestPeriodic.isDone()) &#123;</div><div class="line">                   logger.debug(<span class="string">"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update"</span>);</div><div class="line">                   latestPeriodic.cancel(<span class="keyword">false</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="comment">// 再次调用</span></div><div class="line">               InstanceInfoReplicator.<span class="keyword">this</span>.run();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.warn(<span class="string">"Ignoring onDemand update due to rate limiter"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>Future#cancel(false)</code> 方法，取消定时任务，<strong>避免无用的注册</strong>。</li><li>调用 <code>InstanceInfoReplicator#run()</code> 方法，发起注册。</li></ul></li></ul></li></ul><h2>2.2 刷新应用实例信息</h2><p>调用 <code>DiscoveryClient#refreshInstanceInfo()</code> 方法，刷新应用实例信息。<strong>此处可能导致应用实例信息数据不一致</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshInstanceInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 刷新 数据中心信息</span></div><div class="line">   applicationInfoManager.refreshDataCenterInfoIfRequired();</div><div class="line">   <span class="comment">// 刷新 租约信息</span></div><div class="line">   applicationInfoManager.refreshLeaseInfoIfRequired();</div><div class="line">   <span class="comment">// 健康检查</span></div><div class="line">   InstanceStatus status;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       status = getHealthCheckHandler().getStatus(instanceInfo.getStatus());</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"Exception from healthcheckHandler.getStatus, setting status to DOWN"</span>, e);</div><div class="line">       status = InstanceStatus.DOWN;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</div><div class="line">       applicationInfoManager.setInstanceStatus(status);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>ApplicationInfoManager#refreshDataCenterInfoIfRequired()</code> 方法，刷新数据中心相关信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshDataCenterInfoIfRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// hostname</span></div><div class="line">   String existingAddress = instanceInfo.getHostName();</div><div class="line">   String newAddress;</div><div class="line">   <span class="keyword">if</span> (config <span class="keyword">instanceof</span> RefreshableInstanceConfig) &#123;</div><div class="line">       <span class="comment">// Refresh data center info, and return up to date address</span></div><div class="line">       newAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(<span class="keyword">true</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       newAddress = config.getHostName(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ip</span></div><div class="line">   String newIp = config.getIpAddress();</div><div class="line">   <span class="keyword">if</span> (newAddress != <span class="keyword">null</span> &amp;&amp; !newAddress.equals(existingAddress)) &#123;</div><div class="line">       logger.warn(<span class="string">"The address changed from : &#123;&#125; =&gt; &#123;&#125;"</span>, existingAddress, newAddress);</div><div class="line">       <span class="comment">// :( in the legacy code here the builder is acting as a mutator.</span></div><div class="line">       <span class="comment">// This is hard to fix as this same instanceInfo instance is referenced elsewhere.</span></div><div class="line">       <span class="comment">// We will most likely re-write the client at sometime so not fixing for now.</span></div><div class="line">       InstanceInfo.Builder builder = <span class="keyword">new</span> InstanceInfo.Builder(instanceInfo);</div><div class="line">       builder.setHostName(newAddress) <span class="comment">// hostname</span></div><div class="line">               .setIPAddr(newIp) <span class="comment">// ip</span></div><div class="line">               .setDataCenterInfo(config.getDataCenterInfo()); <span class="comment">// dataCenterInfo</span></div><div class="line">       instanceInfo.setIsDirty();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pair&lt;String, String&gt; hostInfo = getHostInfo();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">(<span class="keyword">boolean</span> refresh)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hostInfo.second();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hostInfo.first();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">getHostInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Pair&lt;String, String&gt; pair;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InetAddress localHost = InetAddress.getLocalHost();</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(localHost.getHostAddress(), localHost.getHostName());</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot get host info"</span>, e);</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(<span class="string">""</span>, <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pair;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>关注应用实例信息的 <code>hostName</code> 、 <code>ipAddr</code> 、 <code>dataCenterInfo</code> 属性的变化。</li><li>一般情况下，我们使用的是非 RefreshableInstanceConfig 实现的配置类( 一般是 MyDataCenterInstanceConfig )，因为 <code>AbstractInstanceConfig.hostInfo</code> 是<strong>静态属性</strong>，<strong>即使本机修改了 IP 等信息，Eureka-Client 进程也不会感知到</strong>。TODO[0022]：看下springcloud 的实现</li></ul></li><li><p>调用 <code>ApplicationInfoManager#refreshLeaseInfoIfRequired()</code> 方法，刷新租约相关信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshLeaseInfoIfRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">   LeaseInfo leaseInfo = instanceInfo.getLeaseInfo();</div><div class="line">   <span class="keyword">if</span> (leaseInfo == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> currentLeaseDuration = config.getLeaseExpirationDurationInSeconds();</div><div class="line">   <span class="keyword">int</span> currentLeaseRenewal = config.getLeaseRenewalIntervalInSeconds();</div><div class="line">   <span class="keyword">if</span> (leaseInfo.getDurationInSecs() != currentLeaseDuration <span class="comment">// 租约过期时间 改变</span></div><div class="line">           || leaseInfo.getRenewalIntervalInSecs() != currentLeaseRenewal) &#123; <span class="comment">// 租约续约频率 改变</span></div><div class="line">       LeaseInfo newLeaseInfo = LeaseInfo.Builder.newBuilder()</div><div class="line">               .setRenewalIntervalInSecs(currentLeaseRenewal)</div><div class="line">               .setDurationInSecs(currentLeaseDuration)</div><div class="line">               .build();</div><div class="line">       instanceInfo.setLeaseInfo(newLeaseInfo);</div><div class="line">       instanceInfo.setIsDirty();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>关注应用实例信息的 <code>renewalIntervalInSecs</code> 、 <code>durationInSecs</code> 属性的变化。</li></ul></li><li><p>调用 <code>HealthCheckHandler#getStatus()</code> 方法，健康检查。这里先暂时跳过，我们在<a href="#">TODO[0004]：健康检查</a> 详细解析。</p></li></ul><h2>2.3 发起注册应用实例</h2><p>调用 <code>DiscoveryClient#register()</code> 方法，<strong>Eureka-Client 向 Eureka-Server 注册应用实例</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   logger.info(PREFIX + appPathIdentifier + <span class="string">": registering service..."</span>);</div><div class="line">   EurekaHttpResponse&lt;Void&gt; httpResponse;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, PREFIX + appPathIdentifier, e.getMessage(), e);</div><div class="line">       <span class="keyword">throw</span> e;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">       logger.info(<span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</div><div class="line">   String urlPath = <span class="string">"apps/"</span> + info.getAppName();</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line">       addExtraHeaders(resourceBuilder);</div><div class="line">       response = resourceBuilder</div><div class="line">               .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</div><div class="line">               .type(MediaType.APPLICATION_JSON_TYPE)</div><div class="line">               .accept(MediaType.APPLICATION_JSON)</div><div class="line">               .post(ClientResponse.class, info);</div><div class="line">       <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</div><div class="line">                   response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#register(...)</code> 方法，<code>POST</code> 请求 Eureka-Server 的 <code>apps/${APP_NAME}</code> 接口，参数为 InstanceInfo ，实现注册实例信息的注册。</li></ul><h1>3. Eureka-Server 接收注册</h1><h2>3.1 接收注册请求</h2><p><code>com.netflix.eureka.resources.ApplicationResource</code>，处理<strong>单个</strong>应用的请求操作的 Resource ( Controller )。</p><p>注册应用实例信息的请求，映射 <code>ApplicationResource#addInstance()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@POST</span></div><div class="line">    <span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></div><div class="line"><span class="function"><span class="params">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</div><div class="line">        <span class="comment">// 校验参数是否合法</span></div><div class="line">        logger.debug(<span class="string">"Registering instance &#123;&#125; (replication=&#123;&#125;)"</span>, info.getId(), isReplication);</div><div class="line">        <span class="comment">// validate that the instanceinfo contains all the necessary required fields</span></div><div class="line">        <span class="keyword">if</span> (isBlank(info.getId())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing instanceId"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getHostName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing hostname"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getIPAddr())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing ip address"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getAppName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing appName"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!appName.equals(info.getAppName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Mismatched appName, expecting "</span> + appName + <span class="string">" but was "</span> + info.getAppName()).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo().getName() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo Name"</span>).build();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// AWS 相关，跳过</span></div><div class="line">        <span class="comment">// handle cases where clients may be registering with bad DataCenterInfo with missing data</span></div><div class="line">        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</div><div class="line">        <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</div><div class="line">            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();</div><div class="line">            <span class="keyword">if</span> (isBlank(dataCenterInfoId)) &#123;</div><div class="line">                <span class="keyword">boolean</span> experimental = <span class="string">"true"</span>.equalsIgnoreCase(serverConfig.getExperimental(<span class="string">"registration.validation.dataCenterInfoId"</span>));</div><div class="line">                <span class="keyword">if</span> (experimental) &#123;</div><div class="line">                    String entity = <span class="string">"DataCenterInfo of type "</span> + dataCenterInfo.getClass() + <span class="string">" must contain a valid id"</span>;</div><div class="line">                    <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(entity).build();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> AmazonInfo) &#123;</div><div class="line">                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;</div><div class="line">                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);</div><div class="line">                    <span class="keyword">if</span> (effectiveId == <span class="keyword">null</span>) &#123;</div><div class="line">                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    logger.warn(<span class="string">"Registering DataCenterInfo of type &#123;&#125; without an appropriate id"</span>, dataCenterInfo.getClass());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 注册应用实例信息</span></div><div class="line">        registry.register(info, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">        <span class="comment">// 返回 204 成功</span></div><div class="line">        <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>请求头 <code>isReplication</code> 参数，和 Eureka-Server 集群复制相关，暂时跳过。</p></li><li><p>调用 <code>PeerAwareInstanceRegistryImpl#register(...)</code> 方法，注册应用实例信息。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用父类 <code>AbstractInstanceRegistry#register(...)</code> 方法，注册应用实例信息。</li></ul></li></ul><h2>3.2 Lease</h2><p>在看具体的注册应用实例信息的逻辑之前，我们先来看下 <code>com.netflix.eureka.lease.Lease</code>，租约。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lease</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> T holder;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 注册时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> registrationTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始服务时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serviceUpTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消注册时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> evictionTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后更新时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">// Make it volatile so that the expiration task would see this quicker</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastUpdateTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 租约持续时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</div><div class="line">        holder = r;</div><div class="line">        registrationTimestamp = System.currentTimeMillis();</div><div class="line">        lastUpdateTimestamp = registrationTimestamp;</div><div class="line">        duration = (durationInSecs * <span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>holder</code> 属性，租约的持有者。在 Eureka-Server 里，暂时只有 InstanceInfo 使用。</p></li><li><p><code>registrationTimestamp</code> 属性，注册( 创建 )租约时间戳。在<strong>构造方法</strong>里可以看租约对象的创建时间戳即为注册租约时间戳。</p></li><li><p><code>serviceUpTimestamp</code> 属性，开始服务时间戳。注册应用实例信息会使用到它如下两个方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceUp</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (serviceUpTimestamp == <span class="number">0</span>) &#123; <span class="comment">// 第一次有效</span></div><div class="line">       serviceUpTimestamp = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceUpTimestamp</span><span class="params">(<span class="keyword">long</span> serviceUpTimestamp)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.serviceUpTimestamp = serviceUpTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>lastUpdatedTimestamp</code> 属性，最后更新租约时间戳。每次续租时，更新该时间戳。注册应用实例信息会使用到它如下方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdatedTimestamp</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.lastUpdatedTimestamp = System.currentTimeMillis();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>duration</code> 属性，租约持续时间，单位：毫秒。当租约过久未续租，即当前时间 - <code>lastUpdatedTimestamp</code> &gt; <code>duration</code> 时，租约过期。</p></li><li><p><code>evictionTimestamp</code> 属性，租约过期时间戳。</p></li></ul><h2>3.3 注册应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#register(...)</code> 方法，注册应用实例信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// TODO 为什么是读锁</span></div><div class="line"> <span class="number">4</span>:         read.lock();</div><div class="line"> <span class="number">5</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 增加 注册次数 到 监控</span></div><div class="line"> <span class="number">7</span>:         REGISTER.increment(isReplication);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 获得 应用实例信息 对应的 租约</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</div><div class="line"><span class="number">11</span>:             gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); <span class="comment">// 添加 应用</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123; <span class="comment">// 添加 应用 成功</span></div><div class="line"><span class="number">13</span>:                 gMap = gNewMap;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</div><div class="line"><span class="number">17</span>:         <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123; <span class="comment">// 已存在时，使用数据不一致的时间大的应用注册信息为有效的</span></div><div class="line"><span class="number">19</span>:             Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp(); <span class="comment">// Server 注册的 InstanceInfo</span></div><div class="line"><span class="number">20</span>:             Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp(); <span class="comment">// Client 请求的 InstanceInfo</span></div><div class="line"><span class="number">21</span>:             logger.debug(<span class="string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:             <span class="comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span></div><div class="line"><span class="number">24</span>:             <span class="comment">// InstanceInfo instead of the server local copy.</span></div><div class="line"><span class="number">25</span>:             <span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</div><div class="line"><span class="number">26</span>:                 logger.warn(<span class="string">"There is an existing lease and the existing lease's dirty timestamp &#123;&#125; is greater"</span> +</div><div class="line"><span class="number">27</span>:                         <span class="string">" than the one that is being registered &#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</div><div class="line"><span class="number">28</span>:                 logger.warn(<span class="string">"Using the existing instanceInfo instead of the new instanceInfo as the registrant"</span>);</div><div class="line"><span class="number">29</span>:                 registrant = existingLease.getHolder();</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">32</span>:             <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line"><span class="number">33</span>:             <span class="comment">// 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"><span class="number">34</span>:             <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:                     <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></div><div class="line"><span class="number">37</span>:                     <span class="comment">// (1</span></div><div class="line"><span class="number">38</span>:                     <span class="comment">// for 30 seconds, 2 for a minute)</span></div><div class="line"><span class="number">39</span>:                     <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</div><div class="line"><span class="number">40</span>:                     <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line"><span class="number">41</span>:                             (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">42</span>:                 &#125;</div><div class="line"><span class="number">43</span>:             &#125;</div><div class="line"><span class="number">44</span>:             logger.debug(<span class="string">"No previous lease information found; it is new registration"</span>);</div><div class="line"><span class="number">45</span>:         &#125;</div><div class="line"><span class="number">46</span>:         <span class="comment">// 创建 租约</span></div><div class="line"><span class="number">47</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</div><div class="line"><span class="number">48</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123; <span class="comment">// 若租约已存在，设置 租约的开始服务的时间戳</span></div><div class="line"><span class="number">49</span>:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</div><div class="line"><span class="number">50</span>:         &#125;</div><div class="line"><span class="number">51</span>:         <span class="comment">// 添加到 租约映射</span></div><div class="line"><span class="number">52</span>:         gMap.put(registrant.getId(), lease);</div><div class="line"><span class="number">53</span>:         <span class="comment">// 添加到 最近注册的调试队列</span></div><div class="line"><span class="number">54</span>:         <span class="keyword">synchronized</span> (recentRegisteredQueue) &#123;</div><div class="line"><span class="number">55</span>:             recentRegisteredQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(</div><div class="line"><span class="number">56</span>:                     System.currentTimeMillis(),</div><div class="line"><span class="number">57</span>:                     registrant.getAppName() + <span class="string">"("</span> + registrant.getId() + <span class="string">")"</span>));</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:         <span class="comment">// TODO[0021]：集群同步</span></div><div class="line"><span class="number">60</span>:         <span class="comment">// This is where the initial state transfer of overridden status happens</span></div><div class="line"><span class="number">61</span>:         <span class="keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</div><div class="line"><span class="number">62</span>:             logger.debug(<span class="string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span></div><div class="line"><span class="number">63</span>:                             + <span class="string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());</div><div class="line"><span class="number">64</span>:             <span class="keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</div><div class="line"><span class="number">65</span>:                 logger.info(<span class="string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());</div><div class="line"><span class="number">66</span>:                 overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</div><div class="line"><span class="number">67</span>:             &#125;</div><div class="line"><span class="number">68</span>:         &#125;</div><div class="line"><span class="number">69</span>:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</div><div class="line"><span class="number">70</span>:         <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">71</span>:             logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</div><div class="line"><span class="number">72</span>:             registrant.setOverriddenStatus(overriddenStatusFromMap);</div><div class="line"><span class="number">73</span>:         &#125;</div><div class="line"><span class="number">74</span>: </div><div class="line"><span class="number">75</span>:         <span class="comment">// 获得应用实例最终状态，并设置应用实例的状态</span></div><div class="line"><span class="number">76</span>:         <span class="comment">// Set the status based on the overridden status rules</span></div><div class="line"><span class="number">77</span>:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</div><div class="line"><span class="number">78</span>:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"><span class="number">79</span>: </div><div class="line"><span class="number">80</span>:         <span class="comment">// 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"><span class="number">81</span>:         <span class="comment">// If the lease is registered with UP status, set lease service up timestamp</span></div><div class="line"><span class="number">82</span>:         <span class="keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</div><div class="line"><span class="number">83</span>:             lease.serviceUp();</div><div class="line"><span class="number">84</span>:         &#125;</div><div class="line"><span class="number">85</span>:         <span class="comment">// 设置 应用实例信息的操作类型 为 添加</span></div><div class="line"><span class="number">86</span>:         registrant.setActionType(ActionType.ADDED);</div><div class="line"><span class="number">87</span>:         <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">88</span>:         recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">89</span>:         <span class="comment">// 设置 租约的最后更新时间戳</span></div><div class="line"><span class="number">90</span>:         registrant.setLastUpdatedTimestamp();</div><div class="line"><span class="number">91</span>:         <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">92</span>:         invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</div><div class="line"><span class="number">93</span>:         logger.info(<span class="string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,</div><div class="line"><span class="number">94</span>:                 registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</div><div class="line"><span class="number">95</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">96</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">97</span>:         read.unlock();</div><div class="line"><span class="number">98</span>:     &#125;</div><div class="line"><span class="number">99</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 行 ：TODO 为什么是读锁。</p></li><li><p>第 6 至 7 行 ：增加注册次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p></li><li><p>第 5 至 16 行 ：获得应用实例信息对应的<strong>租约</strong>。<code>registry</code> 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 租约映射</span></div><div class="line"><span class="comment"> * key1 ：应用名 &#123;<span class="doctag">@link</span> InstanceInfo#appName&#125;</span></div><div class="line"><span class="comment"> * key2 ：应用实例信息编号 &#123;<span class="doctag">@link</span> InstanceInfo#instanceId&#125;</span></div><div class="line"><span class="comment"> * value ：租约</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</div></pre></td></tr></table></figure></p></li><li><p>第 17 至 30 行 ：当租约<strong>已存在</strong>，判断 Server 已存在的 InstanceInfo 的 <code>lastDirtyTimestamp</code> 是否<strong>大于</strong>( 不包括等于 ) Client 请求的 InstanceInfo ，<strong>若是，使用 Server 的 InstanceInfo 进行替代</strong>。</p></li><li><p>第 31 至 44 行 ：增加 <code>numberOfRenewsPerMinThreshold</code> 、<code>expectedNumberOfRenewsPerMin</code>，自我保护机制相关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</p></li><li><p>第 45 至 52 行 ：创建租约，并添加到租约映射( <code>registry</code> )。</p></li><li><p>第 53 至 58 行 ：添加到最近注册的<strong>调试</strong>队列( <code>recentRegisteredQueue</code> )，用于 Eureka-Server 运维界面的显示，无实际业务逻辑使用。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近注册的调试队列</span></div><div class="line"><span class="comment">* key ：添加时的时间戳</span></div><div class="line"><span class="comment">* value ：字符串 = 应用名(应用实例信息编号)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt; recentRegisteredQueue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 循环队列</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;E&gt; 泛型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 队列大小</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.size = size;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.makeSpaceIfNotAvailable();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 保证空间足够</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * 当空间不够时，移除首元素</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeSpaceIfNotAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.size() == size) &#123;</div><div class="line">           <span class="keyword">this</span>.remove();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.makeSpaceIfNotAvailable();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.offer(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 59 至 68 行 ： TODO[0021]：集群同步</p></li><li><p>第 69 至 73 行 ：设置应用实例的覆盖状态( <code>overridestatus</code> )，避免注册应用实例后，丢失覆盖状态。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li><p>第 75 至 78 行 ： <strong>获得应用实例最终状态</strong>，并设置应用实例的状态。在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《应用实例注册发现 （八）之覆盖状态》</a>详细解析。</p></li><li><p>第 80 至 84 行 ：设置租约的开始服务的时间戳( <strong>只有第一次有效</strong> )。</p></li><li><p>第 85 至 88 行 ：设置应用实例信息的<strong>操作类型为添加</strong>，并添加到最近租约变更记录队列( <code>recentlyChangedQueue</code> )。<code>recentlyChangedQueue</code> 用于注册信息的<strong>增量</strong>获取，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self">《应用实例注册发现 （七）之增量获取》</a>详细解析。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div></pre></td></tr></table></figure></p></li><li><p>第 89 至 90 行 ：设置租约的最后更新时间戳。</p></li><li><p>第 91 至 92 行 ：设置响应缓存( ResponseCache )过期，在<a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a>详细解析。</p></li><li><p>第 96 至 97 行 ：释放锁。</p></li></ul><h1>666. 彩蛋</h1><p>嘿嘿，蛮嗨的，比起前面几篇写配置相关的文章来说。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-register/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 注册表 InstanceRegistry 类关系</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-class-diagram/</id>
    <published>2018-05-20T16:00:00.000Z</published>
    <updated>2017-10-12T05:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-class-diagram/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">2. 类图</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">3. LookupService</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">4. LeaseManager</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">5. InstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">6. AbstractInstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">7. PeerAwareInstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">8. PeerAwareInstanceRegistryImpl</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">666. 彩蛋</a></li></ul><hr><h1>1. 概述</h1><p>本文主要简介 <strong>注册表 InstanceRegistry 的类关系</strong>，为后文的<strong>应用实例注册发现</strong>、<strong>Eureka-Server 集群复制</strong>做整体的铺垫。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 类图</h1><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_21/01.png" alt=""></p><ul><li><code>com.netflix.eureka.registry.AwsInstanceRegistry</code>，主要用于亚马逊 AWS，跳过。</li><li><code>com.netflix.eureka.registry.RemoteRegionRegistry</code>，笔者暂时不太理解它的用途。目前猜测 Eureka-Server 集群和集群之间的注册信息的交互方式。查阅官方资料，<a href="https://github.com/Netflix/eureka/issues/29" rel="external nofollow noopener noreferrer" target="_blank">《Add ability to retrieve instances from any remote region》</a> 在做了简单介绍。翻看目前网络上的博客、书籍、项目实战，暂时都没提及此块。估摸和亚马逊 AWS 跨区域( <code>region</code> ) 机制有一定关系，先暂时跳过。有了解此块的同学，麻烦告知下笔者，万分感谢。TODO[0009]：RemoteRegionRegistry。</li><li><strong>蓝框</strong>部分，本文主角。</li></ul><h1>3. LookupService</h1><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.shared.LookupService</code></a>，查找服务<strong>接口</strong>，提供<strong>简单单一</strong>的方式获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_29/01.png" alt=""></p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h1>4. LeaseManager</h1><p><code>com.netflix.eureka.lease.LeaseManager</code>，租约管理器<strong>接口</strong>，提供租约的注册、续租、取消( 主动下线 )、过期( 过期下线 )。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaseManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T r, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>5. InstanceRegistry</h1><p><code>com.netflix.eureka.registry.InstanceRegistry</code>，<strong>应用实例</strong>注册表<strong>接口</strong>。它继承了 LookupService 、LeaseManager 接口，提供应用实例的<strong>注册</strong>与<strong>发现</strong>服务。另外，它结合实际业务场景，定义了<strong>更加丰富</strong>的接口方法。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title">LeaseManager</span>&lt;<span class="title">InstanceInfo</span>&gt;, <span class="title">LookupService</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 开启与关闭相关 ======</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 应用实例状态变更相关 ======</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">storeOverriddenStatusIfRequired</span><span class="params">(String appName, String id, InstanceStatus overriddenStatus)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(String appName, String id, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                         String lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                 String lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Map&lt;String, InstanceStatus&gt; <span class="title">overriddenInstanceStatusesSnapshot</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 响应缓存相关 ======</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializedResponseCache</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ResponseCache <span class="title">getResponseCache</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ====== 自我保护模式相关 ======</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNumOfRenewsInLastMin</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumOfRenewsPerMinThreshold</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isBelowRenewThresold</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSelfPreservationModeEnabled</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ====== 调试/监控相关 ======</span></div><div class="line">    List&lt;Pair&lt;Long, String&gt;&gt; getLastNRegisteredInstances();</div><div class="line"></div><div class="line">    List&lt;Pair&lt;Long, String&gt;&gt; getLastNCanceledInstances();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>6. AbstractInstanceRegistry</h1><p><code>com.netflix.eureka.registry.AbstractInstanceRegistry</code>，应用对象注册表<strong>抽象实现</strong>。</p><p>这里先不拓展开，<a href="http://www.iocoder.cn/categories/Eureka/?self">《Eureka 源码解析 —— 应用实例注册发现》系列</a> 逐篇分享。</p><h1>7. PeerAwareInstanceRegistry</h1><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistry</code>，PeerAware ( 暂时找不到合适的翻译 ) 应用对象注册表<strong>接口</strong>，提供 Eureka-Server 集群内注册信息的<strong>同步</strong>服务。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PeerAwareInstanceRegistry</span> <span class="keyword">extends</span> <span class="title">InstanceRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PeerEurekaNodes peerEurekaNodes)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo info, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> String asgName, <span class="keyword">final</span> ASGResource.ASGStatus newStatus, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>8. PeerAwareInstanceRegistryImpl</h1><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl</code>，PeerAware ( 暂时找不到合适的翻译 ) 应用对象注册表<strong>实现类</strong>。</p><p>这里先不拓展开，<a href="http://www.iocoder.cn/categories/Eureka/?self">《Eureka 源码解析 —— Eureka-Server 集群》系列</a> 逐篇分享。</p><h1>666. 彩蛋</h1><p>本文是一篇<strong>简介</strong>( 啪啪啪，打脸 )，如果胖友比较着急想了解原理，可以阅读 <a href="http://techshow.ctrip.com/archives/1699.html?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">携程 ——《深度剖析服务发现组件Netflix Eureka》</a> 先，写的非常非常非常不错。</p><p>快马加鞭，更新 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》</a> <strong>ing</strong> ...</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-class-diagram/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 启动（二）之 EurekaBootStrap</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-server-init-second/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-server-init-second/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2017-10-12T05:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-server-init-second/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">2. EurekaBootStrap</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">2.1 初始化 Eureka-Server 配置环境</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">2.2 初始化 Eureka-Server 上下文</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3. Filter</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.1 StatusFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.2 ServerRequestAuthFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.3 RateLimitingFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.4 GzipEncodingEnforcingFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">3.5 ServletContainer</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">《Eureka 源码解析 —— Eureka-Server 启动（一）之 EurekaServerConfig》</a>，主要分享 <strong>Eureka-Server 启动的过程</strong>的第二部分 —— <strong>EurekaBootStrap</strong>。</p><p>考虑到整个初始化的过程中涉及的代码特别多，拆分成两两篇文章：</p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">ServerConfig</a></li><li>【本文】EurekaBootStrap</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EurekaBootStrap</h1><p><code>com.netflix.eureka.EurekaBootStrap</code>，Eureka-Server <strong>启动入口</strong>。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/01.png" alt=""></p><p>EurekaBootStrap 实现了 <code>javax.servlet.ServletContextListener</code> <strong>接口</strong>，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 <code>#contextInitialized()</code> 方法，初始化 Eureka-Server，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 省略无关变量和方法</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 初始化 Eureka-Server 配置环境</span></div><div class="line">            initEurekaEnvironment();</div><div class="line"></div><div class="line">            <span class="comment">// 初始化 Eureka-Server 上下文</span></div><div class="line">            initEurekaServerContext();</div><div class="line"></div><div class="line">            ServletContext sc = event.getServletContext();</div><div class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>#initEurekaEnvironment()</code> 方法，初始化 Eureka-Server <strong>配置</strong>环境。</li><li>调用 <code>#initEurekaServerContext()</code> 方法，初始化 Eureka-Server 上下文。</li></ul><h2>2.1 初始化 Eureka-Server 配置环境</h2><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaBootStrap.java</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署环境 - 测服</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署数据中心 - CLOUD</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOUD = <span class="string">"cloud"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署数据中心 - 默认</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT = <span class="string">"default"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_DATACENTER = <span class="string">"archaius.deployment.datacenter"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_DATACENTER = <span class="string">"eureka.datacenter"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    logger.info(<span class="string">"Setting the eureka configuration.."</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 设置配置文件的数据中心</span></div><div class="line">   String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);</div><div class="line">   <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</div><div class="line">       logger.info(<span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 设置配置文件的环境</span></div><div class="line">   String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);</div><div class="line">   <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</div><div class="line">       logger.info(<span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>设置基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius</a> 实现的配置文件的上下文，从而读取<strong>合适</strong>的配置文件。大多数情况下，只需要设置 <code>EUREKA_ENVIRONMENT</code> 即可，不同的服务器环境( 例如，<code>PROD</code> / <code>TEST</code> 等) 读取不同的配置文件。实现原理，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>有详细解析。</li><li>感兴趣的也可以阅读：<a href="https://github.com/Netflix/archaius/wiki/Deployment-context" rel="external nofollow noopener noreferrer" target="_blank">《Netflix Archaius 官方文档 —— Deployment context》</a>。</li></ul><h2>2.2 初始化 Eureka-Server 上下文</h2><p>EurekaBootStrap 的 <code>#initEurekaServerContext()</code> 方法的实现代码相对较多，已经将代码<strong>切块</strong> + <strong>中文注册</strong>，点击 <a href="https://github.com/YunaiV/eureka/blob/a1c6074fd038f1182132a43b1ebc4cc08166f0be/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L137" rel="external nofollow noopener noreferrer" target="_blank">EurekaBootStrap</a> 链接，对照下面每个小结阅读理解。</p><h3>2.2.1 创建 Eureka-Server 配置</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</div></pre></td></tr></table></figure></p><ul><li>在 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">《Eureka 源码解析 —— Eureka-Server 启动（一）之 ServerConfig》「2.3 DefaultEurekaServerConfig」</a> 有详细解析。</li></ul><h3>2.2.2 Eureka-Server 请求和响应的数据兼容</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// For backward compatibility</span></div><div class="line">JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div><div class="line">XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div></pre></td></tr></table></figure></p><ul><li>目前 Eureka-Server 提供 V2 版本 API ，如上代码主要对 V1 版本 API 做兼容。可以选择跳过。</li></ul><h3>2.2.3 创建 Eureka-Server 请求和响应编解码器</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">logger.info(<span class="string">"Initializing the eureka client..."</span>);</div><div class="line">logger.info(eurekaServerConfig.getJsonCodecName());</div><div class="line">ServerCodecs serverCodecs = <span class="keyword">new</span> DefaultServerCodecs(eurekaServerConfig);</div></pre></td></tr></table></figure></p><h3>2.2.4 创建 Eureka-Client</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ApplicationInfoManager applicationInfoManager;</div><div class="line"><span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</div><div class="line">  EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</div><div class="line">          ? <span class="keyword">new</span> CloudInstanceConfig()</div><div class="line">          : <span class="keyword">new</span> MyDataCenterInstanceConfig();</div><div class="line">  </div><div class="line">  applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</div><div class="line">          instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</div><div class="line">  </div><div class="line">  EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</div><div class="line">  eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  applicationInfoManager = eurekaClient.getApplicationInfoManager();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>Eureka-Server 内嵌 Eureka-Client，用于和 Eureka-Server 集群里其他节点通信交互。</p></li><li><p>Eureka-Client 的初始化过程，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">《Eureka 源码解析 —— Eureka-Client 初始化（三）之 EurekaClient》「3. DiscoveryClient」</a>有详细解析。</p></li><li><p>Eureka-Client 也可以通过 EurekaBootStrap 构造方法传递，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> EurekaClient eurekaClient;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EurekaBootStrap</span><span class="params">(EurekaClient eurekaClient)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.eurekaClient = eurekaClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>大多数情况下用不到</strong>。</li></ul></li></ul><h3>2.2.5 创建应用实例信息的注册表</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PeerAwareInstanceRegistry registry;</div><div class="line"><span class="keyword">if</span> (isAws(applicationInfoManager.getInfo())) &#123; <span class="comment">// AWS 相关，跳过</span></div><div class="line">  registry = <span class="keyword">new</span> AwsInstanceRegistry(</div><div class="line">          eurekaServerConfig,</div><div class="line">          eurekaClient.getEurekaClientConfig(),</div><div class="line">          serverCodecs,</div><div class="line">          eurekaClient</div><div class="line">  );</div><div class="line">  awsBinder = <span class="keyword">new</span> AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);</div><div class="line">  awsBinder.start();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</div><div class="line">          eurekaServerConfig,</div><div class="line">          eurekaClient.getEurekaClientConfig(),</div><div class="line">          serverCodecs,</div><div class="line">          eurekaClient</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>应用实例信息的注册表<strong>类关系图</strong>如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/02.png" alt=""></p></li><li><p>本文不展开分享，在<a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?self">《Eureka 源码解析 —— 注册表 InstanceRegistry 类关系》</a>详细解析。</p></li></ul><h3>2.2.6 创建 Eureka-Server 集群节点集合</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</div><div class="line">      registry,</div><div class="line">      eurekaServerConfig,</div><div class="line">      eurekaClient.getEurekaClientConfig(),</div><div class="line">      serverCodecs,</div><div class="line">      applicationInfoManager</div><div class="line">);</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.eureka.cluster.PeerEurekaNodes</code>，Eureka-Server 集群节点集合，在<a href="#">《TODO[0019]：集群初始化》</a>详细解析。</li></ul><h3>2.2.7 创建 Eureka-Server 上下文</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</div><div class="line">      eurekaServerConfig,</div><div class="line">      serverCodecs,</div><div class="line">      registry,</div><div class="line">      peerEurekaNodes,</div><div class="line">      applicationInfoManager</div><div class="line">);</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.eureka.EurekaServerContext</code>，Eureka-Server 上下文<strong>接口</strong>，提供Eureka-Server 内部各组件对象的<strong>初始化</strong>、<strong>关闭</strong>、<strong>获取</strong>等方法。</p></li><li><p><code>com.netflix.eureka.EurekaServerContext.DefaultEurekaServerContext</code>，Eureka-Server 上下文<strong>实现类</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerContext</span> <span class="keyword">implements</span> <span class="title">EurekaServerContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 请求和响应编解码器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息的注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerEurekaNodes peerEurekaNodes;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h3>2.2.8 初始化 EurekaServerContextHolder</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EurekaServerContextHolder.initialize(serverContext);</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.eureka.EurekaServerContextHolder</code>，Eureka-Server 上下文持有者。通过它，可以很方便的获取到 Eureka-Server 上下文，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerContextHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 持有者</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EurekaServerContextHolder holder;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerContext serverContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaServerContextHolder</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serverContext = serverContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">getServerContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serverContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> serverContext Eureka-Server 上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</div><div class="line">        holder = <span class="keyword">new</span> EurekaServerContextHolder(serverContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaServerContextHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> holder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h3>2.2.9 初始化 Eureka-Server 上下文</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverContext.initialize();</div><div class="line">logger.info(<span class="string">"Initialized server context"</span>);</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>ServerContext#initialize()</code> 方法，初始化 Eureka-Server 上下文，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DefaultEurekaServerContext.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   logger.info(<span class="string">"Initializing ..."</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 启动 Eureka-Server 集群节点集合（复制）</span></div><div class="line">   peerEurekaNodes.start();</div><div class="line">   <span class="comment">// 初始化 应用实例信息的注册表</span></div><div class="line">   registry.init(peerEurekaNodes);</div><div class="line"></div><div class="line">   logger.info(<span class="string">"Initialized"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h3>2.2.10 从其他 Eureka-Server 拉取注册信息</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Copy registry from neighboring eureka node</span></div><div class="line"><span class="keyword">int</span> registryCount = registry.syncUp();</div><div class="line">registry.openForTraffic(applicationInfoManager, registryCount);</div></pre></td></tr></table></figure></p><ul><li>本文不展开分享，在<a href="#">《TODO[0019]：集群初始化》</a>详细解析。</li></ul><h3>2.2.11 注册监控</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Register all monitoring statistics.</span></div><div class="line">EurekaMonitors.registerAllStats();</div></pre></td></tr></table></figure></p><ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul><h1>3. Filter</h1><p>Eureka-Server 过滤器( <code>javax.servlet.Filter</code> ) <strong>顺序</strong>如下：</p><ul><li>StatusFilter</li><li>ServerRequestAuthFilter</li><li>RateLimitingFilter</li><li>GzipEncodingEnforcingFilter</li><li>ServletContainer</li></ul><h2>3.1 StatusFilter</h2><p><code>com.netflix.eureka.StatusFilter</code>，Eureka-Server 状态过滤器。当 Eureka-Server 未处于开启( <code>InstanceStatus.UP</code> )状态，返回 HTTP 状态码 307 重定向，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatusFilter.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></div><div class="line"><span class="function"><span class="params">                   FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">  InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();</div><div class="line">  InstanceStatus status = myInfo.getStatus();</div><div class="line">  <span class="keyword">if</span> (status != InstanceStatus.UP &amp;&amp; response <span class="keyword">instanceof</span> HttpServletResponse) &#123;</div><div class="line">      HttpServletResponse httpRespone = (HttpServletResponse) response;</div><div class="line">      httpRespone.sendError(SC_TEMPORARY_REDIRECT,</div><div class="line">              <span class="string">"Current node is currently not ready to serve requests -- current status: "</span></div><div class="line">                      + status + <span class="string">" - try another DS node: "</span>);</div><div class="line">  &#125;</div><div class="line">  chain.doFilter(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>3.2 ServerRequestAuthFilter</h2><p><code>com.netflix.eureka.ServerRequestAuthFilter</code>，Eureka-Server 请求认证过滤器。Eureka-Server 未实现认证。目前打印访问的客户端名和版本号，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。实现代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerRequestAuthFilter.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logAuth</span><span class="params">(ServletRequest request)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (serverConfig.shouldLogIdentityHeaders()) &#123;</div><div class="line">       <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</div><div class="line">           HttpServletRequest httpRequest = (HttpServletRequest) request;</div><div class="line"></div><div class="line">           String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);</div><div class="line">           String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY);</div><div class="line"></div><div class="line">           DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + <span class="string">"-"</span> + clientVersion).build());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2>3.3 RateLimitingFilter</h2><p><code>com.netflix.eureka.RateLimitingFilter</code>，请求限流过滤器。在<a href="#">《TODO[0020]：限流》</a>详细解析。</p><h2>3.4 GzipEncodingEnforcingFilter</h2><p><code>com.netflix.eureka.GzipEncodingEnforcingFilter</code>，GZIP 编码过滤器。</p><h2>3.5 ServletContainer</h2><p><code>com.sun.jersey.spi.container.servlet.ServletContainer</code>，Jersey MVC 请求过滤器。</p><ul><li><p>Jersey MVC 模式如下图：</p><blockquote><p>FROM <a href="http://blog.csdn.net/wangqyoho/article/details/51981916" rel="external nofollow noopener noreferrer" target="_blank">《Jersey框架的MVC》</a><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/03.png" alt=""></p></blockquote></li><li><p>在 <code>com.netflix.eureka.resources</code> 包里，有所有的 Eureka-Server Jersey Resource ( Controller )。</p></li><li><p>过滤器在 <code>web.xml</code> 配置如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.sun.jersey.spi.container.servlet.ServletContainer<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.WebPageContentRegex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/(flex|images|js|css|jsp)/.*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.packages<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey;com.netflix<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- GZIP content encoding/decoding --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerRequestFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerResponseFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">   </div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p></li></ul><h1>666. 彩蛋</h1><p>啦啦啦，Eureka-Server 启动完成！</p><p>准备工作已经完成，可以开始更加有趣的注册、续约、取消注册、过期等等 Eureka-Client 与 Eureka-Server 的交互。</p><p>搞起！</p><p>胖友，分享一波朋友圈可好！？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-server-init-second/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 启动（一）之 ServerConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-server-init-first/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-server-init-first/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2017-10-12T05:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-server-init-first/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2. EurekaServerConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">2.3 DefaultEurekaServerConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 启动的过程</strong>。</p><p>考虑到整个初始化的过程中涉及的代码特别多，拆分成两两篇文章：</p><ul><li>【本文】ServerConfig</li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/?self">EurekaBootStrap</a></li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EurekaServerConfig</h1><p><code>com.netflix.eureka.EurekaServerConfig</code>，<strong>Eureka-Server</strong> 配置<strong>接口</strong>。</p><h2>2.1 类关系图</h2><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_07/01.png" alt=""></p><h2>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaServerConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><p><strong>请求认证相关</strong></p><ul><li>Eureka-Server 未实现认证。在 Spring-Cloud-Eureka-Server，通过 <code>spring-boot-starter-security</code> 模块支持。<a href="http://blog.csdn.net/liuchuanhong1/article/details/54729556" rel="external nofollow noopener noreferrer" target="_blank">《spring cloud-给Eureka Server加上安全的用户认证》</a>有详细解析。</li><li><code>#shouldLogIdentityHeaders()</code> ：打印访问的客户端名和版本号，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul></li><li><p><strong>请求限流相关</strong></p><ul><li>TODO[0020]：限流</li><li><code>#isRateLimiterEnabled()</code> ：请求限流是否开启。</li><li><code>#isRateLimiterThrottleStandardClients()</code> ：是否限制<strong>非标准</strong>客户端的访问。<strong>标准客户端</strong>通过请求头( <code>header</code> )的 <code>&quot;DiscoveryIdentity-Name&quot;</code> 来判断，是否在标准客户端名集合里。</li><li><code>#getRateLimiterPrivilegedClients()</code> ：<strong>标准</strong>客户端名集合。默认包含<code>&quot;DefaultClient&quot;</code> 和 <code>&quot;DefaultServer&quot;</code> 。</li><li><code>#getRateLimiterBurstSize()</code> ：速率限制的 burst size ，使用<strong>令牌桶算法</strong>。</li><li><code>#getRateLimiterRegistryFetchAverageRate()</code> ：<strong>增量</strong>拉取注册信息的速率限制。</li><li><code>#getRateLimiterFullFetchAverageRate()</code> ：<strong>全量</strong>拉取注册信息的速率限制。</li></ul></li><li><p><strong>获取注册信息请求相关</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a> 有详细解析。</li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 有详细解析。</li><li><code>#shouldUseReadOnlyResponseCache()</code> ：是否开启只读请求响应缓存。响应缓存 ( ResponseCache ) 机制目前使用两层缓存策略。优先读取<strong>只读缓存</strong>，读取不到后读取<strong>固定过期</strong>的<strong>读写缓存</strong>。</li><li><code>#getResponseCacheUpdateIntervalMs()</code> ：<strong>只读缓存</strong>更新频率，单位：毫秒。<strong>只读缓存</strong>定时更新任务只更新读取过请求 (<code>com.netflix.eureka.registry.Key</code>)，因此虽然永不过期，也会存在读取不到的情况。</li><li><code>#getResponseCacheAutoExpirationInSeconds()</code> ：<strong>读写缓存</strong>写入后过期时间，单位：秒。</li><li><code>#getRetentionTimeInMSInDeltaQueue()</code>：租约变更记录过期时长，单位：毫秒。默认值 ： 3 * 60 * 1000 毫秒。</li><li><code>#DeltaRetentionTimerIntervalInMs()</code>：移除队列里过期的租约变更记录的定时任务执行频率，单位：毫秒。默认值 ：30 * 1000 毫秒。</li></ul></li><li><p><strong>自我保护机制相关</strong></p><ul><li><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</p></li><li><p><code>#shouldEnableSelfPreservation()</code> ：是否开启自我保护模式。</p><blockquote><p>FROM <a href="http://www.itmuch.com/spring-cloud-sum/understanding-eureka-self-preservation/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立——《理解Eureka的自我保护模式》</a><br>当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。<br>一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。<br>当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p></blockquote></li><li><p><code>#getRenewalPercentThreshold()</code> ：开启自我保护模式比例，超过该比例后开启自我保护模式。</p></li><li><p><code>#getRenewalThresholdUpdateIntervalMs()</code> ：自我保护模式比例更新定时任务执行频率，单位：毫秒。</p></li></ul></li><li><p><strong>注册的应用实例的租约过期相关</strong></p><ul><li><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-evict/?self">《Eureka 源码解析 —— 应用实例注册发现（五）之过期》</a> 有详细解析。</p></li><li><p><code>#getEvictionIntervalTimerInMs()</code> ：租约过期定时任务执行频率，单位：毫秒。</p></li></ul></li><li><p><strong>Eureka-Server 远程节点( 非集群 )读取相关</strong></p><ul><li>TODO[0009]：RemoteRegionRegistry</li><li><code>#getRemoteRegionUrlsWithName()</code> ：TODO[0009]：RemoteRegionRegistry。<ul><li><code>key</code> ：Eureka-Server 区域( <code>region</code> )</li><li><code>value</code> ：Eureka-Server 地址</li></ul></li><li><code>#getRemoteRegionAppWhitelist()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#getRemoteRegionRegistryFetchInterval()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#getRegistrySyncRetries()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取失败重试次数。</li><li><code>#getRegistrySyncRetryWaitMs()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取失败等待( <code>sleep</code> )间隔，单位：毫秒。</li><li><code>#getRemoteRegionFetchThreadPoolSize()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#disableTransparentFallbackToOtherRegion()</code> ：是否禁用本地读取不到注册信息，从远程 Eureka-Server 读取。</li></ul></li><li><p><strong>Eureka-Server 集群同步相关</strong></p><ul><li>TODO[0021]：集群同步</li><li><code>#getMaxThreadsForPeerReplication()</code> ：同步应用实例信息最大线程数。</li><li><code>#getMaxElementsInPeerReplicationPool()</code> ：待执行同步应用实例信息事件缓冲最大数量。</li><li><code>#getMaxTimeForReplication()</code> ：执行单个同步应用实例信息状态任务最大时间。</li><li><code>#shouldSyncWhenTimestampDiffers()</code> ：是否同步应用实例信息，当应用实例信息最后更新时间戳( <code>lastDirtyTimestamp</code> )发生改变。</li><li><code>#getWaitTimeInMsWhenSyncEmpty()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取不到注册信息时，多长时间不允许 Eureka-Client 访问。TODO[0019]：集群初始化</li><li><code>#getPeerEurekaNodesUpdateIntervalMs()</code> ：Eureka-Server 集群节点更新频率，单位：毫秒。TTODO[0019]：集群初始化</li></ul></li></ul><h2>2.3 DefaultEurekaServerConfig</h2><p><code>com.netflix.eureka.DefaultEurekaServerConfig</code>，基于<strong>配置文件</strong>的 <strong>Eureka-Server</strong> 配置<strong>实现类</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerConfig</span> <span class="keyword">implements</span> <span class="title">EurekaServerConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略部分方法和属性</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance = com.netflix.config.DynamicPropertyFactory.getInstance();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory</div><div class="line">            .getInstance().getStringProperty(<span class="string">"eureka.server.props"</span>, <span class="string">"eureka-server"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String namespace = <span class="string">"eureka."</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, TEST);</div><div class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</div><div class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// ConfigurationManager</span></div><div class="line">            <span class="comment">// .loadPropertiesFromResources(eurekaPropsFile);</span></div><div class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(<span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></div><div class="line">                            + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>, eurekaPropsFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>#init()</code> 方法，初始化配置文件对象。类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。<strong>默认配置文件名</strong>为 <code>eureka-server</code>。</li><li>无配置文件的每个属性 KEY 的枚举类。</li></ul><h1>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-server-init-first/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（三）之 EurekaClient</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-third/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-third/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2017-10-12T05:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-client-init-third/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">2. EurekaClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">2.1 LookupService</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">3. DiscoveryClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">3.1 构造方法参数</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">3.2 构造方法</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/?self">《Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig》</a>，主要分享 <strong>Eureka-Client 自身初始化的过程</strong>的第三部分 —— <strong>EurekaClient</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li>（一）<a href="(http://www.iocoder.cn/Eureka/eureka-client-init-first/)">EurekaInstanceConfig</a></li><li>（二）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">EurekaClientConfig</a></li><li><strong>【本文】</strong>（三）EurekaClient</li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EurekaClient</h1><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.EurekaClient</code></a>，Eureka-Client <strong>接口</strong>，声明如下方法：</p><ul><li>提供<strong>多种</strong>方法获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。</li><li>提供方法获取<strong>本地</strong>客户端信息，例如，应用管理器( <code>com.netflix.appinfo.ApplicationInfoManager</code> )和 Eureka-Client 配置( <code>com.netflix.discovery.EurekaClientConfig</code> )。</li><li>提供方法<strong>注册</strong>本地客户端的健康检查和 Eureka 事件监听器。</li></ul><p>另外，Eureka 2.X 版本正在开发，该接口为 Eureka 1.X 和 2.X 提供平滑过渡接口。</p><blockquote><p>This interface does NOT try to clean up the current client interface for eureka 1.x. Rather it tries to provide an easier transition path from eureka 1.x to eureka 2.x.</p></blockquote><h2>2.1 LookupService</h2><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.shared.LookupService</code></a>，查找服务<strong>接口</strong>，提供<strong>简单单一</strong>的方式获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_29/01.png" alt=""></p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h1>3. DiscoveryClient</h1><p><code>com.netflix.discovery.DiscoveryClient</code>，实现 EurekaClient <strong>接口</strong>，用于与 Eureka-Server 交互。实现如下方法：</p><ul><li>向 Eureka-Server <strong>注册</strong>自身服务</li><li>向 Eureka-Server <strong>续约</strong>自身服务</li><li>向 Eureka-Server <strong>取消</strong>自身服务，当关闭时</li><li>从 Eureka-Server <strong>查询</strong>应用集合和应用实例信息</li><li><em>简单来理解，对 Eureka-Server 服务的增删改查</em></li></ul><h2>3.1 构造方法参数</h2><p>DiscoveryClient <strong>完整</strong>构造方法需要传入四个参数，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">     <span class="comment">// .... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>ApplicationInfoManager，在<a href="ttp://www.iocoder.cn/Eureka/eureka-client-init-first/">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》</a>有详细解析。</p></li><li><p>EurekaClientConfig，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">《Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig》</a>有详细解析。</p></li><li><p><code>com.netflix.discovery.BackupRegistry</code>，备份注册中心<strong>接口</strong>。当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息（可能挂了），从备份注册中心读取注册信息。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BackupRegistry.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackupRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NotImplementedRegistryImpl.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotImplementedRegistryImpl</span> <span class="keyword">implements</span> <span class="title">BackupRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>从 <code>com.netflix.discovery.NotImplementedRegistryImpl</code> 可以看出，目前 Eureka-Client 未提供合适的默认实现。</li></ul></li><li><p><code>com.netflix.discovery.AbstractDiscoveryClientOptionalArgs</code>，DiscoveryClient 可选参数抽象基类。不同于上面三个<strong>必填</strong>参数，该参数是<strong>选填</strong>参数，实际生产下使用较少。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成健康检查回调的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成健康检查处理器的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 向 Eureka-Server 注册之前的处理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    PreRegistrationHandler preRegistrationHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey 过滤器集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Collection&lt;T&gt; additionalFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey 客户端</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    EurekaJerseyClient eurekaJerseyClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成 Jersey 客户端的工厂的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TransportClientFactories transportClientFactories;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka 事件监听器集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Set&lt;EurekaEventListener&gt; eventListeners;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.appinfo.HealthCheckCallback</code>，健康检查回调<strong>接口</strong>，目前已经废弃，使用 HealthCheckHandler 替代，<strong>你可以不关注该参数</strong>。</p></li><li><p><code>com.netflix.appinfo.HealthCheckHandler</code>，健康检查处理器<strong>接口</strong>，目前暂未提供合适的<strong>默认</strong>实现，唯一提供的 <code>com.netflix.appinfo.HealthCheckCallbackToHandlerBridge</code>，用于将 HealthCheckCallback <strong>桥接</strong>成 HealthCheckHandler，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HealthCheckHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HealthCheckHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HealthCheckCallbackToHandlerBridge.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HealthCheckCallbackToHandlerBridge</span> <span class="keyword">implements</span> <span class="title">HealthCheckHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HealthCheckCallback callback;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthCheckCallbackToHandlerBridge</span><span class="params">()</span> </span>&#123;</div><div class="line">        callback = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthCheckCallbackToHandlerBridge</span><span class="params">(HealthCheckCallback callback)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.callback = callback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == callback || InstanceInfo.InstanceStatus.STARTING == currentStatus</div><div class="line">                || InstanceInfo.InstanceStatus.OUT_OF_SERVICE == currentStatus) &#123; <span class="comment">// Do not go to healthcheck handler if the status is starting or OOS.</span></div><div class="line">            <span class="keyword">return</span> currentStatus;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> callback.isHealthy() ? InstanceInfo.InstanceStatus.UP : InstanceInfo.InstanceStatus.DOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>在 Spring-Cloud-Eureka-Client，提供了默认实现 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/82991a7fc2859b6345b7f67e2461dbf5d7663836/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaHealthCheckHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.cloud.netflix.eureka.EurekaHealthCheckHandler</code></a>，需要结合 <a href="https://github.com/spring-projects/spring-boot/tree/c79568886406662736dcdce78f65e7f46dd62696/spring-boot-actuator/" rel="external nofollow noopener noreferrer" target="_blank"><code>spirng-boot-actuate</code></a> 使用，感兴趣的同学可以看看。本文暂不拓展开，后面另开文章分享。（TODO[0004]：健康检查）</li></ul></li><li><p><code>com.netflix.discovery.PreRegistrationHandler</code>，向 Eureka-Server 注册之前的处理器<strong>接口</strong>，目前暂未提供默认实现。通过实现该接口，可以在注册前做一些自定义的处理。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PreRegistrationHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeRegistration</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p><code>additionalFilters</code>，Jersey 过滤器集合。这里声明泛型 <code>&lt;T&gt;</code> 的原因，Jersey 1.X 和 Jersey 2.X 的过滤器接口<strong>不同</strong>，通过泛型来支持。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Jersey1DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jersey1DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">ClientFilter</span>&gt; </span>&#123;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="comment">// Jersey2DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jersey2DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">ClientRequestFilter</span>&gt; </span>&#123;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="comment">// DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">Jersey1DiscoveryClientOptionalArgs</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>Jersey 1.X 使用 ClientFilter 。ClientFilter 目前有两个过滤器实现：EurekaIdentityHeaderFilter 、DynamicGZIPContentEncodingFilter 。</li><li>Jersey 2.X 使用 ClientRequestFilter 。</li><li>DiscoveryClient 使用 DiscoveryClientOptionalArgs，即 Jersey 1.X 。</li></ul></li><li><p><code>eurekaJerseyClient</code>，Jersey 客户端。该<strong>参数</strong>目前废弃，使用下面 TransportClientFactories 参数来进行生成。</p></li><li><p><code>com.netflix.discovery.shared.transport.jersey.TransportClientFactories</code>，生成 Jersey 客户端<strong>工厂的工厂</strong>接口。目前有 Jersey1TransportClientFactories 、Jersey2TransportClientFactories 两个实现。TransportClientFactories 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransportClientFactories.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactories</span>&lt;<span class="title">F</span>&gt; </span>&#123;</div><div class="line">  </div><div class="line">      <span class="meta">@Deprecated</span></div><div class="line">      <span class="function">TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> Collection&lt;F&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> EurekaJerseyClient providedJerseyClient)</span></span>;</div><div class="line">  </div><div class="line">      <span class="function">TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> Collection&lt;F&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TransportClientFactory.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="function">EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span></span>;</div><div class="line">    </div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>第一个方法已经废弃，这就是为什么说上面的 <code>eurekaJerseyClient</code> <strong>参数</strong>( 不是 EurekaJerseyClient 类)已经废弃，被第二个方法取代。相比来说，第二个方法对 EurekaJerseyClient 创建封装会更好。</li></ul></li></ul></li><li><p><code>com.netflix.discovery.EurekaEventListener</code>，Eureka 事件监听器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaEventListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEventListener</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// EurekaEvent.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEvent</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryEvent.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryEvent</span> <span class="keyword">implements</span> <span class="title">EurekaEvent</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.discovery.StatusChangeEvent</code>，应用实例状态变更事件，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a> 有详细解析。</li><li><code>com.netflix.discovery.CacheRefreshedEvent</code>，在<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》「2.4 发起获取注册信息」</a> 有详细解析。</li></ul></li></ul><h2>3.2 构造方法</h2><p>DiscoveryClient 的构造方法实现代码相对较多，已经将代码<strong>切块</strong> + <strong>中文注册</strong>，点击 <a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L298" rel="external nofollow noopener noreferrer" target="_blank">DiscoveryClient</a> 链接，对照下面每个小结阅读理解。</p><h3>3.2.1 赋值 AbstractDiscoveryClientOptionalArgs</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.healthCheckHandlerProvider = args.healthCheckHandlerProvider;</div><div class="line">  <span class="keyword">this</span>.healthCheckCallbackProvider = args.healthCheckCallbackProvider;</div><div class="line">  <span class="keyword">this</span>.eventListeners.addAll(args.getEventListeners());</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler = args.preRegistrationHandler;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.healthCheckCallbackProvider = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">this</span>.healthCheckHandlerProvider = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.2.2 赋值 ApplicationInfoManager、EurekaClientConfig</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"></div><div class="line">clientConfig = config;</div><div class="line">staticClientConfig = clientConfig;</div><div class="line">transportConfig = config.getTransportConfig();</div><div class="line">instanceInfo = myInfo;</div><div class="line"><span class="keyword">if</span> (myInfo != <span class="keyword">null</span>) &#123;</div><div class="line">  appPathIdentifier = instanceInfo.getAppName() + <span class="string">"/"</span> + instanceInfo.getId(); <span class="comment">// 无实际业务用途，用于打 logger</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  logger.warn(<span class="string">"Setting instanceInfo to a passed in null value"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.2.3 赋值 BackupRegistry</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.backupRegistryProvider = backupRegistryProvider;</div></pre></td></tr></table></figure></p><h3>3.2.4 初始化 InstanceInfoBasedUrlRandomizer</h3><p>TODO[0016]：InstanceInfoBasedUrlRandomizer</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.urlRandomizer = <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);</div></pre></td></tr></table></figure></p><h3>3.2.5 初始化 Applications 在本地的缓存</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Applications 在本地的缓存</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拉取注册信息次数</span></div><div class="line"><span class="comment">* monotonically increasing generation counter to ensure stale threads do not reset registry to an older version</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong fetchRegistryGeneration;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">localRegionApps.set(<span class="keyword">new</span> Applications());</div><div class="line"></div><div class="line">fetchRegistryGeneration = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><ul><li>在创建 DiscoveryClient 时，<code>localRegionApps</code> 为空。</li><li>定时任务<strong>间隔</strong>从 Eureka-Server 拉取注册应用信息到本地缓存，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a> 有详细解析。</li></ul><h3>3.2.6 获取哪些 Region 集合的注册信息</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取哪些区域( Region )集合的注册信息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; remoteRegionsToFetch;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取哪些区域( Region )集合的注册信息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String[]&gt; remoteRegionsRef;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">remoteRegionsToFetch = <span class="keyword">new</span> AtomicReference&lt;&gt;(clientConfig.fetchRegistryForRemoteRegions());</div><div class="line">remoteRegionsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == <span class="keyword">null</span> ? <span class="keyword">null</span> : remoteRegionsToFetch.get().split(<span class="string">","</span>));</div></pre></td></tr></table></figure></p><h3>3.2.7 初始化拉取、心跳的监控</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功从 Eureka-Server 拉取注册信息时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulRegistryFetchTimestamp = -<span class="number">1</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功向 Eureka-Server 心跳时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulHeartbeatTimestamp = -<span class="number">1</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 心跳监控</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThresholdLevelsMetric heartbeatStalenessMonitor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拉取监控</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThresholdLevelsMetric registryStalenessMonitor;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (config.shouldFetchRegistry()) &#123;</div><div class="line">  <span class="keyword">this</span>.registryStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="string">"lastUpdateSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (config.shouldRegisterWithEureka()) &#123;</div><div class="line">  <span class="keyword">this</span>.heartbeatStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="string">"lastHeartbeatSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>每次成功向 Eureka-Serve 心跳或者从从 Eureka-Server 拉取注册信息后，都会更新相应时间戳。</li><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>对 <a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/util/ThresholdLevelsMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.util.ThresholdLevelsMetric</code></a> 感兴趣的同学可以点击链接查看。本文暂不拓展开，后面另开文章分享。（TODO[0012]：监控相关）</li></ul><h3>3.2.8 结束初始化，当无需和 Eureka-Server 交互</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;</div><div class="line">  logger.info(<span class="string">"Client configured to neither register nor query for data."</span>);</div><div class="line">  scheduler = <span class="keyword">null</span>;</div><div class="line">  heartbeatExecutor = <span class="keyword">null</span>;</div><div class="line">  cacheRefreshExecutor = <span class="keyword">null</span>;</div><div class="line">  eurekaTransport = <span class="keyword">null</span>;</div><div class="line">  instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(<span class="keyword">new</span> PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());</div><div class="line"></div><div class="line">  <span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></div><div class="line">  <span class="comment">// to work with DI'd DiscoveryClient</span></div><div class="line">  DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</div><div class="line">  DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line"></div><div class="line">  initTimestampMs = System.currentTimeMillis();</div><div class="line">  logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</div><div class="line">          initTimestampMs, <span class="keyword">this</span>.getApplications().size());</div><div class="line"></div><div class="line">  <span class="keyword">return</span>;  <span class="comment">// no need to setup up an network tasks and we are done</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.2.9 初始化线程池</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 线程池</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* A scheduler to be used for the following 3 tasks: 【目前只有两个】</span></div><div class="line"><span class="comment">* - updating service urls</span></div><div class="line"><span class="comment">* - scheduling a TimedSuperVisorTask</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line"><span class="comment">// additional executors for supervised subtasks</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 心跳执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor heartbeatExecutor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #localRegionApps&#125; 刷新执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor cacheRefreshExecutor;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></div><div class="line">scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build());</div><div class="line"></div><div class="line">heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">     <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build()</div><div class="line">);  <span class="comment">// use direct handoff</span></div><div class="line"></div><div class="line">cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">     <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build()</div><div class="line">);  <span class="comment">// use direct handoff</span></div></pre></td></tr></table></figure></p><ul><li><code>scheduler</code>，<strong>定时任务</strong>线程池，初始化大小为 2，一个给 <code>heartbeatExecutor</code>，一个给 <code>cacheRefreshExecutor</code>。</li><li><code>heartbeatExecutor</code>、<code>cacheRefreshExecutor</code> 在提交给 <code>scheduler</code> 才声明具体的<strong>任务</strong>。</li></ul><h3>3.2.10 初始化 Eureka 网络通信相关</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</div><div class="line">scheduleServerEndpointTask(eurekaTransport, args);</div></pre></td></tr></table></figure></p><ul><li>本文暂不拓展开，后面另开文章分享。（TODO[0013]：网络传输相关）</li></ul><h3>3.2.11 初始化 InstanceRegionChecker</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">AzToRegionMapper azToRegionMapper;</div><div class="line"><span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</div><div class="line">    azToRegionMapper = <span class="keyword">new</span> DNSBasedAzToRegionMapper(clientConfig);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    azToRegionMapper = <span class="keyword">new</span> PropertyBasedAzToRegionMapper(clientConfig);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsToFetch.get()) &#123;</div><div class="line">    azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(<span class="string">","</span>));</div><div class="line">&#125;</div><div class="line">instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.discovery.AzToRegionMapper</code>，主要用于亚马逊 AWS，跳过。</p></li><li><p><code>com.netflix.discovery.InstanceRegionChecker</code>，应用实例信息区域( <code>region</code> )校验，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceRegionChecker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略和亚马逊 AWS 相关的属性和方法</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 本地区域( Region )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String localRegion;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocalRegion</span><span class="params">(@Nullable String instanceRegion)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == instanceRegion || instanceRegion.equals(localRegion); <span class="comment">// no region == local</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocalRegion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> localRegion;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h3>3.2.12 从 Eureka-Server 拉取注册信息</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">  fetchRegistryFromBackup();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server <strong>初始</strong>拉取注册信息。在（TO后文链接）详细解析。</p></li><li><p>调用 <code>#fetchRegistryFromBackup()</code> 方法，若<strong>初始</strong>拉取注册信息失败，从备份注册中心获取。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchRegistryFromBackup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        BackupRegistry backupRegistryInstance = newBackupRegistryInstance();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == backupRegistryInstance) &#123; <span class="comment">// backward compatibility with the old protected method, in case it is being used.</span></div><div class="line">            backupRegistryInstance = backupRegistryProvider.get();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != backupRegistryInstance) &#123;</div><div class="line">            Applications apps = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (isFetchingRemoteRegionRegistries()) &#123;</div><div class="line">                String remoteRegionsStr = remoteRegionsToFetch.get();</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsStr) &#123;</div><div class="line">                    apps = backupRegistryInstance.fetchRegistry(remoteRegionsStr.split(<span class="string">","</span>));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                apps = backupRegistryInstance.fetchRegistry();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (apps != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> Applications applications = <span class="keyword">this</span>.filterAndShuffle(apps);</div><div class="line">                applications.setAppsHashCode(applications.getReconcileHashCode());</div><div class="line">                localRegionApps.set(applications);</div><div class="line">                logTotalInstances();</div><div class="line">                logger.info(<span class="string">"Fetched registry successfully from the backup"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.warn(<span class="string">"No backup registry instance defined &amp; unable to find any discovery servers."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        logger.warn(<span class="string">"Cannot fetch applications from apps although backup registry was specified"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>BackupRegistry 目前暂未提供默认实现，需要自行相关逻辑。</li></ul></li></ul><h3>3.2.13 执行向 Eureka-Server 注册之前的处理器</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// call and execute the pre registration handler before all background tasks (inc registration) is started</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.preRegistrationHandler != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler.beforeRegistration();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>3.2.14 初始化定时任务</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">initScheduledTasks();</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Eureka-Server 拉取注册信息执行器</span></div><div class="line">   <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line">       <span class="comment">// registry cache refresh timer</span></div><div class="line">       <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"cacheRefresh"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       cacheRefreshExecutor,</div><div class="line">                       registryFetchIntervalSeconds,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> CacheRefreshThread()</div><div class="line">               ),</div><div class="line">               registryFetchIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">   <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">       <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</div><div class="line">       logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</div><div class="line"></div><div class="line">       <span class="comment">// Heartbeat timer</span></div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"heartbeat"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       heartbeatExecutor,</div><div class="line">                       renewalIntervalInSecs,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> HeartbeatThread()</div><div class="line">               ),</div><div class="line">               renewalIntervalInSecs, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">       <span class="comment">// InstanceInfo replicator</span></div><div class="line">       instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</div><div class="line">               <span class="keyword">this</span>,</div><div class="line">               instanceInfo,</div><div class="line">               clientConfig.getInstanceInfoReplicationIntervalSeconds(),</div><div class="line">               <span class="number">2</span>); <span class="comment">// burstSize</span></div><div class="line"></div><div class="line">       statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</div><div class="line">                       InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</div><div class="line">                   <span class="comment">// log at warn level if DOWN was involved</span></div><div class="line">                   logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">               &#125;</div><div class="line">               instanceInfoReplicator.onDemandUpdate();</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</div><div class="line">           applicationInfoManager.registerStatusChangeListener(statusChangeListener);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>初始化</strong>从 Eureka-Server 拉取注册信息执行器，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现 （六）之全量获取》</a> 详细解析。</li><li><strong>初始化</strong>向 Eureka-Server 心跳（续租）执行器，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 详细解析。</li></ul><h3>3.2.15 向 Servo 注册监控</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Monitors.registerObject(<span class="keyword">this</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">  logger.warn(<span class="string">"Cannot register timers"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul><h3>3.2.16 初始化完成</h3><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 初始化完成时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> initTimestampMs;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// 【3.2.16】初始化完成</span></div><div class="line"><span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></div><div class="line"><span class="comment">// to work with DI'd DiscoveryClient</span></div><div class="line">DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</div><div class="line">DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line"></div><div class="line">initTimestampMs = System.currentTimeMillis();</div><div class="line">logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</div><div class="line">      initTimestampMs, <span class="keyword">this</span>.getApplications().size());</div></pre></td></tr></table></figure></p><h1>666. 彩蛋</h1><p>由于笔者是边理解源码边输出博客内容，如果有错误或者不清晰的地方，<strong>欢迎</strong>微笑给我的微信公众号( <strong>芋道源码</strong> ) 留言，我会<strong>仔细</strong>回复。感谢 + 1024。</p><p>后面文章不断更新，会慢慢完善本文中的。</p><p>推荐参考阅读：</p><ul><li><a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD —— 《Spring Cloud微服务实战》</a> Spring Cloud Eureka —— 源码分析</li><li><strong>买盗版书，等于编写一个初级 BUG</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-client-init-third/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-second/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-second/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2017-10-12T05:37:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-client-init-second/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2. EurekaClientConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.3 DefaultEurekaClientConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.4 DefaultEurekaClientConfigProvider</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">2.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3. EurekaTransportConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">3.3 DefaultEurekaTransportConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">666. 彩蛋</a></li></ul><hr><p><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg"></a></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》</a>，主要分享 <strong>Eureka-Client 自身初始化的过程</strong>的第二部分 —— <strong>EurekaClientConfig</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li>（一）<a href="(http://www.iocoder.cn/Eureka/eureka-client-init-first/)">EurekaInstanceConfig</a></li><li><strong>【本文】</strong>（二）EurekaClientConfig</li><li>（三）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">EurekaClient</a></li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EurekaClientConfig</h1><p><code>com.netflix.discovery.EurekaClientConfig</code>，<strong>Eureka-Client</strong> 配置<strong>接口</strong>。</p><h2>2.1 类关系图</h2><p>EurekaClientConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_22/04.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2ClientConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li></ul><h2>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaClientConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><strong>Region、Zone 相关</strong><ul><li><p><code>#getRegion()</code> ：Eureka-Client 所在区域( <code>region</code> )。</p></li><li><p><code>#getAvailabilityZones()</code> ：Eureka-Client 所在地区( <code>region</code> ) 可用区( <code>zone</code> )集合。<strong>该参数虽然是数组，第一个元素代表其所在的可用区</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getZone</span><span class="params">(String[] availZones, InstanceInfo myInfo)</span> </span>&#123;</div><div class="line">    String instanceZone = ((availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) ? <span class="string">"default"</span></div><div class="line">            : availZones[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">if</span> (myInfo != <span class="keyword">null</span></div><div class="line">            &amp;&amp; myInfo.getDataCenterInfo().getName() == DataCenterInfo.Name.Amazon) &#123;</div><div class="line">    </div><div class="line">        String awsInstanceZone = ((AmazonInfo) myInfo.getDataCenterInfo())</div><div class="line">                .get(AmazonInfo.MetaDataKey.availabilityZone);</div><div class="line">        <span class="keyword">if</span> (awsInstanceZone != <span class="keyword">null</span>) &#123;</div><div class="line">            instanceZone = awsInstanceZone;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instanceZone;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>进步一步理解 Region、Zone 查看<a href="http://www.itmuch.com/spring-cloud-1/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《周立 —— Region、Zone解析》</a>。</p></li></ul></li><li><strong>使用 DNS 获取 Eureka-Server URL 相关</strong><ul><li><code>#shouldUseDnsForFetchingServiceUrls()</code> ：是否使用 DNS 方式获取 Eureka-Server URL 地址。</li><li><code>#getEurekaServerDNSName()</code> ：Eureka-Server 的 DNS 名。</li><li><code>#getEurekaServerPort()</code> ：Eureka-Server 的端口。</li><li><code>#getEurekaServerURLContext()</code> ：Eureka-Server 的 URL Context 。</li><li><code>#getEurekaServiceUrlPollIntervalSeconds()</code> ：轮询获取 Eureka-Server 地址变更频率，单位：秒。默认：300 秒。</li><li><code>#shouldPreferSameZoneEureka()</code> ：优先使用相同区( <code>zone</code> )的 Eureka-Server。</li></ul></li><li><strong>直接配合 Eureka-Server URL 相关</strong><ul><li><code>#getEurekaServerServiceUrls()</code> ： Eureka-Server 的 URL 集合。</li></ul></li><li><strong>发现：从 Eureka-Server 获取注册信息相关</strong><ul><li><code>#shouldFetchRegistry()</code> ：是否从 Eureka-Server 拉取注册信息。</li><li><code>#getRegistryFetchIntervalSeconds()</code> ：从 Eureka-Server 拉取注册信息频率，单位：秒。默认：30 秒。</li><li><code>#shouldFilterOnlyUpInstances()</code> ：是否过滤，只获取状态为开启( Up )的应用实例集合。</li><li><code>#fetchRegistryForRemoteRegions()</code> ：TODO[0009]：RemoteRegionRegistry</li><li><code>#getCacheRefreshExecutorThreadPoolSize()</code> ：注册信息缓存刷新线程池大小。</li><li><code>#getCacheRefreshExecutorExponentialBackOffBound()</code> ：注册信息缓存刷新执行超时后的延迟重试的时间。</li><li><code>#getRegistryRefreshSingleVipAddress()</code> ：TODO[0010]：getRegistryRefreshSingleVipAddress</li></ul></li><li><strong>注册：向 Eureka-Server 注册自身服务</strong><ul><li><code>#shouldRegisterWithEureka()</code> ：是否向 Eureka-Server 注册自身服务。</li><li><code>#shouldUnregisterOnShutdown()</code> ：是否向 Eureka-Server 取消注册自身服务，当进程关闭时。</li><li><code>#getInstanceInfoReplicationIntervalSeconds()</code> ：向 Eureka-Server 同步应用实例信息变化频率，单位：秒。</li><li><code>#getInitialInstanceInfoReplicationIntervalSeconds()</code> ：向 Eureka-Server 同步应用信息变化初始化延迟，单位：秒。</li><li><code>#getBackupRegistryImpl()</code> ：获取备份注册中心实现类。当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息（可能挂了），从备份注册中心读取注册信息。目前 Eureka-Client 未提供合适的实现。</li><li><code>#getHeartbeatExecutorThreadPoolSize()</code> ：心跳执行线程池大小。</li><li><code>#getHeartbeatExecutorExponentialBackOffBound()</code> ：心跳执行超时后的延迟重试的时间。</li></ul></li></ul><h2>2.3 DefaultEurekaClientConfig</h2><p><code>com.netflix.discovery.DefaultEurekaClientConfig</code>，基于<strong>配置文件</strong>的 <strong>Eureka-Client</strong> 配置<strong>实现类</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfig</span> <span class="keyword">implements</span> <span class="title">EurekaClientConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ZONE = <span class="string">"defaultZone"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * HTTP 传输配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaTransportConfig transportConfig;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaClientConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</div><div class="line">                ? namespace</div><div class="line">                : namespace + <span class="string">"."</span>;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</div><div class="line">        <span class="comment">// 创建 HTTP 传输配置</span></div><div class="line">        <span class="keyword">this</span>.transportConfig = <span class="keyword">new</span> DefaultEurekaTransportConfig(namespace, configInstance);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。</li><li>在 <code>com.netflix.discovery.PropertyBasedClientConfigConstants</code> 可以看到配置文件的每个属性 KEY 。</li><li><code>transportConfig</code> 属性，在 <a href="#">「3. EurekaTransportConfig」</a> 详细解析。</li></ul><h2>2.4 DefaultEurekaClientConfigProvider</h2><p><code>com.netflix.discovery.providers.DefaultEurekaClientConfigProvider</code>，创建 DefaultEurekaClientConfig 的工厂，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfigProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">EurekaClientConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</div><div class="line">    <span class="meta">@EurekaNamespace</span></div><div class="line">    <span class="keyword">private</span> String namespace;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DefaultEurekaClientConfig config;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> EurekaClientConfig <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</div><div class="line">            config = (namespace == <span class="keyword">null</span>)</div><div class="line">                    ? <span class="keyword">new</span> DefaultEurekaClientConfig()</div><div class="line">                    : <span class="keyword">new</span> DefaultEurekaClientConfig(namespace);</div><div class="line">                    </div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Remove this when DiscoveryManager is finally no longer used</span></div><div class="line">            DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> config;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>2.5 小结</h2><p>推荐参考阅读：</p><ul><li><a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD —— 《Spring Cloud微服务实战》</a> Spring Cloud Eureka —— 配置详解</li><li><a href="http://www.cnblogs.com/fangfuhai/p/7070325.html" rel="external nofollow noopener noreferrer" target="_blank">风中程序猿 —— 《微服务架构：Eureka参数配置项详解》</a></li></ul><h1>3. EurekaTransportConfig</h1><h2>3.1 类关系图</h2><p>EurekaTransportConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_22/05.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2TransportConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li></ul><h2>3.2 配置属性</h2><p>TODO[0011]：EurekaTransportConfig 后面看到那部分源码在补充，没理顺。</p><h2>3.3 DefaultEurekaTransportConfig</h2><p><code>com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig</code>，基于<strong>配置文件</strong>的<strong>网络传输</strong>配置<strong>实现类</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaTransportConfig</span> <span class="keyword">implements</span> <span class="title">EurekaTransportConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + <span class="string">"."</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaTransportConfig</span><span class="params">(String parentNamespace, DynamicPropertyFactory configInstance)</span> </span>&#123;</div><div class="line">        <span class="comment">// 命名空间</span></div><div class="line">        <span class="keyword">this</span>.namespace = parentNamespace == <span class="keyword">null</span></div><div class="line">                ? SUB_NAMESPACE</div><div class="line">                : (parentNamespace.endsWith(<span class="string">"."</span>)</div><div class="line">                    ? parentNamespace + SUB_NAMESPACE</div><div class="line">                    : parentNamespace + <span class="string">"."</span> + SUB_NAMESPACE);</div><div class="line">        <span class="comment">// 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = configInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。</li><li>在 <code>com.netflix.discovery.shared.transport.PropertyBasedTransportConfigConstants</code> 可以看到配置文件的每个属性 KEY 。</li></ul><h1>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-client-init-second/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-first/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-first/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2017-10-12T05:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-client-init-first/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2. EurekaInstanceConfig</a><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.1 类关系图</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.2 配置属性</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.3 AbstractInstanceConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.4 PropertiesInstanceConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.5 MyDataCenterInstanceConfig</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">2.6 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">3. InstanceInfo</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">4. ApplicationInfoManager</a></li><li><a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 自身初始化的过程</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li><strong>【本文】</strong>（一）EurekaInstanceConfig</li><li>（二）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">EurekaClientConfig</a></li><li>（三）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">EurekaClient</a></li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EurekaInstanceConfig</h1><p><code>com.netflix.appinfo.EurekaInstanceConfig</code>，Eureka <strong>应用实例</strong>配置<strong>接口</strong>。在下文你会看到 EurekaClientConfig <strong>接口</strong>，两者的区别如下：</p><ul><li>EurekaInstanceConfig，重在<strong>应用实例</strong>，例如，应用名、应用的端口等等。此处应用指的是，Application Consumer 和 Application Provider。</li><li>EurekaClientConfig，重在 <strong>Eureka-Client</strong>，例如， 连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。</li></ul><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/02.jpeg" alt=""></p><h2>2.1 类关系图</h2><p>EurekaInstanceConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/03.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2ClientConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li><li>CloudInstanceConfig、Ec2EurekaArchaius2InstanceConfig 基于亚马逊 AWS，大多数读者和我对 AWS 都不了解，因此暂不解析。</li></ul><h2>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaInstanceConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><p><code>#getLeaseRenewalIntervalInSeconds()</code> ：租约续约频率，单位：秒。应用不断通过按照该频率发送心跳给 Eureka-Server 以达到续约的作用。当 Eureka-Server 超过最大频率未收到续约（心跳），契约失效，进行应用移除。应用移除后，其他应用无法从 Eureka-Server 获取该应用。</p></li><li><p><code>#getLeaseExpirationDurationInSeconds()</code> ：契约过期时间，单位：秒。</p></li><li><p><code>#getDataCenterInfo()</code> ：数据中心信息。<code>com.netflix.appinfo.DataCenterInfo</code>，数据中心信息<strong>接口</strong>，目前较为简单，标记所属数据中心名。一般情况下，我们使用 <code>Name.MyOwn</code>。接口实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCenterInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据中心名枚举</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> Name &#123;</div><div class="line">        Netflix,</div><div class="line">        Amazon,</div><div class="line">        MyOwn</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 归属的数据中心名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Name <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>#getNamespace()</code> ：配置命名空间，默认使用 <code>eureka</code>。以 <code>eureka-client.properties</code> 举个例子：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">eureka.name=eureka</div><div class="line">eureka.port=<span class="number">8080</span></div><div class="line">eureka.vipAddress=eureka.mydomain.net</div></pre></td></tr></table></figure></p><ul><li>每个属性<strong>最前面</strong>的 <code>eureka</code> 即是配置命名空间，一般情况无需修改。</li></ul></li><li><p>TODO[0004]：健康检查</p></li><li><p>TODO[0006]：getDefaultAddressResolutionOrder</p></li><li><p><code>#isInstanceEnabledOnit()</code> ：应用初始化后是否开启。在<a href="#">「3. InstanceInfo」</a>详细解析。</p></li></ul><h2>2.3 AbstractInstanceConfig</h2><p><code>com.netflix.appinfo.AbstractInstanceConfig</code>，Eureka <strong>应用实例</strong>配置<strong>抽象基类</strong>，主要实现一些相对<strong>通用</strong>的配置，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 契约过期时间，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEASE_EXPIRATION_DURATION_SECONDS = <span class="number">90</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 租约续约频率，单位：秒。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEASE_RENEWAL_INTERVAL_SECONDS = <span class="number">30</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 https 端口关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SECURE_PORT_ENABLED = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 http 端口开启</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> NON_SECURE_PORT_ENABLED = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 http 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NON_SECURE_PORT = <span class="number">80</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 https 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECURE_PORT = <span class="number">443</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用初始化后开启</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> INSTANCE_ENABLED_ON_INIT = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主机信息</span></div><div class="line"><span class="comment">     * key：主机 IP 地址</span></div><div class="line"><span class="comment">     * value：主机名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pair&lt;String, String&gt; hostInfo = getHostInfo();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据中心信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> DataCenterInfo info = <span class="keyword">new</span> DataCenterInfo() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Name.MyOwn;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">getHostInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Pair&lt;String, String&gt; pair;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InetAddress localHost = InetAddress.getLocalHost();</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(localHost.getHostAddress(), localHost.getHostName());</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot get host info"</span>, e);</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(<span class="string">""</span>, <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pair;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略 setting / getting 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#getHostInfo()</code> 方法，获取本地服务器的主机名和主机 IP 地址。<strong>如果主机有多网卡或者虚拟机网卡</strong>，这块要小心，解决方式如下：<ul><li>手动配置本机的 <code>hostname</code> + <code>etc/hosts</code> 文件，从而映射主机名和 IP 地址。</li><li>使用 Spring-Cloud-Eureka-Client 的话，参考<a href="http://www.itmuch.com/spring-cloud-code-read/spring-cloud-code-read-eureka-registry-ip/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立 —— 《Eureka服务注册过程详解之IpAddress》</a>解决。</li></ul></li></ul><h2>2.4 PropertiesInstanceConfig</h2><p><code>com.netflix.appinfo.PropertiesInstanceConfig</code>，基于<strong>配置文件</strong>的 Eureka <strong>应用实例</strong>配置<strong>抽象基类</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用分组</span></div><div class="line"><span class="comment">     * 从 环境变量 获取</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String appGrpNameFromEnv;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(CommonConstants.DEFAULT_CONFIG_NAMESPACE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(namespace, <span class="keyword">new</span> DataCenterInfo() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Name.MyOwn;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace, DataCenterInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(info);</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</div><div class="line">                ? namespace</div><div class="line">                : namespace + <span class="string">"."</span>;</div><div class="line">        <span class="comment">// 从 环境变量 获取 应用分组</span></div><div class="line">        appGrpNameFromEnv = ConfigurationManager.getConfigInstance()</div><div class="line">                .getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppGroupName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> configInstance.getStringProperty(namespace + APP_GROUP_KEY, appGrpNameFromEnv).get().trim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>configInstance</code> 属性，配置文件对象，基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 1.x</a> 实现配置文件的读取。在 <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/PropertyBasedInstanceConfigConstants.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.PropertyBasedInstanceConfigConstants</code></a> 可以看到配置文件的每个属性 KEY 。</p></li><li><p><code>appGrpNameFromEnv</code> 属性，应用分组，从<strong>环境变量</strong>中获取。从 <code>#getAppGroupName()</code> 方法中，可以看到优先还是从配置文件读取。设置方法如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">System.setProperty(FALLBACK_APP_GROUP_KEY, <span class="string">"app_gropu_name"</span>);</div></pre></td></tr></table></figure></p><ul><li><code>FALLBACK_APP_GROUP_KEY</code>，私有静态变量，实际得使用 <code>NETFLIX_APP_GROUP</code>。</li><li><code>com.netflix.config.ConfigurationManager</code> 可以从<strong>环境变量</strong>获取到值。</li></ul></li><li><p>调用 <code>Archaius1Utils#initConfig(...)</code> 方法，初始化读取的配置文件对象，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1Utils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Archaius1Utils.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicPropertyFactory <span class="title">initConfig</span><span class="params">(String configName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 配置文件对象</span></div><div class="line">        DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance();</div><div class="line">        <span class="comment">// 配置文件名</span></div><div class="line">        DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty(<span class="string">"eureka.client.props"</span>, configName);</div><div class="line">        <span class="comment">// 配置文件环境</span></div><div class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, <span class="string">"test"</span>);</div><div class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</div><div class="line">        <span class="comment">// 将配置文件加载到环境变量</span></div><div class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></div><div class="line">                            + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>,</div><div class="line">                    eurekaPropsFile);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> configInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>从环境变量 <code>eureka.client.props</code>，获取配置文件名。如果未配置，使用参数 <code>configName</code>，即 <code>CommonConstants.CONFIG_FILE_NAME</code> ( <code>&quot;eureka-client&quot;</code> )。</li><li>从环境变量 <code>eureka.environment</code> ( EUREKA_ENVIRONMENT )，获取配置文件环境。</li><li>调用 <code>ConfigurationManager#loadCascadedPropertiesFromResources(...)</code> 方法，读取配置文件到环境变量，首先读取 <code>${eureka.client.props}</code> 对应的配置文件；然后读取 <code>${eureka.client.props}-${eureka.environment}</code> 对应的配置文件。若有相同属性，进行覆盖。</li></ul></li></ul><h2>2.5 MyDataCenterInstanceConfig</h2><p><code>com.netflix.appinfo.MyDataCenterInstanceConfig</code>，非 AWS 数据中心的 Eureka <strong>应用实例</strong>配置<strong>实现类</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataCenterInstanceConfig</span> <span class="keyword">extends</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(namespace);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace, DataCenterInfo dataCenterInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(namespace, dataCenterInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>2.6 小结</h2><p>一般情况下，使用 MyDataCenterInstanceConfig 配置 Eureka 应用实例。</p><p>在 Spring-Cloud-Eureka 里，<strong>直接</strong>基于 EurekaInstanceConfig 接口重新实现了配置类，实际逻辑差别不大，在<a href="#">TODO[0007] ：《Spring-Cloud-Eureka-Client》</a>详细解析。</p><h1>3. InstanceInfo</h1><p><code>com.netflix.appinfo.InstanceInfo</code>，<strong>应用实例</strong>信息。Eureka-Client 向 Eureka-Server <strong>注册</strong>该对象信息。注册成功后，可以被其他 Eureka-Client <strong>发现</strong>。</p><p><strong>本文仅分享 InstanceInfo 的初始化</strong>。InstanceInfo 里和注册发现相关的属性和方法，暂时跳过。</p><p><code>com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider</code>，基于 EurekaInstanceConfig 创建 InstanceInfo 的工厂，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="meta">@Singleton</span></div><div class="line">  <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">InstanceInfo</span>&gt; </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(EurekaConfigBasedInstanceInfoProvider.class);</div><div class="line">  <span class="number">4</span>: </div><div class="line">  <span class="number">5</span>:     <span class="keyword">private</span> <span class="keyword">final</span> EurekaInstanceConfig config;</div><div class="line">  <span class="number">6</span>: </div><div class="line">  <span class="number">7</span>:     <span class="keyword">private</span> InstanceInfo instanceInfo;</div><div class="line">  <span class="number">8</span>: </div><div class="line">  <span class="number">9</span>:     <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</div><div class="line"> <span class="number">10</span>:     <span class="keyword">private</span> VipAddressResolver vipAddressResolver = <span class="keyword">null</span>;</div><div class="line"> <span class="number">11</span>: </div><div class="line"> <span class="number">12</span>:     <span class="meta">@Inject</span></div><div class="line"> <span class="number">13</span>:     <span class="function"><span class="keyword">public</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span><span class="params">(EurekaInstanceConfig config)</span> </span>&#123;</div><div class="line"> <span class="number">14</span>:         <span class="keyword">this</span>.config = config;</div><div class="line"> <span class="number">15</span>:     &#125;</div><div class="line"> <span class="number">16</span>: </div><div class="line"> <span class="number">17</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">18</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InstanceInfo <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">19</span>:         <span class="keyword">if</span> (instanceInfo == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">20</span>:             <span class="comment">// Build the lease information to be passed to the server based on config</span></div><div class="line"> <span class="number">21</span>:             <span class="comment">// 创建 租约信息构建器，并设置属性</span></div><div class="line"> <span class="number">22</span>:             LeaseInfo.Builder leaseInfoBuilder = LeaseInfo.Builder.newBuilder()</div><div class="line"> <span class="number">23</span>:                     .setRenewalIntervalInSecs(config.getLeaseRenewalIntervalInSeconds())</div><div class="line"> <span class="number">24</span>:                     .setDurationInSecs(config.getLeaseExpirationDurationInSeconds());</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// 创建 VIP地址解析器</span></div><div class="line"> <span class="number">27</span>:             <span class="keyword">if</span> (vipAddressResolver == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">28</span>:                 vipAddressResolver = <span class="keyword">new</span> Archaius1VipAddressResolver();</div><div class="line"> <span class="number">29</span>:             &#125;</div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:             <span class="comment">// Builder the instance information to be registered with eureka server</span></div><div class="line"> <span class="number">32</span>:             <span class="comment">// 创建 应用实例信息构建器</span></div><div class="line"> <span class="number">33</span>:             InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver);</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:             <span class="comment">// 应用实例编号</span></div><div class="line"> <span class="number">36</span>:             <span class="comment">// set the appropriate id for the InstanceInfo, falling back to datacenter Id if applicable, else hostname</span></div><div class="line"> <span class="number">37</span>:             String instanceId = config.getInstanceId();</div><div class="line"> <span class="number">38</span>:             DataCenterInfo dataCenterInfo = config.getDataCenterInfo();</div><div class="line"> <span class="number">39</span>:             <span class="keyword">if</span> (instanceId == <span class="keyword">null</span> || instanceId.isEmpty()) &#123;</div><div class="line"> <span class="number">40</span>:                 <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</div><div class="line"> <span class="number">41</span>:                     instanceId = ((UniqueIdentifier) dataCenterInfo).getId();</div><div class="line"> <span class="number">42</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">43</span>:                     instanceId = config.getHostName(<span class="keyword">false</span>);</div><div class="line"> <span class="number">44</span>:                 &#125;</div><div class="line"> <span class="number">45</span>:             &#125;</div><div class="line"> <span class="number">46</span>: </div><div class="line"> <span class="number">47</span>:             <span class="comment">// 获得 主机名</span></div><div class="line"> <span class="number">48</span>:             String defaultAddress;</div><div class="line"> <span class="number">49</span>:             <span class="keyword">if</span> (config <span class="keyword">instanceof</span> RefreshableInstanceConfig) &#123;</div><div class="line"> <span class="number">50</span>:                 <span class="comment">// Refresh AWS data center info, and return up to date address</span></div><div class="line"> <span class="number">51</span>:                 defaultAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(<span class="keyword">false</span>);</div><div class="line"> <span class="number">52</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">53</span>:                 defaultAddress = config.getHostName(<span class="keyword">false</span>);</div><div class="line"> <span class="number">54</span>:             &#125;</div><div class="line"> <span class="number">55</span>:             <span class="comment">// fail safe</span></div><div class="line"> <span class="number">56</span>:             <span class="keyword">if</span> (defaultAddress == <span class="keyword">null</span> || defaultAddress.isEmpty()) &#123;</div><div class="line"> <span class="number">57</span>:                 defaultAddress = config.getIpAddress();</div><div class="line"> <span class="number">58</span>:             &#125;</div><div class="line"> <span class="number">59</span>: </div><div class="line"> <span class="number">60</span>:             <span class="comment">// 设置 应用实例信息构建器 的 属性</span></div><div class="line"> <span class="number">61</span>:             builder.setNamespace(config.getNamespace())</div><div class="line"> <span class="number">62</span>:                     .setInstanceId(instanceId)</div><div class="line"> <span class="number">63</span>:                     .setAppName(config.getAppname())</div><div class="line"> <span class="number">64</span>:                     .setAppGroupName(config.getAppGroupName())</div><div class="line"> <span class="number">65</span>:                     .setDataCenterInfo(config.getDataCenterInfo())</div><div class="line"> <span class="number">66</span>:                     .setIPAddr(config.getIpAddress())</div><div class="line"> <span class="number">67</span>:                     .setHostName(defaultAddress) <span class="comment">// 主机名</span></div><div class="line"> <span class="number">68</span>:                     .setPort(config.getNonSecurePort())</div><div class="line"> <span class="number">69</span>:                     .enablePort(PortType.UNSECURE, config.isNonSecurePortEnabled())</div><div class="line"> <span class="number">70</span>:                     .setSecurePort(config.getSecurePort())</div><div class="line"> <span class="number">71</span>:                     .enablePort(PortType.SECURE, config.getSecurePortEnabled())</div><div class="line"> <span class="number">72</span>:                     .setVIPAddress(config.getVirtualHostName()) <span class="comment">// VIP 地址</span></div><div class="line"> <span class="number">73</span>:                     .setSecureVIPAddress(config.getSecureVirtualHostName())</div><div class="line"> <span class="number">74</span>:                     .setHomePageUrl(config.getHomePageUrlPath(), config.getHomePageUrl())</div><div class="line"> <span class="number">75</span>:                     .setStatusPageUrl(config.getStatusPageUrlPath(), config.getStatusPageUrl())</div><div class="line"> <span class="number">76</span>:                     .setASGName(config.getASGName())</div><div class="line"> <span class="number">77</span>:                     .setHealthCheckUrls(config.getHealthCheckUrlPath(),</div><div class="line"> <span class="number">78</span>:                             config.getHealthCheckUrl(), config.getSecureHealthCheckUrl());</div><div class="line"> <span class="number">79</span>: </div><div class="line"> <span class="number">80</span>:             <span class="comment">// 应用初始化后是否开启</span></div><div class="line"> <span class="number">81</span>:             <span class="comment">// Start off with the STARTING state to avoid traffic</span></div><div class="line"> <span class="number">82</span>:             <span class="keyword">if</span> (!config.isInstanceEnabledOnit()) &#123;</div><div class="line"> <span class="number">83</span>:                 InstanceStatus initialStatus = InstanceStatus.STARTING;</div><div class="line"> <span class="number">84</span>:                 LOG.info(<span class="string">"Setting initial instance status as: "</span> + initialStatus);</div><div class="line"> <span class="number">85</span>:                 builder.setStatus(initialStatus);</div><div class="line"> <span class="number">86</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">87</span>:                 LOG.info(<span class="string">"Setting initial instance status as: &#123;&#125;. This may be too early for the instance to advertise "</span></div><div class="line"> <span class="number">88</span>:                          + <span class="string">"itself as available. You would instead want to control this via a healthcheck handler."</span>,</div><div class="line"> <span class="number">89</span>:                          InstanceStatus.UP);</div><div class="line"> <span class="number">90</span>:             &#125;</div><div class="line"> <span class="number">91</span>: </div><div class="line"> <span class="number">92</span>:             <span class="comment">// 设置 应用实例信息构建器 的 元数据( Metadata )集合</span></div><div class="line"> <span class="number">93</span>:             <span class="comment">// Add any user-specific metadata information</span></div><div class="line"> <span class="number">94</span>:             <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; mapEntry : config.getMetadataMap().entrySet()) &#123;</div><div class="line"> <span class="number">95</span>:                 String key = mapEntry.getKey();</div><div class="line"> <span class="number">96</span>:                 String value = mapEntry.getValue();</div><div class="line"> <span class="number">97</span>:                 builder.add(key, value);</div><div class="line"> <span class="number">98</span>:             &#125;</div><div class="line"> <span class="number">99</span>: </div><div class="line"><span class="number">100</span>:             <span class="comment">// 创建 应用实例信息</span></div><div class="line"><span class="number">101</span>:             instanceInfo = builder.build();</div><div class="line"><span class="number">102</span>: </div><div class="line"><span class="number">103</span>:             <span class="comment">// 设置 应用实例信息 的 租约信息</span></div><div class="line"><span class="number">104</span>:             instanceInfo.setLeaseInfo(leaseInfoBuilder.build());</div><div class="line"><span class="number">105</span>:         &#125;</div><div class="line"><span class="number">106</span>:         <span class="keyword">return</span> instanceInfo;</div><div class="line"><span class="number">107</span>:     &#125;</div><div class="line"><span class="number">108</span>: </div><div class="line"><span class="number">109</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>该类实现 <code>javax.inject.Provider</code> 接口，设置 InstanceInfo 的生成工厂。感兴趣的同学，可以点击<a href="http://blog.csdn.net/derekjiang/article/details/7231490" rel="external nofollow noopener noreferrer" target="_blank">《Google-Guice入门介绍》</a>搜索 <strong>Provider</strong> 关键字。目前处于<strong>试验</strong>阶段，未完成。</p></li><li><p><code>EurekaConfigBasedInstanceInfoProvider(config)</code> 构造方法，设置生成 InstanceInfo 的 EurekaInstanceConfig 配置。</p></li><li><p>调用 <code>#get()</code> 方法，根据 EurekaInstanceConfig 创建 InstanceInfo。InstanceInfo 的绝大数属性和 EurekaInstanceConfig 是一致的 。实现代码如下：</p><ul><li><p>第 21 至 24 行 ：创建租约信息构建器( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/LeaseInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.LeaseInfo.Builder</code></a> )，并设置 <code>renewalIntervalInSecs</code> / <code>durationInSecs</code> 属性。</p></li><li><p>第 26 至 29 行 ：创建 VIP地址解析器( <code>com.netflix.appinfo.providers.VipAddressResolver</code> )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// VipAddressResolver.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VipAddressResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1VipAddressResolver</span> <span class="keyword">implements</span> <span class="title">VipAddressResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile(<span class="string">"\\$\\&#123;(.*?)\\&#125;"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vipAddressMacro == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        String result = vipAddressMacro;</div><div class="line">        <span class="comment">// 替换表达式</span></div><div class="line">        Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</div><div class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line">            String key = matcher.group(<span class="number">1</span>);</div><div class="line">            String value = DynamicPropertyFactory.getInstance().getStringProperty(key, <span class="string">""</span>).get();</div><div class="line"></div><div class="line">            logger.debug(<span class="string">"att:"</span> + matcher.group());</div><div class="line">            logger.debug(<span class="string">", att key:"</span> + key);</div><div class="line">            logger.debug(<span class="string">", att value:"</span> + value);</div><div class="line">            logger.debug(<span class="string">""</span>);</div><div class="line"></div><div class="line">            result = result.replaceAll(<span class="string">"\\$\\&#123;"</span> + key + <span class="string">"\\&#125;"</span>, value);</div><div class="line">            matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>使用 <code>#resolveDeploymentContextBasedVipAddresses()</code> 方法，将 <strong>VIP地址</strong> 里的 <code>${(.*?)}</code> 查找配置文件里的键值进行替换。例如，<code>${eureka.env}.domain.com</code>，查找配置文件里的键 <code>${eureka.env}</code> 对应值进行替换。TODO[0005]：调试下来，发现 Archaius 已经替换，等到找到答案修改此处。</li></ul></li><li><p>第 32 至 33 行 ：创建应用实例信息构建器( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo.Builder</code></a> )。</p></li><li><p>第 35 至 45 行 ：获得应用实例编号( <code>instanceId</code> )。</p></li><li><p>第 47 至 58 行 ：获得主机名。</p></li><li><p>第 60 至 78 行 ：设置应用实例信息构建器的属性。</p></li><li><p>第 80 至 90 行 ：应用初始化后是否开启。</p><ul><li>第 82 至 85 行 ：应用<strong>不开启</strong>，应用实例处于 STARTING 状态。</li><li>第 86 至 90 行 ：应用<strong>开启</strong>，应用实例处于 UP 状态。</li><li><strong>使用应用初始化后不开启</strong>，可以通过调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法改变应用实例状态，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</li></ul></li><li><p>第 92 至 98 行 ：设置应用实例信息构建器的元数据( Metadata )集合。</p></li><li><p>第 100 至 101 行 ：创建应用实例信息( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo</code></a> )。</p></li><li><p>第 103 至 104 行 ：设置应用实例信息的租约信息( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo</code></a> )。</p></li></ul></li></ul><h1>4. ApplicationInfoManager</h1><p><code>com.netflix.appinfo.ApplicationInfoManager</code>，应用信息管理器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfoManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationInfoManager instance = <span class="keyword">new</span> ApplicationInfoManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, StatusChangeListener&gt; listeners;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例状态匹配</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusMapper instanceStatusMapper;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InstanceInfo instanceInfo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> EurekaInstanceConfig config;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它构造方法</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationInfoManager</span><span class="params">(EurekaInstanceConfig config, InstanceInfo instanceInfo, OptionalArgs optionalArgs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.config = config;</div><div class="line">        <span class="keyword">this</span>.instanceInfo = instanceInfo;</div><div class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ConcurrentHashMap&lt;String, StatusChangeListener&gt;();</div><div class="line">        <span class="keyword">if</span> (optionalArgs != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.instanceStatusMapper = optionalArgs.getInstanceStatusMapper();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.instanceStatusMapper = NO_OP_MAPPER;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Hack to allow for getInstance() to use the DI'd ApplicationInfoManager</span></div><div class="line">        instance = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>listeners</code> 属性，状态变更监听器集合。在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</p></li><li><p><code>instanceStatusMapper</code> 属性，应用实例状态匹配。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceStatusMapper</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InstanceStatusMapper NO_OP_MAPPER = <span class="keyword">new</span> InstanceStatusMapper() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> InstanceStatus <span class="title">map</span><span class="params">(InstanceStatus prev)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> prev;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><ul><li><code>#map</code> 方法，根据传入 <code>pre</code> 参数，转换成对应的应用实例状态。</li><li>默认情况下，使用 NO_OP_MAPPER 。一般情况下，不需要关注该类。</li></ul></li></ul><h1>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/eureka-client-init-first/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/Eureka/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/Eureka/build-debugging-environment/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2017-10-12T05:36:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/build-debugging-environment/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3. Eureka-Server 启动</a><ul><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3.1 MockRemoteEurekaServer</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3.2 Eureka-Server war 包</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">3.3 Eureka-Server 直接启动</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">4. Eureka-Client 启动</a></li><li><a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 依赖工具</h1><ul><li>Gradle</li><li>JDK</li><li>IntelliJ IDEA</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/Netflix/eureka.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/eureka.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Gradle</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master</code> 分支。</p><h1>3. Eureka-Server 启动</h1><p>Eureka-Server 启动调试方式，有三种方式，我们来尝试每一种。</p><h2>3.1 MockRemoteEurekaServer</h2><p><code>com.netflix.eureka.AbstractTester</code>，测试抽象类，有如下实现子类：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_08/01.png" alt=""></p><p>使用任意一个子类的单元测试执行即可执行 Eureka-Server 逻辑的调试，这里以 <code>com.netflix.eureka.resources.ApplicationsResourceTest</code> 作为例子。</p><p>Debug 运行 <code>ApplicationsResourceTest#testFullAppsGetJson()</code> 单元测试。在方法执行前，<code>ApplicationsResourceTest#setUp()</code> 会运行，初始化 Eureka-Server <strong>模拟环境</strong>，例如：<code>com.netflix.eureka.mock.MockRemoteEurekaServer</code> ( 模拟 Eureka-Server )。</p><p>因为是<strong>模拟环境</strong>，对 Eureka-Server 的操作不是 Eureka-Client 请求 Eureka-Server 的方式，而是直接调用单元测试对应的方法。例如：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationsResourceTest.java</span></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFullAppsGetJson</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   Response response = applicationsResource.getContainers(</div><div class="line">           Version.V2.name(),</div><div class="line">           MediaType.APPLICATION_JSON,</div><div class="line">           <span class="keyword">null</span>, <span class="comment">// encoding</span></div><div class="line">           EurekaAccept.full.name(),</div><div class="line">           <span class="keyword">null</span>,  <span class="comment">// uriInfo</span></div><div class="line">           <span class="keyword">null</span>  <span class="comment">// remote regions</span></div><div class="line">   );</div><div class="line"></div><div class="line">   String json = String.valueOf(response.getEntity());</div><div class="line">   DecoderWrapper decoder = CodecWrappers.getDecoder(CodecWrappers.LegacyJacksonJson.class);</div><div class="line"></div><div class="line">   Applications decoded = decoder.decode(json, Applications.class);</div><div class="line">   <span class="comment">// test per app as the full apps list include the mock server that is not part of the test apps</span></div><div class="line">   <span class="keyword">for</span> (Application application : testApplications.getRegisteredApplications()) &#123;</div><div class="line">       Application decodedApp = decoded.getRegisteredApplications(application.getName());</div><div class="line">       assertThat(EurekaEntityComparators.equal(application, decodedApp), is(<span class="keyword">true</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>直接调用 <code>ApplicationsResource#getContainers(...)</code> 方法。</li></ul><p><strong>总结</strong>：这种方式，简单粗暴，容易上手。当然，它的缺点是<strong>模拟</strong>。刚开始调试 Eureka-Server 可以尝试这种方式。</p><h2>3.2 Eureka-Server war 包</h2><p>第一步，编译 Eureka-Server war 包。该步骤可能消耗漫长的时间，如果执行失败，请不断重试。命令如下：</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> eureka</div><div class="line">./gradlew clean build</div></pre></td></tr></table></figure></p><p>第二步，Debug 运行<code>com.netflix.eureka.resources.EurekaClientServerRestIntegrationTest</code> 任意单元测试方法。</p><p><strong>总结</strong>：这种方式，编译的过程比较痛苦，不排除失败的可能性。每次增加对代码的注册后，都需要重新编译打包。因此不建议采用。那咋办呢？见第三种。良心如博主，赶紧关注博主的微信公众号：【<strong>芋道源码</strong>】。</p><h2>3.3 Eureka-Server 直接启动</h2><p>第一步，修改 <code>EurekaClientServerRestIntegrationTest#startServer()</code> 方法，解决第二种方式使用 war 包运行每次修改代码都需要重新编译的问题，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaClientServerRestIntegrationTest.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</div><div class="line"></div><div class="line">   <span class="comment">// TODO Thread.currentThread().getContextClassLoader() 获取不到路径，先暂时这样；</span></div><div class="line">   WebAppContext webAppCtx = <span class="keyword">new</span> WebAppContext(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/webapp"</span>).getAbsolutePath(), <span class="string">"/"</span>);</div><div class="line">   webAppCtx.setDescriptor(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/webapp/WEB-INF/web.xml"</span>).getAbsolutePath());</div><div class="line">   webAppCtx.setResourceBase(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/resources"</span>).getAbsolutePath());</div><div class="line">   webAppCtx.setClassLoader(Thread.currentThread().getContextClassLoader());</div><div class="line">   server.setHandler(webAppCtx);</div><div class="line">   server.start();</div><div class="line"></div><div class="line">   eurekaServiceUrl = <span class="string">"http://localhost:8080/v2"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>笔者不太熟悉 Gradle 的打包方式，使用 <code>Thread.currentThread().getContextClassLoader().getResource()</code> 方法，一直无法拿到路径，有知道的同学麻烦告知下。</li></ul><p>第二步，Debug 运行<code>com.netflix.eureka.resources.EurekaClientServerRestIntegrationTest</code> 任意单元测试方法。TODO[0003]：Thread.currentThread().getContextClassLoader() 获取不到路径，先暂时这样；</p><p><strong>总结</strong>：这种方式，完美。建议使用该方式调试。</p><h1>4. Eureka-Client 启动</h1><p>我们以 <code>com.netflix.eureka.ExampleEurekaClient</code> 为例子。</p><p>第一步，在 <code>EurekaClientServerRestIntegrationTest#setUp()</code> 方法末尾添加 <code>Thread.sleep(Long.MAX_VALUE)</code> 代码。</p><p>第二步，按照<a href="#">「 3.3 Eureka-Server 直接启动」</a>方法启动 Eureka-Server。</p><p>第三步，将 <code>EurekaClientServerRestIntegrationTest#injectEurekaConfiguration</code> 复制到 ExampleEurekaClient 类里。</p><p>第四步，在 <code>ExampleEurekaClient#main()</code> 方法的第一行，添加 <code>injectEurekaConfiguration()</code> 代码。</p><p>第五步，Debug 运行 <code>ExampleEurekaClient#main()</code> 方法。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_08/02.png" alt=""></p><p><code>eureka-examples</code> 模块还提供别的例子，可以逐个调试。</p><h1>666. 彩蛋</h1><p>本文写的，相对比较简洁，如果有任何疑问，可以给我公众号留言。</p><p>下一篇更新？恩，我还没想好，整理<a href="#">《Eureka 源码解析》</a>整个系列的目录ing。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/build-debugging-environment/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 项目结构简介</title>
    <link href="http://www.iocoder.cn/Eureka/project-structure/"/>
    <id>http://www.iocoder.cn/Eureka/project-structure/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2017-10-12T05:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/project-structure/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">1. 概述</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">1.1 简介</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">1.2 项目结构</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">2. eureka-client</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">2.1 eureka-client-archaius2</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">2.2 eureka-client-jersey2</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">3. eureka-core</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">3.1 eureka-core-jersey2</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">4. eureka-resources</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">5. eureka-server</a><ul><li><a href="http://www.iocoder.cn/Eureka/project-structure/">5.1 eureka-server-governator</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">6. eureka-examples</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">7. eureka-test-utils</a></li><li><a href="http://www.iocoder.cn/Eureka/project-structure/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka 的项目结构</strong>，附带部分简介和原理。</p><p>Eureka 项目地址：<a href="https://github.com/Netflix/eureka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/eureka</a></p><ul><li>请注意下，不是 <code>spring-cloud-netflix-eureka-client</code> / <code>spring-cloud-netflix-eureka-server</code> 。</li><li>笔者 Fork 的代码仓库 <a href="https://github.com/YunaiV/eureka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/eureka</a>，会随着这个系列的文章逐渐增加<strong>中文注释</strong>，可以先 Star 一下。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h2>1.1 简介</h2><p>Eureka 是 <a href="https://zh.wikipedia.org/wiki/Netflix" rel="external nofollow noopener noreferrer" target="_blank">Netflix</a> 开源的服务注册发现组件，分成 Client 和 Server 两部分。简化架构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/01.png" alt=""></p><ul><li>Eureka-Server ：通过 REST 协议暴露服务，提供应用服务的注册和发现的功能。</li><li>Application Provider ：应用服务提供者，内嵌 Eureka-Client ，通过它向 Eureka-Server 注册自身服务。</li><li>Application Consumer ：应用服务消费者，内嵌 Eureka-Client ，通过它从 Eureka-Server 获取服务列表。</li><li>请注意下，Application Provider 和 Application Consumer 强调扮演的角色，实际可以在同一 JVM 进程，即是服务的提供者，又是服务的消费者。</li></ul><h2>1.2 项目结构</h2><p>Eureka 项目结构如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/02.png" alt=""></p><p>❓❓❓不只 Eureka-Client 、 Eureka-Server ❓❓❓</p><p>淡定。我们一起来了解每个模块的功能和结构。</p><h1>2. <code>eureka-client</code></h1><p><code>eureka-client</code> 模块为 Eureka-Client 的功能实现：</p><ul><li><code>com.netflix.appinfo</code> 包：Eureka-Client 的应用配置。此处的应用指的就是上文提到的 Application Provider，Application Consumer。</li><li><code>com.netflix.discovery</code> 包：Eureka-Client 的注册与发现相关功能。<ul><li><p><code>com.netflix.discovery.DiscoveryClient</code> 类：注册发现客户端实现类。</p></li><li><p><code>com.netflix.discovery.guice</code> 包：Eureka <strong>计划</strong>使用 <a href="https://github.com/google/guice" rel="external nofollow noopener noreferrer" target="_blank">Google Guice</a> 实现依赖注入，参见本文「5.1 <code>eureka-server-governator</code>」。一方面 Guice 是轻量级的依赖注入框架，另一方面避免和业务代码的 Spring 版本冲突。</p><blockquote><p>Guice (pronounced 'juice') is a lightweight dependency injection framework for Java 6 and above, brought to you by Google.</p></blockquote></li><li><p><code>com.netflix.discovery.converters</code> 包：Eureka 内部传输数据编解码转换器，支持 XML / JSON 格式。</p></li><li><p><code>com.netflix.discovery.endpoint</code> 包：目前该包正在重构，和下文的 <code>com.netflix.discovery.shared.dns</code> 和 <code>com.netflix.discovery.shared.resolver</code> 用途相近。</p></li><li><p><code>com.netflix.disvoery.provider</code> 包：目前仅有 DiscoveryJerseyProvider 类。该类声明自定义的 Jersey 请求和响应的序列化和反序列化实现。</p></li><li><p><code>com.netflix.disvoery.providers</code> 包：目前仅有 DefaultEurekaClientConfigProvider 类。该类实现 <code>javax.inject.Provider</code> 接口，设置 EurekaClientConfig ( Eureka 客户端配置 ) 的生成工厂。感兴趣的同学，可以点击<a href="http://blog.csdn.net/derekjiang/article/details/7231490" rel="external nofollow noopener noreferrer" target="_blank">《Google-Guice入门介绍》</a>搜索 <strong>Provider</strong> 关键字。</p></li><li><p><code>com.netflix.discovery.shared</code> 包：Eureka-Client 和 Eureka-Server 注册发现相关的共享重用的代码。下文你会看到，Eureka-Server 通过 <code>eureka-core</code> 模块实现，<code>eureka-core</code> 依赖 <code>eureka-client</code>。<strong>粗一看，我们会感觉 What ？Eureka-Server 代码依赖 Eureka-Client 代码</strong>！？这个和 Eureka-Server 多节点注册信息 P2P 同步的实现有关。一个 Eureka-Server 收到 Eureka-Client 注册请求后，Eureka-Server 会自己模拟 Eureka-Client 发送注册请求到其它的 Eureka-Server，因此部分实现代码就使用到了这个包，在<a href="#">TODO[0002]：《Eureka 源码解析 —— Eureka-Server 集群（二）之同步注册表》</a>详细解析。</p><ul><li><code>com.netflix.discovery.shared.transport</code> 包：Eureka-Client 对 Eureka-Server RESTful 的 HTTP 客户端，基于 Jersey Client 实现。Jersey 在下文「2.1 <code>eureka-client-jersey2</code>」详细解析。</li><li><code>com.netflix.discovery.shared.dns</code> 包 ：DNS 解析器。</li><li><code>com.netflix.discovery.shared.resolver</code> 包：EurekaEndpoint 解析器。【TODO[0001]：<code>com.netflix.discovery.shared.resolver</code>】</li></ul></li><li><p><code>com.netflix.discovery.util</code> 包 ：工具类。</p></li></ul></li></ul><h2>2.1 <code>eureka-client-archaius2</code></h2><p><a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Archaius</a> 是 Netflix 开源的配置管理组件。</p><p>Archaius 目前有 1.x 和 2.x 版本，默认情况下，Eureka 使用 1.x 版本。从官方文档上来看，2.x 版本仍然在开发中。</p><blockquote><p>FROM <a href="https://github.com/YunaiV/eureka/blob/103e0875b08c9ff4abb85eaab672df2041b63558/eureka-client-archaius2/README.md" rel="external nofollow noopener noreferrer" target="_blank">eureka-client-archaius2 README</a><br>This is a version of eureka-client that has been ported to use Archaius 2.x as the backing configuration system. Please note that this client is still work in progress. This client is also only java8 compatible (as Archaius 2.x is only java8 compatible).</p></blockquote><h2>2.2 <code>eureka-client-jersey2</code></h2><p><a href="https://github.com/jersey/jersey" rel="external nofollow noopener noreferrer" target="_blank">Jersey</a> 是 JAX-RS（JSR311）开源参考实现，用于构建 RESTful Web Service。</p><ul><li>Eureka-Server 使用 <a href="https://github.com/jersey/jersey/tree/9fdb7e386dc56b33f569ab198caf818d7a18525d/core-server/" rel="external nofollow noopener noreferrer" target="_blank">Jersey Server</a> 创建 RESTful Server 。</li><li>Eureka-Client 使用 <a href="https://github.com/jersey/jersey/tree/9fdb7e386dc56b33f569ab198caf818d7a18525d/core-client/" rel="external nofollow noopener noreferrer" target="_blank">Jersey Client</a> 请求 Eureka-Server 。</li></ul><p>Jersey 目前有 1.x 和 2.x 版本，默认情况下，Eureka 使用 1.x 版本。从官方文档上来看，2.x 版本由社区实现，Netflix 自己暂未使用。</p><blockquote><p>FROM <a href="https://github.com/Netflix/eureka/tree/30a85dc31be1c9d399e4e6ec5150759fb8777edf/eureka-client-jersey2/" rel="external nofollow noopener noreferrer" target="_blank">eureka-client-jersey2 README</a><br>Please note that this jersey2 compatible Eureka client (eureka-client-jersey2) is created and maintained by the community. Netflix does not currently use this library internally.</p></blockquote><h1>3. <code>eureka-core</code></h1><p><code>eureka-core</code> 模块为 Eureka-Server 的功能实现：</p><ul><li><code>com.netflix.eureka.EurekaBootStrap</code> 类：Eureka-Server 启动类。</li><li><code>com.netflix.eureka.aws</code> 包：与亚马逊 AWS 服务相关的类。由于笔者和大多数读者都对 AWS 暂不了解，本系列<a href="#">《Eureka 源码解析》</a>会跳过和 AWS 相关的代码。</li><li><code>com.netflix.eureka.cluster</code> 包：Eureka-Server 集群数据复制相关的代码。</li><li><code>com.netflix.eureka.lease</code> 包：应用注册后的<strong>租约</strong>管理( 注册 / 取消 / 续期 / 过期 )。</li><li><code>com.netflix.eureka.resousrces</code> 包：资源，基于 Jersey Server 实现，相当于 Spring MVC 的控制层代码。</li><li><code>com.netflix.eureka.transport</code> 包：Eureka-Server 对 Eureka-Server 的 RESTful HTTP 客户端，基于 <code>com.netflix.discovery.shared.transport</code> 封装实现。</li><li><code>com.netflix.eureka.util</code> 包：工具类。</li></ul><h2>3.1 <code>eureka-core-jersey2</code></h2><p>参见本文「2.1 <code>eureka-client-jersey2</code>」。</p><h1>4. <code>eureka-resources</code></h1><p><code>eureka-resources</code> 模块，使用 JSP 实现 Eureka-Server 的运维后台界面。项目结构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/03.png" alt=""></p><h1>5. <code>eureka-server</code></h1><p><code>eureka-server</code> 模块，将 <code>eureka-client</code> + <code>eureka-core</code> + <code>eureka-resources</code> 三者打包成 Eureka-Server 的 <code>war</code> 包。项目结构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/04.png" alt=""></p><h2>5.1 <code>eureka-server-governator</code></h2><p><code>eureka-server-governator</code> 模块，使用 <a href="https://github.com/Netflix/governator" rel="external nofollow noopener noreferrer" target="_blank">Netflix Governator</a> 管理 Eureka-Server 的生命周期。</p><blockquote><p>FROM <a href="http://www.infoq.com/cn/news/2013/02/netflix-opensource" rel="external nofollow noopener noreferrer" target="_blank">http://www.infoq.com/cn/news/2013/02/netflix-opensource</a><br><strong>Governator</strong>，一款对 Google Guice 进行扩展的类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能。</p></blockquote><p>目前该模块正在实现阶段。</p><blockquote><p>FROM <a href="https://github.com/Netflix/eureka/tree/30a85dc31be1c9d399e4e6ec5150759fb8777edf/eureka-server-governator/" rel="external nofollow noopener noreferrer" target="_blank">eureka-server-governator README</a><br>This server build is still experimental.</p></blockquote><h1>6. <code>eureka-examples</code></h1><p><code>eureka-examples</code> 模块，提供 Eureka-Client 使用例子。</p><h1>7. <code>eureka-test-utils</code></h1><p><code>eureka-test-utils</code> 模块，提供 Eureka 单元测试工具类。</p><h1>666. 彩蛋</h1><p>第一篇 Eureka 的文章，如果有地方写的不正确，还望指出，谢谢。</p><p>下一篇 Eureka 调试环境搭建。</p><p>更多 Eureka 内容，推荐阅读如下文章：</p><ul><li>携程 —— <a href="http://techshow.ctrip.com/archives/1699.html" rel="external nofollow noopener noreferrer" target="_blank">《深度剖析服务发现组件Netflix Eureka》</a></li><li>程序员DD —— <a href="http://blog.didispace.com/springcloud-sourcecode-eureka/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud源码分析（一）Eureka》</a></li><li>王鸿飞 —— <a href="http://blog.spring-cloud.io/blog/sc-eureka.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix Eureka源码导读与原理分析》</a></li><li>许进 —— <a href="http://xujin.org/sc/sc-netflix-eureka/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix之Eureka上篇》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/project-structure/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 项目实战</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/http-sample/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/http-sample/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2017-10-12T06:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/http-sample/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">1. 概述</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">2. 实体结构</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">2.1 商城服务</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">2.2 资金服务</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">2.3 红包服务</a></li></ul></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">3. 服务调用</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">4. 下单支付流程</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">4.1 Try 阶段</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">4.2 Confirm / Cancel 阶段</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">4.2.1 Confirm</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">4.2.2 Cancel</a></li></ul></li></ul></li><li><a href="http://www.iocoder.cn/TCC-Transaction/http-sample/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文分享 <strong>TCC 项目实战</strong>。以官方 Maven项目 <code>tcc-transaction-http-sample</code> 为例子( <code>tcc-transaction-dubbo-sample</code> 类似 )。</p><p>建议你已经成功启动了该项目。如果不知道如何启动，可以先查看<a href="http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/?self">《TCC-Transaction 源码分析 —— 调试环境搭建》</a>。如果再碰到问题，欢迎加微信公众号( <strong>芋道源码</strong> )，我会一一仔细回复。</p><p>OK，首先我们简单了解下这个项目。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/01.png" alt=""></p><ul><li>首页 =&gt; 商品列表 =&gt; 确认支付页 =&gt; 支付结果页</li><li>使用账户余额 + 红包余额<strong>联合</strong>支付购买商品，并账户之间<strong>转账</strong>。</li></ul><p>项目拆分三个子 Maven 项目：</p><ul><li><code>tcc-transaction-http-order</code> ：商城服务，提供商品和商品订单逻辑。</li><li><code>tcc-transaction-http-capital</code> ：资金服务，提供账户余额逻辑。</li><li><code>tcc-transaction-http-redpacket</code> ：红包服务，提供红包余额逻辑。</li></ul><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/03.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1>2. 实体结构</h1><h2>2.1 商城服务</h2><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/02.png" alt=""></p><ul><li><p>Shop，商店表。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商店编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 所有者用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ownerUserId;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>Product，商品表。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商品编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> productId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商店编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> shopId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商品名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String productName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单价</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal price;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>Order，订单表。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5908730245224893590L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支付( 下单 )用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> payerUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 收款( 商店拥有者 )用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> payeeUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 红包支付金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal redPacketPayAmount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 账户余额支付金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal capitalPayAmount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单状态</span></div><div class="line"><span class="comment">     * - DRAFT ：草稿</span></div><div class="line"><span class="comment">     * - PAYING ：支付中</span></div><div class="line"><span class="comment">     * - CONFIRMED ：支付成功</span></div><div class="line"><span class="comment">     * - PAY_FAILED ：支付失败</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String status = <span class="string">"DRAFT"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商户订单号，使用 UUID 生成</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String merchantOrderNo;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单明细数组</span></div><div class="line"><span class="comment">     * 非存储字段</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;OrderLine&gt; orderLines = <span class="keyword">new</span> ArrayList&lt;OrderLine&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><ul><li><p>OrderLine，订单明细。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderLine</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2300754647209250837L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商品编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> productId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单价</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal unitPrice;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><p><strong>业务逻辑</strong>：</p><p>下单时，插入订单状态为 <code>&quot;DRAFT&quot;</code> 的订单( Order )记录，并插入购买的商品订单明细( OrderLine )记录。支付时，更新订单状态为 <code>&quot;PAYING&quot;</code>。</p><ul><li>订单支付成功，更新订单状态为 <code>&quot;CONFIRMED&quot;</code>。</li><li>订单支付失败，更新订单状体为 <code>&quot;PAY_FAILED&quot;</code>。</li></ul><h2>2.2 资金服务</h2><p>关系较为简单，有两个实体：</p><ul><li><p>CapitalAccount，资金账户余额。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapitalAccount</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 账户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 余额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal balanceAmount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>TradeOrder，交易订单表。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeOrder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转出用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> selfUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转入用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> oppositeUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商户订单号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String merchantOrderNo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal amount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单状态</span></div><div class="line"><span class="comment">     * - DRAFT ：草稿</span></div><div class="line"><span class="comment">     * - CONFIRM ：交易成功</span></div><div class="line"><span class="comment">     * - CANCEL ：交易取消</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String status = <span class="string">"DRAFT"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><p><strong>业务逻辑</strong>：</p><p>订单支付支付中，插入交易订单状态为 <code>&quot;DRAFT&quot;</code> 的订单( TradeOrder )记录，并更新<strong>减少</strong>下单用户的资金账户余额。</p><ul><li>订单支付成功，更新交易订单状态为 <code>&quot;CONFIRM&quot;</code>，并更新<strong>增加</strong>商店拥有用户的资金账户余额。</li><li>订单支付失败，更新交易订单状态为 <code>&quot;CANCEL&quot;</code>，并更新**增加( 恢复 )**下单用户的资金账户余额。</li></ul><h2>2.3 红包服务</h2><p>关系较为简单，<strong>和资金服务 99.99% 相同</strong>，有两个实体：</p><ul><li><p>RedPacketAccount，红包账户余额。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPacketAccount</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 账户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 余额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal balanceAmount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>TradeOrder，交易订单表。实体代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeOrder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转出用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> selfUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转入用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> oppositeUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商户订单号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String merchantOrderNo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal amount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单状态</span></div><div class="line"><span class="comment">     * - DRAFT ：草稿</span></div><div class="line"><span class="comment">     * - CONFIRM ：交易成功</span></div><div class="line"><span class="comment">     * - CANCEL ：交易取消</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String status = <span class="string">"DRAFT"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><p><strong>业务逻辑</strong>：</p><p>订单支付支付中，插入交易订单状态为 <code>&quot;DRAFT&quot;</code> 的订单( TradeOrder )记录，并更新<strong>减少</strong>下单用户的红包账户余额。</p><ul><li>订单支付成功，更新交易订单状态为 <code>&quot;CONFIRM&quot;</code>，并更新<strong>增加</strong>商店拥有用户的红包账户余额。</li><li>订单支付失败，更新交易订单状态为 <code>&quot;CANCEL&quot;</code>，并更新**增加( 恢复 )**下单用户的红包账户余额。</li></ul><h1>3. 服务调用</h1><p>服务之间，通过 <strong>HTTP</strong> 进行调用。</p><p><strong>红包服务和资金服务为商城服务提供调用( 以资金服务为例子 )</strong>：</p><ul><li><p>XML 配置如下 ：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-service-provider.xml</div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalAccountRepository"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.domain.repository.CapitalAccountRepository"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"tradeOrderRepository"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.domain.repository.TradeOrderRepository"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalTradeOrderService"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.service.CapitalTradeOrderServiceImpl"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalAccountService"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.service.CapitalAccountServiceImpl"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalTradeOrderServiceExporter"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"capitalTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalTradeOrderService"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalAccountServiceExporter"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"capitalAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalAccountService"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpServer"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.support.SimpleHttpServerFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contexts"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalTradeOrderService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalTradeOrderServiceExporter"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalAccountService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalAccountServiceExporter"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"8081"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p></li><li><p>Java 代码实现如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapitalAccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">CapitalAccountService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    CapitalAccountRepository capitalAccountRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getCapitalAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> capitalAccountRepository.findByUserId(userId).getBalanceAmount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapitalAccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">CapitalAccountService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    CapitalAccountRepository capitalAccountRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getCapitalAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> capitalAccountRepository.findByUserId(userId).getBalanceAmount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><p><strong>商城服务调用</strong></p><ul><li><p>XML 配置如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-service-consumer.xml</div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpInvokerRequestExecutor"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.CommonsHttpInvokerRequestExecutor"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpClient"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.httpclient.HttpClient"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpConnectionManager"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"multiThreadHttpConnectionManager"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multiThreadHttpConnectionManager"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.apache.commons.httpclient.MultiThreadedHttpConnectionManager"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"params"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.httpclient.params.HttpConnectionManagerParams"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionTimeout"</span> <span class="attr">value</span>=<span class="string">"200000"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotalConnections"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultMaxConnectionsPerHost"</span> <span class="attr">value</span>=<span class="string">"512"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"soTimeout"</span> <span class="attr">value</span>=<span class="string">"5000"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"captialTradeOrderService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8081/remoting/CapitalTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"capitalAccountService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8081/remoting/CapitalAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redPacketAccountService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8082/remoting/RedPacketAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.redpacket.api.RedPacketAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redPacketTradeOrderService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8082/remoting/RedPacketTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.redpacket.api.RedPacketTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p></li><li><p>Java 接口接口如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalAccountService</span> </span>&#123;</div><div class="line">    <span class="function">BigDecimal <span class="title">getCapitalAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketAccountService</span> </span>&#123;</div><div class="line">    <span class="function">BigDecimal <span class="title">getRedPacketAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, RedPacketTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h1>4. 下单支付流程</h1><p><strong>ps</strong>：数据访问的方法，请自己拉取代码，使用 IDE 查看。谢谢。🙂</p><p>下单支付流程，整体流程如下图( <a href="./../../images/TCC-Transaction/2018_03_15/04.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/04.png" alt=""></p><p>点击**【支付】**按钮，下单支付流程。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">""</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="meta">@RequestMapping</span>(value = <span class="string">"/placeorder"</span>, method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">placeOrder</span><span class="params">(@RequestParam String redPacketPayAmount,</span></span></div><div class="line"><span class="function"><span class="params">                                   @RequestParam <span class="keyword">long</span> shopId,</span></span></div><div class="line"><span class="function"><span class="params">                                   @RequestParam <span class="keyword">long</span> payerUserId,</span></span></div><div class="line"><span class="function"><span class="params">                                   @RequestParam <span class="keyword">long</span> productId)</span> </span>&#123;</div><div class="line">        PlaceOrderRequest request = buildRequest(redPacketPayAmount, shopId, payerUserId, productId);</div><div class="line">        <span class="comment">// 下单并支付订单</span></div><div class="line">        String merchantOrderNo = placeOrderService.placeOrder(request.getPayerUserId(), request.getShopId(),</div><div class="line">                request.getProductQuantities(), request.getRedPacketPayAmount());</div><div class="line">        <span class="comment">// 返回</span></div><div class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"pay_success"</span>);</div><div class="line">        <span class="comment">// 查询订单状态</span></div><div class="line">        String status = orderService.getOrderStatusByMerchantOrderNo(merchantOrderNo);</div><div class="line">        <span class="comment">// 支付结果提示</span></div><div class="line">        String payResultTip = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="string">"CONFIRMED"</span>.equals(status)) &#123;</div><div class="line">            payResultTip = <span class="string">"支付成功"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PAY_FAILED"</span>.equals(status)) &#123;</div><div class="line">            payResultTip = <span class="string">"支付失败"</span>;</div><div class="line">        &#125;</div><div class="line">        mv.addObject(<span class="string">"payResult"</span>, payResultTip);</div><div class="line">        <span class="comment">// 商品信息</span></div><div class="line">        mv.addObject(<span class="string">"product"</span>, productRepository.findById(productId));</div><div class="line">        <span class="comment">// 资金账户金额 和 红包账户金额</span></div><div class="line">        mv.addObject(<span class="string">"capitalAmount"</span>, accountService.getCapitalAccountByUserId(payerUserId));</div><div class="line">        mv.addObject(<span class="string">"redPacketAmount"</span>, accountService.getRedPacketAccountByUserId(payerUserId));</div><div class="line">        <span class="keyword">return</span> mv;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>PlaceOrderService#placeOrder(...)</code> 方法，下单并支付订单。</li><li>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-order/src/main/java/org/mengyun/tcctransaction/sample/http/order/domain/service/OrderServiceImpl.java" rel="external nofollow noopener noreferrer" target="_blank"><code>OrderService#getOrderStatusByMerchantOrderNo(...)</code></a> 方法，查询订单状态。</li></ul><hr><p>调用 <code>PlaceOrderService#placeOrder(...)</code> 方法，下单并支付订单。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderServiceImpl</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">placeOrder</span><span class="params">(<span class="keyword">long</span> payerUserId, <span class="keyword">long</span> shopId, List&lt;Pair&lt;Long, Integer&gt;&gt; productQuantities, BigDecimal redPacketPayAmount)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取商店</span></div><div class="line">        Shop shop = shopRepository.findById(shopId);</div><div class="line">        <span class="comment">// 创建订单</span></div><div class="line">        Order order = orderService.createOrder(payerUserId, shop.getOwnerUserId(), productQuantities);</div><div class="line">        <span class="comment">// 发起支付</span></div><div class="line">        Boolean result = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            paymentService.makePayment(order, redPacketPayAmount, order.getTotalAmount().subtract(redPacketPayAmount));</div><div class="line">        &#125; <span class="keyword">catch</span> (ConfirmingException confirmingException) &#123;</div><div class="line">            <span class="comment">// exception throws with the tcc transaction status is CONFIRMING,</span></div><div class="line">            <span class="comment">// when tcc transaction is confirming status,</span></div><div class="line">            <span class="comment">// the tcc transaction recovery will try to confirm the whole transaction to ensure eventually consistent.</span></div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (CancellingException cancellingException) &#123;</div><div class="line">            <span class="comment">// exception throws with the tcc transaction status is CANCELLING,</span></div><div class="line">            <span class="comment">// when tcc transaction is under CANCELLING status,</span></div><div class="line">            <span class="comment">// the tcc transaction recovery will try to cancel the whole transaction to ensure eventually consistent.</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="comment">// other exceptions throws at TRYING stage.</span></div><div class="line">            <span class="comment">// you can retry or cancel the operation.</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> order.getMerchantOrderNo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>ShopRepository#findById(...)</code> 方法，查询商店。</p></li><li><p>调用 <code>OrderService#createOrder(...)</code> 方法，创建订单状态为 <code>&quot;DRAFT&quot;</code> 的<strong>商城</strong>订单。实际业务不会这么做，此处仅仅是例子，简化流程。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Transactional</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">createOrder</span><span class="params">(<span class="keyword">long</span> payerUserId, <span class="keyword">long</span> payeeUserId, List&lt;Pair&lt;Long, Integer&gt;&gt; productQuantities)</span> </span>&#123;</div><div class="line">        Order order = orderFactory.buildOrder(payerUserId, payeeUserId, productQuantities);</div><div class="line">        orderRepository.createOrder(order);</div><div class="line">        <span class="keyword">return</span> order;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><ul><li>调用 <code>PaymentService#makePayment(...)</code> 方法，发起支付，<strong>TCC 流程</strong>。</li><li><strong>生产代码对于异常需要进一步处理</strong>。</li><li><strong>生产代码对于异常需要进一步处理</strong>。</li><li><strong>生产代码对于异常需要进一步处理</strong>。</li></ul><h2>4.1 Try 阶段</h2><p><strong>商城服务</strong></p><p>调用 <code>PaymentService#makePayment(...)</code> 方法，发起 Try 流程，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Compensable</span>(confirmMethod = <span class="string">"confirmMakePayment"</span>, cancelMethod = <span class="string">"cancelMakePayment"</span>)</div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePayment</span><span class="params">(Order order, BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   System.out.println(<span class="string">"order try make payment called.time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 更新订单状态为支付中</span></div><div class="line">   order.pay(redPacketPayAmount, capitalPayAmount);</div><div class="line">   orderRepository.updateOrder(order);</div><div class="line">   <span class="comment">// 资金账户余额支付订单</span></div><div class="line">   String result = tradeOrderServiceProxy.record(<span class="keyword">null</span>, buildCapitalTradeOrderDto(order));</div><div class="line">   <span class="comment">// 红包账户余额支付订单</span></div><div class="line">   String result2 = tradeOrderServiceProxy.record(<span class="keyword">null</span>, buildRedPacketTradeOrderDto(order));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>设置方法注解 @Compensable</p><ul><li>事务传播级别 Propagation.REQUIRED ( <strong>默认值</strong> )</li><li>设置 <code>confirmMethod</code> /  <code>cancelMethod</code> 方法名</li><li>事务上下文编辑类 DefaultTransactionContextEditor ( <strong>默认值</strong> )</li></ul></li><li><p>设置方法注解 @Transactional，保证方法操作原子性。</p></li><li><p>调用 <code>OrderRepository#updateOrder(...)</code> 方法，更新订单状态为<strong>支付中</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Order.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.redPacketPayAmount = redPacketPayAmount;</div><div class="line">   <span class="keyword">this</span>.capitalPayAmount = capitalPayAmount;</div><div class="line">   <span class="keyword">this</span>.status = <span class="string">"PAYING"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><ul><li><p>调用 <code>TradeOrderServiceProxy#record(...)</code> 方法，<strong>资金</strong>账户余额支付订单。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TradeOrderServiceProxy.java</span></div><div class="line"><span class="meta">@Compensable</span>(propagation = Propagation.SUPPORTS, confirmMethod = <span class="string">"record"</span>, cancelMethod = <span class="string">"record"</span>, transactionContextEditor = Compensable.DefaultTransactionContextEditor.class)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> capitalTradeOrderService.record(transactionContext, tradeOrderDto);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CapitalTradeOrderService.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>设置方法注解 @Compensable</p><ul><li><code>propagation=Propagation.SUPPORTS</code> ：支持当前事务，如果当前没有事务，就以非事务方式执行。<strong>为什么不使用 REQUIRED</strong> ？如果使用 REQUIRED 事务传播级别，事务恢复重试时，会发起新的事务。</li><li><code>confirmMethod</code>、<code>cancelMethod</code> 使用和 try 方法<strong>相同方法名</strong>：<strong>本地发起</strong>远程服务 TCC confirm / cancel 阶段，调用相同方法进行事务的提交或回滚。远程服务的 CompensableTransactionInterceptor 会根据事务的状态是 CONFIRMING / CANCELLING 来调用对应方法。</li></ul></li><li><p>调用 <code>CapitalTradeOrderService#record(...)</code> 方法，远程调用，发起<strong>资金</strong>账户余额支付订单。</p><ul><li>本地方法调用时，参数 <code>transactionContext</code> 传递 <code>null</code> 即可，TransactionContextEditor 会设置。在<a href="http://www.iocoder.cn/TCC-Transaction/tcc-core/?self">《TCC-Transaction 源码分析 —— TCC 实现》「6.3 资源协调者拦截器」</a>有详细解析。</li><li>远程方法调用时，参数 <code>transactionContext</code> 需要传递。Dubbo 远程方法调用实际也进行了传递，传递方式较为特殊，通过隐式船舱，在<a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self">《TCC-Transaction 源码分析 —— Dubbo 支持》「3. Dubbo 事务上下文编辑器」</a>有详细解析。</li></ul></li></ul></li><li><p>调用 <code>TradeOrderServiceProxy#record(...)</code> 方法，<strong>红包</strong>账户余额支付订单。和<strong>资金</strong>账户余额支付订单 99.99% 类似，不重复“复制粘贴”。</p></li></ul><hr><p><strong>资金服务</strong></p><p>调用 <code>CapitalTradeOrderServiceImpl#record(...)</code> 方法，<strong>红包</strong>账户余额支付订单。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="meta">@Compensable</span>(confirmMethod = <span class="string">"confirmRecord"</span>, cancelMethod = <span class="string">"cancelRecord"</span>, transactionContextEditor = Compensable.DefaultTransactionContextEditor.class)</div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line"><span class="comment">//            Thread.sleep(10000000L);</span></div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"capital try record called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 生成交易订单</span></div><div class="line">   TradeOrder tradeOrder = <span class="keyword">new</span> TradeOrder(</div><div class="line">           tradeOrderDto.getSelfUserId(),</div><div class="line">           tradeOrderDto.getOppositeUserId(),</div><div class="line">           tradeOrderDto.getMerchantOrderNo(),</div><div class="line">           tradeOrderDto.getAmount()</div><div class="line">   );</div><div class="line">   tradeOrderRepository.insert(tradeOrder);</div><div class="line">   <span class="comment">// 更新减少下单用户的资金账户余额</span></div><div class="line">   CapitalAccount transferFromAccount = capitalAccountRepository.findByUserId(tradeOrderDto.getSelfUserId());</div><div class="line">   transferFromAccount.transferFrom(tradeOrderDto.getAmount());</div><div class="line">   capitalAccountRepository.save(transferFromAccount);</div><div class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>设置方法注解 @Compensable</p><ul><li>事务传播级别 Propagation.REQUIRED ( <strong>默认值</strong> )</li><li>设置 <code>confirmMethod</code> /  <code>cancelMethod</code> 方法名</li><li>事务上下文编辑类 DefaultTransactionContextEditor ( <strong>默认值</strong> )</li></ul></li><li><p>设置方法注解 @Transactional，保证方法操作原子性。</p></li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/TradeOrderRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>TradeOrderRepository#insert(...)</code></a> 方法，生成订单状态为 <code>&quot;DRAFT&quot;</code> 的交易订单。</p></li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/CapitalAccountRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CapitalAccountRepository#save(...)</code></a> 方法，更新减少下单用户的资金账户余额。<strong>Try 阶段锁定资源时，一定要先扣。TCC 是最终事务一致性，如果先添加，可能被使用</strong>。</p></li></ul><h2>4.2 Confirm / Cancel 阶段</h2><p>当 Try 操作<strong>全部</strong>成功时，发起 Confirm 操作。<br>当 Try 操作存在<strong>任务</strong>失败时，发起 Cancel 操作。</p><h3>4.2.1 Confirm</h3><p><strong>商城服务</strong></p><p>调用 <code>PaymentServiceImpl#confirmMakePayment(...)</code> 方法，更新订单状态为支付<strong>成功</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmMakePayment</span><span class="params">(Order order, BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"order confirm make payment called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 更新订单状态为支付成功</span></div><div class="line">   order.confirm();</div><div class="line">   orderRepository.updateOrder(order);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><strong>生产代码该方法需要加下 @Transactional 注解，保证原子性</strong>。</p></li><li><p>调用 <code>OrderRepository#updateOrder(...)</code> 方法，更新订单状态为支付成功。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Order.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.status = <span class="string">"CONFIRMED"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><p><strong>资金服务</strong></p><p>调用 <code>CapitalTradeOrderServiceImpl#confirmRecord(...)</code> 方法，更新交易订单状态为交易<strong>成功</strong>。</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"capital confirm record called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 查询交易记录</span></div><div class="line">   TradeOrder tradeOrder = tradeOrderRepository.findByMerchantOrderNo(tradeOrderDto.getMerchantOrderNo());</div><div class="line">   <span class="comment">// 判断交易记录状态。因为 `#record()` 方法，可能事务回滚，记录不存在 / 状态不对</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != tradeOrder &amp;&amp; <span class="string">"DRAFT"</span>.equals(tradeOrder.getStatus())) &#123;</div><div class="line">       <span class="comment">// 更新订单状态为交易成功</span></div><div class="line">       tradeOrder.confirm();</div><div class="line">       tradeOrderRepository.update(tradeOrder);</div><div class="line">       <span class="comment">// 更新增加商店拥有者用户的资金账户余额</span></div><div class="line">       CapitalAccount transferToAccount = capitalAccountRepository.findByUserId(tradeOrderDto.getOppositeUserId());</div><div class="line">       transferToAccount.transferTo(tradeOrderDto.getAmount());</div><div class="line">       capitalAccountRepository.save(transferToAccount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>设置方法注解 @Transactional，保证方法操作原子性。</p></li><li><p><strong>判断交易记录状态</strong>。因为 <code>#record()</code> 方法，可能事务回滚，记录不存在 / 状态不对。</p></li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/TradeOrderRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>TradeOrderRepository#update(...)</code></a> 方法，更新交易订单状态为交易<strong>成功</strong>。</p></li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/CapitalAccountRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CapitalAccountRepository#save(...)</code></a> 方法，更新增加商店拥有者用户的资金账户余额。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CapitalAccount.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(BigDecimal amount)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.balanceAmount = <span class="keyword">this</span>.balanceAmount.add(amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><p><strong>红包服务</strong></p><p>和<strong>资源服务</strong> 99.99% 相同，不重复“复制粘贴”。</p><h3>4.2.2 Cancel</h3><p><strong>商城服务</strong></p><p>调用 <code>PaymentServiceImpl#cancelMakePayment(...)</code> 方法，更新订单状态为支付<strong>失败</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelMakePayment</span><span class="params">(Order order, BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"order cancel make payment called.time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 更新订单状态为支付失败</span></div><div class="line">   order.cancelPayment();</div><div class="line">   orderRepository.updateOrder(order);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><strong>生产代码该方法需要加下 @Transactional 注解，保证原子性</strong>。</p></li><li><p>调用 <code>OrderRepository#updateOrder(...)</code> 方法，更新订单状态为支付失败。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Order.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelPayment</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">"PAY_FAILED"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><p><strong>资金服务</strong></p><p>调用 <code>CapitalTradeOrderServiceImpl#cancelRecord(...)</code> 方法，更新交易订单状态为交易<strong>失败</strong>。</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"capital cancel record called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 查询交易记录</span></div><div class="line">   TradeOrder tradeOrder = tradeOrderRepository.findByMerchantOrderNo(tradeOrderDto.getMerchantOrderNo());</div><div class="line">   <span class="comment">// 判断交易记录状态。因为 `#record()` 方法，可能事务回滚，记录不存在 / 状态不对</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != tradeOrder &amp;&amp; <span class="string">"DRAFT"</span>.equals(tradeOrder.getStatus())) &#123;</div><div class="line">       <span class="comment">// / 更新订单状态为交易失败</span></div><div class="line">       tradeOrder.cancel();</div><div class="line">       tradeOrderRepository.update(tradeOrder);</div><div class="line">       <span class="comment">// 更新增加( 恢复 )下单用户的资金账户余额</span></div><div class="line">       CapitalAccount capitalAccount = capitalAccountRepository.findByUserId(tradeOrderDto.getSelfUserId());</div><div class="line">       capitalAccount.cancelTransfer(tradeOrderDto.getAmount());</div><div class="line">       capitalAccountRepository.save(capitalAccount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>设置方法注解 @Transactional，保证方法操作原子性。</p></li><li><p><strong>判断交易记录状态</strong>。因为 <code>#record()</code> 方法，可能事务回滚，记录不存在 / 状态不对。</p></li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/TradeOrderRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>TradeOrderRepository#update(...)</code></a> 方法，更新交易订单状态为交易<strong>失败</strong>。</p></li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/CapitalAccountRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CapitalAccountRepository#save(...)</code></a> 方法，更新增加( 恢复 )下单用户的资金账户余额。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CapitalAccount.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelTransfer</span><span class="params">(BigDecimal amount)</span> </span>&#123;</div><div class="line">    transferTo(amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><p><strong>红包服务</strong></p><p>和<strong>资源服务</strong> 99.99% 相同，不重复“复制粘贴”。</p><h1>666. 彩蛋</h1><p>嘿嘿，代码只是看起来比较多，实际不多。</p><p>蚂蚁金融云提供了银行间转账的 TCC 过程例子，有兴趣的同学可以看看：<a href="https://www.cloud.alipay.com/docs/2/46886" rel="external nofollow noopener noreferrer" target="_blank">《蚂蚁金融云 —— 分布式事务服务（DTS） —— 场景介绍》</a>。</p><p>本系列 EOF ~撒花</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/05.png" alt=""></p><p>胖友，分享个朋友圈，可好？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/http-sample/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 运维平台</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/console/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/console/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2017-10-12T06:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/console/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">1. 概述</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">2. 数据访问层</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">2.1 JDBC 事务 DAO</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">2.2 Redis 事务 DAO</a></li></ul></li><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">3. 控制层</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">3.1 查看未完成的事务列表</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">3.2 重置事务恢复重试次数</a></li></ul></li><li><a href="http://www.iocoder.cn/TCC-Transaction/console/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文分享 <strong>运维平台</strong>。TCC-Transaction 提供了相对精简的运维平台，用于查看在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码分析 —— 事务存储器》</a>提到的<strong>事务存储</strong>。目前暂时只有两个功能：</p><ul><li>查看未完成的事务列表</li><li>重置事务恢复重试次数</li></ul><p>运维平台( Maven 项目 <code>tcc-transaction-server</code> ) 整体代码结构如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/01.png" alt=""></p><p>本文自下而上，Dao =&gt; Controller =&gt; UI 的顺序进行解析实现。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><h1>2. 数据访问层</h1><p><code>org.mengyun.tcctransaction.server.dao.TransactionDao</code>，事务Dao <strong>接口</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务 VO 数组</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> domain 领域</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum 第几页</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 分页大小</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务 VO 数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;TransactionVo&gt; <span class="title">findTransactions</span><span class="params">(String domain, Integer pageNum, <span class="keyword">int</span> pageSize)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务总数量</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> domain 领域</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Integer <span class="title">countOfFindTransactions</span><span class="params">(String domain)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重置事务重试次数</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> domain 领域</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> globalTxId 全局事务编号</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> branchQualifier 分支事务编号</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否重置成功</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">resetRetryCount</span><span class="params">(String domain, <span class="keyword">byte</span>[] globalTxId, <span class="keyword">byte</span>[] branchQualifier)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>TCC-Transaction 提供了四种事务存储器，但是目前只支持两种数据访问层的实现：</p><ul><li>JDBC 事务 DAO</li><li>Redis 事务 DAO</li></ul><h2>2.1 JDBC 事务 DAO</h2><p><code>org.mengyun.tcctransaction.server.dao.JdbcTransactionDao</code>，JDBC 事务 DAO 实现。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Repository</span>(<span class="string">"jdbcTransactionDao"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTransactionDao</span> <span class="keyword">implements</span> <span class="title">TransactionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME_PREFIX = <span class="string">"TCC_TRANSACTION"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> DataSource dataSource;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 读取 jdbc-domain-suffix.properties</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;jdbcDomainSuffix&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> Properties domainSuffix;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>dataSource</code>，数据源。配置方式如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-server-dao.xml </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></div><div class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></div><div class="line"><span class="tag">     <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"logAbandoned"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"removeAbandoned"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"removeAbandonedTimeout"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"numTestsPerEvictionRun"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT NOW() FROM DUAL"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">// tcc-transaction-server.properties</div><div class="line">jdbc.url=jdbc:mysql://127.0.0.1:33061/TCC?useUnicode=true&amp;characterEncoding=UTF-8</div><div class="line">jdbc.username=root</div><div class="line">jdbc.password=123456</div></pre></td></tr></table></figure></p><ul><li>在 <code>appcontext-server-dao.xml</code>，配置数据源 Bean 对象。</li><li>在 <code>tcc-transaction-server.properties</code>，配置数据源属性。</li></ul></li><li><p><code>domainSuffix</code>，<code>domian</code> 和 表后缀( <code>suffix</code> ) 的映射关系。配置方式如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// jdbc-domain-suffix.properties</div><div class="line">CAPITAL=_CAP</div><div class="line">ORDER=_ORD</div><div class="line">REDPACKET=_RED</div></pre></td></tr></table></figure></p><ul><li>键 ：domain。</li><li>值 ：suffix。</li></ul></li></ul><p>JdbcTransactionDao 代码实现上比较易懂，点击<a href="https://github.com/YunaiV/tcc-transaction/blob/e54c3e43a2e47a7765bdb18a485860cb31acbb72/tcc-transaction-server/src/main/java/org/mengyun/tcctransaction/server/dao/JdbcTransactionDao.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看，已经添加中文注释。</p><h2>2.2 Redis 事务 DAO</h2><p><code>org.mengyun.tcctransaction.server.dao.RedisTransactionDao</code>，Redis 事务 DAO。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Repository</span>(<span class="string">"redisTransactionDao"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTransactionDao</span> <span class="keyword">implements</span> <span class="title">TransactionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * redis pool</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JedisPool jedisPool;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 序列化</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ObjectSerializer serializer = <span class="keyword">new</span> JdkSerializationSerializer();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 读取 redis-domain-key-prefix.properties</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;redisDomainKeyPrefix&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> Properties domainKeyPrefix;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>jedisPool</code>，Redis 连接池。配置方式如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-server-dao.xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.host&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.port&#125;"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"6000"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"4"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">null</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"5"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.db&#125;"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">// tcc-transaction-server.properties</div><div class="line">redis.host=127.0.0.1</div><div class="line">redis.port=6379</div><div class="line">redis.password=</div><div class="line">redis.db=0</div></pre></td></tr></table></figure></p><ul><li>在 <code>appcontext-server-dao.xml</code>，配置 Redis 连接池 Bean 对象。</li><li>在 <code>tcc-transaction-server.properties</code>，配置 Redis 连接池属性。</li></ul></li><li><p><code>domainKeyPrefix</code>，domain 和 Redis Key 前缀( <code>prefix</code> )的映射。配置方式如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">CAPITAL=TCC:CAP:</div><div class="line">ORDER=TCC:ORD:</div><div class="line">REDPACKET=TCC:RED:</div></pre></td></tr></table></figure></p><ul><li>键 ：domain。</li><li>值 ：suffix。</li></ul></li></ul><p>RedisTransactionDao 代码实现上比较易懂，点击[链接]https://github.com/YunaiV/tcc-transaction/blob/e54c3e43a2e47a7765bdb18a485860cb31acbb72/tcc-transaction-server/src/main/java/org/mengyun/tcctransaction/server/dao/RedisTransactionDao.java)查看，已经添加中文注释。</p><h1>3. 控制层</h1><p><code>org.mengyun.tcctransaction.server.controller.TransactionController</code>，事务 Controller。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PAGE_NUM = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PAGE_SIZE = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据访问对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Qualifier</span>(<span class="string">"jdbcTransactionDao"</span>)</div><div class="line">    <span class="keyword">private</span> TransactionDao transactionDao;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 项目访问根目录</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;tcc_domain&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String tccDomain;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>transactionDao</code>，数据访问对象。配置方式如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-server-dao.xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionDao"</span> <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.server.dao.JdbcTransactionDao"</span>/&gt;</span></div></pre></td></tr></table></figure></p><ul><li>目前运维平台只能读取一个数据源，如果你的数据源是多个，需要对运维平台做一定的改造，或启动多个项目。</li></ul></li><li><p><code>tccDomain</code>，项目访问根目录。配置方式如下：</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// tcc-transaction-server.properties</div><div class="line">tcc_domain=</div></pre></td></tr></table></figure></p><ul><li>一般情况下不用配置，如果你放在 Tomcat 根目录。</li></ul></li></ul><h2>3.1 查看未完成的事务列表</h2><p>调用 <code>TransactionController#manager(...)</code> 方法，查看事务列表。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/management"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">manager</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"manager"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/management/domain/&#123;domain&#125;"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">manager</span><span class="params">(@PathVariable String domain)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> manager(domain, DEFAULT_PAGE_NUM);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/management/domain/&#123;domain&#125;/pagenum/&#123;pageNum&#125;"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">manager</span><span class="params">(@PathVariable String domain, @PathVariable Integer pageNum)</span> </span>&#123;</div><div class="line">   ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"manager"</span>);</div><div class="line">   <span class="comment">// 获得事务 VO 数组</span></div><div class="line">   List&lt;TransactionVo&gt; transactionVos = transactionDao.findTransactions(domain, pageNum, DEFAULT_PAGE_SIZE);</div><div class="line">   <span class="comment">// 获得事务总数量</span></div><div class="line">   Integer totalCount = transactionDao.countOfFindTransactions(domain);</div><div class="line">   <span class="comment">// 计算总页数</span></div><div class="line">   Integer pages = totalCount / DEFAULT_PAGE_SIZE;</div><div class="line">   <span class="keyword">if</span> (totalCount % DEFAULT_PAGE_SIZE &gt; <span class="number">0</span>) &#123;</div><div class="line">       pages++;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回</span></div><div class="line">   modelAndView.addObject(<span class="string">"transactionVos"</span>, transactionVos);</div><div class="line">   modelAndView.addObject(<span class="string">"pageNum"</span>, pageNum);</div><div class="line">   modelAndView.addObject(<span class="string">"pageSize"</span>, DEFAULT_PAGE_SIZE);</div><div class="line">   modelAndView.addObject(<span class="string">"pages"</span>, pages);</div><div class="line">   modelAndView.addObject(<span class="string">"domain"</span>, domain);</div><div class="line">   modelAndView.addObject(<span class="string">"urlWithoutPaging"</span>, tccDomain + <span class="string">"/management/domain/"</span> + domain);</div><div class="line">   <span class="keyword">return</span> modelAndView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>UI 界面如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/02.png" alt=""></p><h2>3.2 重置事务恢复重试次数</h2><p>调用 <code>TransactionController#reset(...)</code> 方法，事务重置重试次数。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/domain/&#123;domain&#125;/retry/reset"</span>, method = RequestMethod.PUT)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> CommonResponse&lt;Void&gt; <span class="title">reset</span><span class="params">(@PathVariable String domain, String globalTxId, String branchQualifier)</span> </span>&#123;</div><div class="line">   transactionDao.resetRetryCount(domain,</div><div class="line">           DatatypeConverter.parseHexBinary(globalTxId),</div><div class="line">           DatatypeConverter.parseHexBinary(branchQualifier));</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> CommonResponse&lt;Void&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>UI 界面如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/03.png" alt=""></p><h1>666. 彩蛋</h1><p>可能有人会吐槽运维平台怎么做的这么简陋。这个不是 TCC-Transaction 一个开源项目存在的问题，其他例如 Dubbo、Disconf 等等都会存在这个情况。</p><p>开源作者因为时间关系，更多的精力关注在核心代码，所以对运维友好性可能花费的精力较少。</p><p>当然，因为是开源的关系，我们可以自己做运维平台反向的贡献到这些项目。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/04.png" alt=""></p><p>胖友，分享一个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/console/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— Dubbo 支持</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/dubbo-support/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2017-10-12T06:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/dubbo-support/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">1. 概述</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2. Dubbo 代理</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.1 JavassistProxyFactory</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.1.1 Javassist</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.1.2 TccJavassistProxyFactory</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.1.3 TccProxy &amp; TccClassGenerator</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.1.4 配置 Dubbo Proxy</a></li></ul></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.2 JdkProxyFactory</a><ul><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.2.1 JDK Proxy</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.2.2 TccJdkProxyFactory</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.2.3 TccInvokerInvocationHandler</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">2.2.4 配置 Dubbo Proxy</a></li></ul></li></ul></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">3. Dubbo 事务上下文编辑器</a></li><li><a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文分享 <strong>Dubbo 支持</strong>。</p><p>TCC-Transaction 通过 Dubbo <strong>隐式传参</strong>的功能，避免自己对业务代码的入侵。可能有同学不太理解为什么说 TCC-Transaction 对业务代码有一定的入侵性，一起来看个代码例子：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>代码来自 <code>tcc-transaction-http-sample</code> 。声明远程调用时，增加了参数 TransactionContext。当然你也可以通过自己使用的远程调用框架做一定封装，避免入侵。</li></ul><p>如下是对 Dubbo 封装了后，Dubbo Service 方法的例子：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Compensable</span></div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>代码来自 <code>http-transaction-dubbo-sample</code> 。是不是不需要传入参数 TransactionContext。当然，注解是肯定需要的，否则 TCC-Transaction 怎么知道哪些方法是 TCC 方法。</li></ul><p>TCC-Transaction 通过 Dubbo Proxy 的机制，实现 <code>@Compensable</code> 属性自动生成，增加开发体验，也避免出错。</p><hr><p>Dubbo 支持( Maven 项目 <code>tcc-transaction-dubbo</code> ) 整体代码结构如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/01.png" alt=""></p><ul><li><code>proxy</code></li><li><code>context</code></li></ul><p>我们分成两个小节分享这两个包实现的功能。</p><p><strong>笔者暂时对 Dubbo 了解的不够深入，如果有错误的地方，还烦请指出，谢谢。</strong></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><h1>2. Dubbo 代理</h1><p>将 Dubbo Service 方法上的<strong>注解</strong> <code>@Compensable</code> ，自动生成注解的 <code>confirmMethod</code>、<code>cancelMethod</code>、<code>transactionContextEditor</code> 属性，例子代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Compensable</span>(propagation=Propagation.SUPPORTS, confirmMethod=<span class="string">"record"</span>, cancelMethod=<span class="string">"record"</span>, transactionContextEditor=DubboTransactionContextEditor.class)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto paramRedPacketTradeOrderDto)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>该代码通过 Javassist 生成的 Proxy 代码的示例。</li><li><code>propagation=Propagation.SUPPORTS</code> ：支持当前事务，如果当前没有事务，就以非事务方式执行。<strong>为什么不使用 REQUIRED</strong> ？如果使用 REQUIRED 事务传播级别，事务恢复重试时，会发起新的事务。</li><li><code>confirmMethod</code>、<code>cancelMethod</code> 使用和 try 方法<strong>相同方法名</strong>：<strong>本地发起</strong>远程服务 TCC confirm / cancel 阶段，调用相同方法进行事务的提交或回滚。远程服务的 CompensableTransactionInterceptor 会根据事务的状态是 CONFIRMING / CANCELLING 来调用对应方法。<ul><li><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/02.png" alt=""></li></ul></li><li><code>transactionContextEditor=DubboTransactionContextEditor.class</code>，使用 Dubbo 事务上下文编辑器，在<a href="#">「3. Dubbo 事务上下文编辑器」</a>详细分享。</li></ul><p>Dubbo Service Proxy 提供了两种生成方式：</p><ul><li>JavassistProxyFactory，基于 Javassist 方式</li><li>JdkProxyFactory，基于 JDK 动态代理机制</li></ul><p>这块内容我们不拓展开，感兴趣的同学点击如下文章：</p><ul><li><a href="http://daveztong.github.io/2016/11/23/Dubbo%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo学习-理解动态代理》</a></li><li><a href="http://javatar.iteye.com/blog/814426" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo 作者博客 —— 动态代理方案性能对比》</a></li><li><a href="http://blog.csdn.net/quhongwei_zhanqiu/article/details/41597261" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo原理解析-代理之Javassist生成的伪代码》</a></li><li><strong><a href="http://blog.kazaff.me/2015/01/27/dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%BB%86%E8%8A%82/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo的服务暴露细节》</a></strong></li></ul><p>Dubbo 的 Invoker 模型是非常关键的概念，看下图：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/03.jpeg" alt=""></p><h2>2.1 JavassistProxyFactory</h2><h3>2.1.1 Javassist</h3><blockquote><p>Javassist 是一个开源的分析、编辑和创建 Java 字节码的类库。通过使用Javassist 对字节码操作可以实现动态 ”AOP” 框架。</p><p>关于 Java 字节码的处理，目前有很多工具，如 bcel，asm( cglib只是对asm又封装了一层 )。不过这些都需要直接跟虚拟机指令打交道。</p><p>Javassist 的主要的优点，在于简单，而且快速，直接使用 Java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p></blockquote><ul><li>粗略一看，可能不够形象，下面我们通过看 TCC-Transaction 如何使用来理解理解。</li><li><a href="http://www.cnblogs.com/sunfie/p/5154246.html" rel="external nofollow noopener noreferrer" target="_blank">《Java学习之javassist》</a></li><li><a href="http://blog.csdn.net/qbg19881206/article/details/8993562" rel="external nofollow noopener noreferrer" target="_blank">《Javassist 字节码操作》</a></li></ul><h3>2.1.2 TccJavassistProxyFactory</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccJavassistProxyFactory</code>，TCC Javassist 代理工厂。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccJavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">JavassistProxyFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) TccProxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>项目启动时</strong>，调用 <code>TccJavassistProxyFactory#getProxy(...)</code> 方法，生成 Dubbo Service 调用 Proxy。</li><li><code>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler</code>，Dubbo 调用处理器，点击<a href="https://github.com/alibaba/dubbo/blob/17619dfa974457b00fe27cf68ae3f9d266709666/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/InvokerInvocationHandler.java" rel="external nofollow noopener noreferrer" target="_blank">连接</a>查看代码。</li></ul><h3>2.1.3 TccProxy &amp; TccClassGenerator</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccProxy</code>，TCC Proxy 工厂，生成 Dubbo Service 调用 Proxy 。笔者认为，TccProxy 改成 TccProxyFactory 更合适，原因在下文。</p><p><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator</code>，TCC 类代码生成器，基于 Javassist 实现。</p><p><strong>🦅案例</strong></p><p>一个 Dubbo Service，TccProxy 会动态生成两个类：</p><ul><li>Dubbo Service 调用 Proxy</li><li>Dubbo Service 调用 ProxyFactory，生成对应的 Dubbo Service Proxy</li></ul><p>例如 Dubbo Service 接口如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketTradeOrderService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Compensable</span></div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>生成 Dubbo Service 调用 <strong>ProxyFactory</strong> 如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccProxy3</span> <span class="keyword">extends</span> <span class="title">TccProxy</span> <span class="keyword">implements</span> <span class="title">TccClassGenerator</span>.<span class="title">DC</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> proxy3(paramInvocationHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>TccProxy 提供 <code>#newInstance(handler)</code> 方法，创建 Proxy，所以笔者认为，TccProxy 改成 TccProxyFactory 更合适。</li><li><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator.DC</code> 动态生成类标记，标记该类由 TccClassGenerator 生成的。</li></ul><p>生成 Dubbo Service 调用 <strong>Proxy</strong> 如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy3</span> <span class="keyword">implements</span> <span class="title">TccClassGenerator</span>.<span class="title">DC</span>, <span class="title">RedPacketTradeOrderService</span>, <span class="title">EchoService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</div><div class="line">    <span class="keyword">private</span> InvocationHandler handler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy3</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy3</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.handler = paramInvocationHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Compensable</span>(propagation = Propagation.SUPPORTS, confirmMethod = <span class="string">"record"</span>, cancelMethod = <span class="string">"record"</span>, transactionContextEditor = DubboTransactionContextEditor.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto paramRedPacketTradeOrderDto)</span> </span>&#123;</div><div class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        arrayOfObject[<span class="number">0</span>] = paramRedPacketTradeOrderDto;</div><div class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrayOfObject);</div><div class="line">        <span class="keyword">return</span> (String) localObject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object $echo(Object paramObject) &#123;</div><div class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        arrayOfObject[<span class="number">0</span>] = paramObject;</div><div class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrayOfObject);</div><div class="line">        <span class="keyword">return</span> (Object) localObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.alibaba.dubbo.rpc.service.EchoService</code>，Dubbo Service 回声服务接口，用于服务健康检查，Dubbo Service 默认自动实现该接口，点击<a href="https://github.com/alibaba/dubbo/blob/17619dfa974457b00fe27cf68ae3f9d266709666/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/service/EchoService.java" rel="external nofollow noopener noreferrer" target="_blank">连接</a>查看代码。</li><li><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator.DC</code> 动态生成类标记，标记该类由 TccClassGenerator 生成的。</li></ul><p><strong>🦅实现</strong></p><p>调用 <code>TccProxy#getProxy(...)</code> 方法，获得 <strong>TCC Proxy 工厂</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="comment">// 【TccProxy.java】</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TccProxy <span class="title">getProxy</span><span class="params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="comment">// 校验接口超过上限</span></div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (ics.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">  <span class="number">5</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">  <span class="number">6</span>:     &#125;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:     <span class="comment">// use interface class name list as key.</span></div><div class="line">  <span class="number">9</span>:     StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line"> <span class="number">10</span>:     <span class="keyword">for</span> (Class&lt;?&gt; ic : ics) &#123;</div><div class="line"> <span class="number">11</span>:         String itf = ic.getName();</div><div class="line"> <span class="number">12</span>:         <span class="comment">// 校验是否为接口</span></div><div class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (!ic.isInterface()) &#123;</div><div class="line"> <span class="number">14</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(itf + <span class="string">" is not a interface."</span>);</div><div class="line"> <span class="number">15</span>:         &#125;</div><div class="line"> <span class="number">16</span>:         <span class="comment">// 加载接口类</span></div><div class="line"> <span class="number">17</span>:         Class&lt;?&gt; tmp = <span class="keyword">null</span>;</div><div class="line"> <span class="number">18</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">19</span>:             tmp = Class.forName(itf, <span class="keyword">false</span>, cl);</div><div class="line"> <span class="number">20</span>:         &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line"> <span class="number">21</span>:         &#125;</div><div class="line"> <span class="number">22</span>:         <span class="keyword">if</span> (tmp != ic) &#123; <span class="comment">// 加载接口类失败</span></div><div class="line"> <span class="number">23</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ic + <span class="string">" is not visible from class loader"</span>);</div><div class="line"> <span class="number">24</span>:         &#125;</div><div class="line"> <span class="number">25</span>:         sb.append(itf).append(<span class="string">';'</span>);</div><div class="line"> <span class="number">26</span>:     &#125;</div><div class="line"> <span class="number">27</span>:     String key = sb.toString();</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:     <span class="comment">// get cache by class loader.</span></div><div class="line"> <span class="number">30</span>:     Map&lt;String, Object&gt; cache;</div><div class="line"> <span class="number">31</span>:     <span class="keyword">synchronized</span> (ProxyCacheMap) &#123;</div><div class="line"> <span class="number">32</span>:         cache = ProxyCacheMap.get(cl);</div><div class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">34</span>:             cache = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line"> <span class="number">35</span>:             ProxyCacheMap.put(cl, cache);</div><div class="line"> <span class="number">36</span>:         &#125;</div><div class="line"> <span class="number">37</span>:     &#125;</div><div class="line"> <span class="number">38</span>: </div><div class="line"> <span class="number">39</span>:     <span class="comment">// 获得 TccProxy 工厂</span></div><div class="line"> <span class="number">40</span>:     TccProxy proxy = <span class="keyword">null</span>;</div><div class="line"> <span class="number">41</span>:     <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line"> <span class="number">42</span>:         <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">43</span>:             <span class="comment">// 从缓存中获取 TccProxy 工厂</span></div><div class="line"> <span class="number">44</span>:             Object value = cache.get(key);</div><div class="line"> <span class="number">45</span>:             <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference&lt;?&gt;) &#123;</div><div class="line"> <span class="number">46</span>:                 proxy = (TccProxy) ((Reference&lt;?&gt;) value).get();</div><div class="line"> <span class="number">47</span>:                 <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">48</span>:                     <span class="keyword">return</span> proxy;</div><div class="line"> <span class="number">49</span>:                 &#125;</div><div class="line"> <span class="number">50</span>:             &#125;</div><div class="line"> <span class="number">51</span>:             <span class="comment">// 缓存中不存在，设置生成 TccProxy 代码标记。创建中时，其他创建请求等待，避免并发。</span></div><div class="line"> <span class="number">52</span>:             <span class="keyword">if</span> (value == PendingGenerationMarker) &#123;</div><div class="line"> <span class="number">53</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">54</span>:                     cache.wait();</div><div class="line"> <span class="number">55</span>:                 &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line"> <span class="number">56</span>:                 &#125;</div><div class="line"> <span class="number">57</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">58</span>:                 cache.put(key, PendingGenerationMarker);</div><div class="line"> <span class="number">59</span>:                 <span class="keyword">break</span>;</div><div class="line"> <span class="number">60</span>:             &#125;</div><div class="line"> <span class="number">61</span>:         &#125;</div><div class="line"> <span class="number">62</span>:         <span class="keyword">while</span> (<span class="keyword">true</span>);</div><div class="line"> <span class="number">63</span>:     &#125;</div><div class="line"> <span class="number">64</span>: </div><div class="line"> <span class="number">65</span>:     <span class="keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();</div><div class="line"> <span class="number">66</span>:     String pkg = <span class="keyword">null</span>;</div><div class="line"> <span class="number">67</span>:     TccClassGenerator ccp = <span class="keyword">null</span>; <span class="comment">// proxy class generator</span></div><div class="line"> <span class="number">68</span>:     TccClassGenerator ccm = <span class="keyword">null</span>; <span class="comment">// proxy factory class generator</span></div><div class="line"> <span class="number">69</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">70</span>:         <span class="comment">// 创建 Tcc class 代码生成器</span></div><div class="line"> <span class="number">71</span>:         ccp = TccClassGenerator.newInstance(cl);</div><div class="line"> <span class="number">72</span>: </div><div class="line"> <span class="number">73</span>:         Set&lt;String&gt; worked = <span class="keyword">new</span> HashSet&lt;String&gt;(); <span class="comment">// 已处理方法签名集合。key：方法签名</span></div><div class="line"> <span class="number">74</span>:         List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;Method&gt;(); <span class="comment">// 已处理方法集合。</span></div><div class="line"> <span class="number">75</span>: </div><div class="line"> <span class="number">76</span>:         <span class="comment">// 处理接口</span></div><div class="line"> <span class="number">77</span>:         <span class="keyword">for</span> (Class&lt;?&gt; ic : ics) &#123;</div><div class="line"> <span class="number">78</span>:             <span class="comment">// 非 public 接口，使用接口包名</span></div><div class="line"> <span class="number">79</span>:             <span class="keyword">if</span> (!Modifier.isPublic(ic.getModifiers())) &#123;</div><div class="line"> <span class="number">80</span>:                 String npkg = ic.getPackage().getName();</div><div class="line"> <span class="number">81</span>:                 <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">82</span>:                     pkg = npkg;</div><div class="line"> <span class="number">83</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">84</span>:                     <span class="keyword">if</span> (!pkg.equals(npkg)) &#123; <span class="comment">// 实现了两个非 public 的接口，</span></div><div class="line"> <span class="number">85</span>:                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</div><div class="line"> <span class="number">86</span>:                     &#125;</div><div class="line"> <span class="number">87</span>:                 &#125;</div><div class="line"> <span class="number">88</span>:             &#125;</div><div class="line"> <span class="number">89</span>:             <span class="comment">// 添加接口</span></div><div class="line"> <span class="number">90</span>:             ccp.addInterface(ic);</div><div class="line"> <span class="number">91</span>:             <span class="comment">// 处理接口方法</span></div><div class="line"> <span class="number">92</span>:             <span class="keyword">for</span> (Method method : ic.getMethods()) &#123;</div><div class="line"> <span class="number">93</span>:                 <span class="comment">// 添加方法签名到已处理方法签名集合</span></div><div class="line"> <span class="number">94</span>:                 String desc = ReflectUtils.getDesc(method);</div><div class="line"> <span class="number">95</span>:                 <span class="keyword">if</span> (worked.contains(desc)) &#123;</div><div class="line"> <span class="number">96</span>:                     <span class="keyword">continue</span>;</div><div class="line"> <span class="number">97</span>:                 &#125;</div><div class="line"> <span class="number">98</span>:                 worked.add(desc);</div><div class="line"> <span class="number">99</span>:                 <span class="comment">// 生成接口方法实现代码</span></div><div class="line"><span class="number">100</span>:                 <span class="keyword">int</span> ix = methods.size();</div><div class="line"><span class="number">101</span>:                 Class&lt;?&gt; rt = method.getReturnType();</div><div class="line"><span class="number">102</span>:                 Class&lt;?&gt;[] pts = method.getParameterTypes();</div><div class="line"><span class="number">103</span>:                 StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="string">"];"</span>);</div><div class="line"><span class="number">104</span>:                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pts.length; j++) &#123;</div><div class="line"><span class="number">105</span>:                     code.append(<span class="string">" args["</span>).append(j).append(<span class="string">"] = ($w)$"</span>).append(j + <span class="number">1</span>).append(<span class="string">";"</span>);</div><div class="line"><span class="number">106</span>:                 &#125;</div><div class="line"><span class="number">107</span>:                 code.append(<span class="string">" Object ret = handler.invoke(this, methods["</span>).append(ix).append(<span class="string">"], args);"</span>);</div><div class="line"><span class="number">108</span>:                 <span class="keyword">if</span> (!Void.TYPE.equals(rt)) &#123;</div><div class="line"><span class="number">109</span>:                     code.append(<span class="string">" return "</span>).append(asArgument(rt, <span class="string">"ret"</span>)).append(<span class="string">";"</span>);</div><div class="line"><span class="number">110</span>:                 &#125;</div><div class="line"><span class="number">111</span>:                 methods.add(method);</div><div class="line"><span class="number">112</span>:                 <span class="comment">// 添加方法</span></div><div class="line"><span class="number">113</span>:                 Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line"><span class="number">114</span>:                 <span class="keyword">if</span> (compensable != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">115</span>:                     ccp.addMethod(<span class="keyword">true</span>, method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</div><div class="line"><span class="number">116</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">117</span>:                     ccp.addMethod(<span class="keyword">false</span>, method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</div><div class="line"><span class="number">118</span>:                 &#125;</div><div class="line"><span class="number">119</span>:             &#125;</div><div class="line"><span class="number">120</span>:         &#125;</div><div class="line"><span class="number">121</span>: </div><div class="line"><span class="number">122</span>:         <span class="comment">// 设置包路径</span></div><div class="line"><span class="number">123</span>:         <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">124</span>:             pkg = PACKAGE_NAME;</div><div class="line"><span class="number">125</span>:         &#125;</div><div class="line"><span class="number">126</span>: </div><div class="line"><span class="number">127</span>:         <span class="comment">// create ProxyInstance class.</span></div><div class="line"><span class="number">128</span>:         <span class="comment">// 设置类名</span></div><div class="line"><span class="number">129</span>:         String pcn = pkg + <span class="string">".proxy"</span> + id;</div><div class="line"><span class="number">130</span>:         ccp.setClassName(pcn);</div><div class="line"><span class="number">131</span>:         <span class="comment">// 添加静态属性 methods</span></div><div class="line"><span class="number">132</span>:         ccp.addField(<span class="string">"public static java.lang.reflect.Method[] methods;"</span>);</div><div class="line"><span class="number">133</span>:         <span class="comment">// 添加属性 handler</span></div><div class="line"><span class="number">134</span>:         ccp.addField(<span class="string">"private "</span> + InvocationHandler.class.getName() + <span class="string">" handler;"</span>);</div><div class="line"><span class="number">135</span>:         <span class="comment">// 添加构造方法，参数 handler</span></div><div class="line"><span class="number">136</span>:         ccp.addConstructor(Modifier.PUBLIC, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="string">"handler=$1;"</span>);</div><div class="line"><span class="number">137</span>:         <span class="comment">// 添加构造方法，参数 空</span></div><div class="line"><span class="number">138</span>:         ccp.addDefaultConstructor();</div><div class="line"><span class="number">139</span>:         <span class="comment">// 生成类</span></div><div class="line"><span class="number">140</span>:         Class&lt;?&gt; clazz = ccp.toClass();</div><div class="line"><span class="number">141</span>:         <span class="comment">// 设置静态属性 methods</span></div><div class="line"><span class="number">142</span>:         clazz.getField(<span class="string">"methods"</span>).set(<span class="keyword">null</span>, methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]));</div><div class="line"><span class="number">143</span>: </div><div class="line"><span class="number">144</span>:         <span class="comment">// create TccProxy class.</span></div><div class="line"><span class="number">145</span>:         <span class="comment">// 创建 Tcc class 代码生成器</span></div><div class="line"><span class="number">146</span>:         ccm = TccClassGenerator.newInstance(cl);</div><div class="line"><span class="number">147</span>:         <span class="comment">// 设置类名</span></div><div class="line"><span class="number">148</span>:         String fcn = TccProxy.class.getName() + id;</div><div class="line"><span class="number">149</span>:         ccm.setClassName(fcn);</div><div class="line"><span class="number">150</span>:         <span class="comment">// 添加构造方法，参数 空</span></div><div class="line"><span class="number">151</span>:         ccm.addDefaultConstructor();</div><div class="line"><span class="number">152</span>:         <span class="comment">// 设置父类为 TccProxy.class</span></div><div class="line"><span class="number">153</span>:         ccm.setSuperClass(TccProxy.class);</div><div class="line"><span class="number">154</span>:         <span class="comment">// 添加方法 #newInstance(handler)</span></div><div class="line"><span class="number">155</span>:         ccm.addMethod(<span class="string">"public Object newInstance("</span> + InvocationHandler.class.getName() + <span class="string">" h)&#123; return new "</span> + pcn + <span class="string">"($1); &#125;"</span>);</div><div class="line"><span class="number">156</span>:         <span class="comment">// 生成类</span></div><div class="line"><span class="number">157</span>:         Class&lt;?&gt; pc = ccm.toClass();</div><div class="line"><span class="number">158</span>:         <span class="comment">// 创建 TccProxy 对象</span></div><div class="line"><span class="number">159</span>:         proxy = (TccProxy) pc.newInstance();</div><div class="line"><span class="number">160</span>:     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line"><span class="number">161</span>:         <span class="keyword">throw</span> e;</div><div class="line"><span class="number">162</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">163</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</div><div class="line"><span class="number">164</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">165</span>:         <span class="comment">// release TccClassGenerator</span></div><div class="line"><span class="number">166</span>:         <span class="keyword">if</span> (ccp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">167</span>:             ccp.release();</div><div class="line"><span class="number">168</span>:         &#125;</div><div class="line"><span class="number">169</span>:         <span class="keyword">if</span> (ccm != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">170</span>:             ccm.release();</div><div class="line"><span class="number">171</span>:         &#125;</div><div class="line"><span class="number">172</span>:         <span class="comment">// 唤醒缓存 wait</span></div><div class="line"><span class="number">173</span>:         <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line"><span class="number">174</span>:             <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">175</span>:                 cache.remove(key);</div><div class="line"><span class="number">176</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">177</span>:                 cache.put(key, <span class="keyword">new</span> WeakReference&lt;TccProxy&gt;(proxy));</div><div class="line"><span class="number">178</span>:             &#125;</div><div class="line"><span class="number">179</span>:             cache.notifyAll();</div><div class="line"><span class="number">180</span>:         &#125;</div><div class="line"><span class="number">181</span>:     &#125;</div><div class="line"><span class="number">182</span>:     <span class="keyword">return</span> proxy;</div><div class="line"><span class="number">183</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 至 7 行 ：校验接口超过上限。</p></li><li><p>第 8 至 27 行 ：使用接口集合类名以 <code>;</code> 分隔拼接，作为 Proxy 的唯一标识。例如 ：<code>key=org.mengyun.tcctransaction.sample.dubbo.redpacket.api.RedPacketAccountService;com.alibaba.dubbo.rpc.service.EchoService;</code> 。</p></li><li><p>第 29 至 37 行 ：获得 Proxy 对应的 ClassLoader。这里我们看下静态属性 <code>ProxyCacheMap</code> 的定义：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Proxy 对象缓存</span></div><div class="line"><span class="comment">* key ：ClassLoader</span></div><div class="line"><span class="comment">* value.key ：Tcc Proxy 标识。使用 Tcc Proxy 实现接口名拼接</span></div><div class="line"><span class="comment">* value.value ：Tcc Proxy 工厂对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, Map&lt;String, Object&gt;&gt; ProxyCacheMap = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, Map&lt;String, Object&gt;&gt;();</div></pre></td></tr></table></figure></p><ul><li>使用 WeakHashMap，当 ClassLoader 被回收时，其对应的值一起被移除。</li><li><a href="http://blog.csdn.net/yangzl2008/article/details/6980709" rel="external nofollow noopener noreferrer" target="_blank">《WeakHashMap和HashMap的区别》</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3311092.html" rel="external nofollow noopener noreferrer" target="_blank">《Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例》</a></li></ul></li><li><p>第 39 至 63 行 ：一直获得 <strong>TCC Proxy 工厂</strong>直到成功。</p><ul><li>第 43 至 50 行 ：从<strong>缓存</strong>中获取 TCC Proxy 工厂。</li><li>第 51 至 60 行 ：若缓存中不存在，设置<strong>正在生成 TccProxy 代码标记</strong>。创建中时，其他创建请求等待，避免并发。</li></ul></li><li><p>第 65 行 ：<code>PROXY_CLASS_COUNTER</code>，Proxy Class 计数，用于生成 Proxy 类名自增。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong PROXY_CLASS_COUNTER = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div></pre></td></tr></table></figure></p></li><li><p>第 66 至 67 行</p><ul><li><code>ccm</code>，生成 Dubbo Service 调用 <strong>ProxyFactory</strong> 的代码生成器</li><li><code>ccp</code>，生成 Dubbo Service 调用 <strong>Proxy</strong> 的代码生成器</li></ul></li><li><p><strong>第 70 至 142 行 ：生成 Dubbo Service 调用 Proxy 的代码</strong>。</p><ul><li><p>第 70 至 71 行 ：调用 <code>TccClassGenerator#newInstance(loader)</code> 方法， 创建生成 Dubbo Service 调用 <strong>Proxy</strong> 的代码生成器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TccClassGenerator.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TccClassGenerator</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * CtClass hash 集合</span></div><div class="line"><span class="comment">     * key：类名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ClassPool mPool;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TccClassGenerator <span class="title">newInstance</span><span class="params">(ClassLoader loader)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TccClassGenerator(getClassPool(loader));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TccClassGenerator</span><span class="params">(ClassPool pool)</span> </span>&#123;</div><div class="line">        mPool = pool;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>ClassPool</strong> 是一个 CtClass 对象的 hash 表，类名做为 key 。ClassPool 的 <code>#get(key)</code> 搜索 hash 表找到与指定 key 关联的 CtClass 对象。如果没有找到 CtClass 对象，<code>#get(key)</code> 读一个类文件构建新的 CtClass 对象，它是被记录在 hash 表中然后返回这个对象。</li></ul></li><li><p>第 76 至 120 行，处理接口。</p><ul><li><p>第 79 至 88 行，生成类的包名。</p></li><li><p>第 89 至 90 行，调用 <code>TccClassGenerator#addInterface(cl)</code> 方法，添加生成类的接口( <strong>Dubbo Service 接口</strong> )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的接口集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Set&lt;String&gt; mInterfaces;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> addInterface(cl.getName());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addInterface</span><span class="params">(String cn)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mInterfaces == <span class="keyword">null</span>) &#123;</div><div class="line">       mInterfaces = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mInterfaces.add(cn);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 93 至 98 行，添加方法签名到已处理方法签名集合。多个接口可能存在相同的接口方法，跳过相同的方法，避免冲突。</p></li><li><p>第 99 至 110 行，生成 Dubbo Service 调用实现代码。案例代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto paramRedPacketTradeOrderDto)</span> </span>&#123;</div><div class="line">  Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">  arrayOfObject[<span class="number">0</span>] = paramRedPacketTradeOrderDto;</div><div class="line">  Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrayOfObject);</div><div class="line">  <span class="keyword">return</span> (String)localObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/04.png" alt=""></li></ul></li><li><p>第 112 至 118 行 ：调用 <code>TccClassGenerator#addMethod(...)</code> 方法，添加生成的方法。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的方法代码集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> List&lt;String&gt; mMethods;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 带 <span class="doctag">@Compensable</span> 方法代码集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Set&lt;String&gt; compensableMethods = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addMethod</span><span class="params">(<span class="keyword">boolean</span> isCompensableMethod, String name, <span class="keyword">int</span> mod, Class&lt;?&gt; rt, Class&lt;?&gt;[] pts, Class&lt;?&gt;[] ets, String body)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接方法</span></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   sb.append(modifier(mod)).append(<span class="string">' '</span>).append(ReflectUtils.getName(rt)).append(<span class="string">' '</span>).append(name);</div><div class="line">   sb.append(<span class="string">'('</span>);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">           sb.append(<span class="string">','</span>);</div><div class="line">       sb.append(ReflectUtils.getName(pts[i]));</div><div class="line">       sb.append(<span class="string">" arg"</span>).append(i);</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">')'</span>);</div><div class="line">   <span class="keyword">if</span> (ets != <span class="keyword">null</span> &amp;&amp; ets.length &gt; <span class="number">0</span>) &#123;</div><div class="line">       sb.append(<span class="string">" throws "</span>);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">               sb.append(<span class="string">','</span>);</div><div class="line">           sb.append(ReflectUtils.getName(ets[i]));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">'&#123;'</span>).append(body).append(<span class="string">'&#125;'</span>);</div><div class="line">   <span class="comment">// 是否有 @Compensable 注解</span></div><div class="line">   <span class="keyword">if</span> (isCompensableMethod) &#123;</div><div class="line">       compensableMethods.add(sb.toString());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> addMethod(sb.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addMethod</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mMethods == <span class="keyword">null</span>) &#123;</div><div class="line">       mMethods = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mMethods.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul></li><li><p>第 122 至 130 行，生成类名( 例如，<code>org.mengyun.tcctransaction.dubbo.proxy.javassist.proxy3</code> )，并调用 <code>TccClassGenerator#setClassName(...)</code> 方法，设置类名。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的类名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> String mClassName;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">setClassName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">   mClassName = name;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 131 至 134 行，调用 <code>TccClassGenerator#addField(...)</code> 方法，添加<strong>静态</strong>属性 <code>methods</code> ( Dubbo Service 方法集合 )和属性 <code>handler</code> ( Dubbo InvocationHandler )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的属性集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> List&lt;String&gt; mFields;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addField</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mFields == <span class="keyword">null</span>) &#123;</div><div class="line">       mFields = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mFields.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 135 至 136 行，调用 <code>TccClassGenerator#addConstructor(...)</code> 方法，添加参数为 <code>handler</code> 的构造方法。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的非空构造方法代码集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> List&lt;String&gt; mConstructors;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addConstructor</span><span class="params">(<span class="keyword">int</span> mod, Class&lt;?&gt;[] pts, Class&lt;?&gt;[] ets, String body)</span> </span>&#123;</div><div class="line">   <span class="comment">// 构造方法代码</span></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   sb.append(modifier(mod)).append(<span class="string">' '</span>).append(SIMPLE_NAME_TAG);</div><div class="line">   sb.append(<span class="string">'('</span>);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">           sb.append(<span class="string">','</span>);</div><div class="line">       sb.append(ReflectUtils.getName(pts[i]));</div><div class="line">       sb.append(<span class="string">" arg"</span>).append(i);</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">')'</span>);</div><div class="line">   <span class="keyword">if</span> (ets != <span class="keyword">null</span> &amp;&amp; ets.length &gt; <span class="number">0</span>) &#123;</div><div class="line">       sb.append(<span class="string">" throws "</span>);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">               sb.append(<span class="string">','</span>);</div><div class="line">           sb.append(ReflectUtils.getName(ets[i]));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">'&#123;'</span>).append(body).append(<span class="string">'&#125;'</span>);</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">return</span> addConstructor(sb.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addConstructor</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mConstructors == <span class="keyword">null</span>) &#123;</div><div class="line">       mConstructors = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mConstructors.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addConstructor</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mConstructors == <span class="keyword">null</span>) &#123;</div><div class="line">       mConstructors = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mConstructors.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 137 至 138 行，调用 <code>TccClassGenerator#addDefaultConstructor()</code> 方法，添加默认空构造方法。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 默认空构造方法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mDefaultConstructor = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addDefaultConstructor</span><span class="params">()</span> </span>&#123;</div><div class="line">   mDefaultConstructor = <span class="keyword">true</span>;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 139 行，调用 <code>TccClassGenerator#toClass()</code> 方法，<strong>生成类</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> Class&lt;?&gt; toClass() &#123;</div><div class="line"> <span class="number">2</span>:    <span class="comment">// mCtc 非空时，进行释放；下面会进行创建 mCtc</span></div><div class="line"> <span class="number">3</span>:    <span class="keyword">if</span> (mCtc != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">4</span>:        mCtc.detach();</div><div class="line"> <span class="number">5</span>:    &#125;</div><div class="line"> <span class="number">6</span>:    <span class="keyword">long</span> id = CLASS_NAME_COUNTER.getAndIncrement();</div><div class="line"> <span class="number">7</span>:    <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">8</span>:        CtClass ctcs = mSuperClass == <span class="keyword">null</span> ? <span class="keyword">null</span> : mPool.get(mSuperClass);</div><div class="line"> <span class="number">9</span>:        <span class="keyword">if</span> (mClassName == <span class="keyword">null</span>) &#123; <span class="comment">// 类名</span></div><div class="line"><span class="number">10</span>:            mClassName = (mSuperClass == <span class="keyword">null</span> || javassist.Modifier.isPublic(ctcs.getModifiers())</div><div class="line"><span class="number">11</span>:                    ? TccClassGenerator.class.getName() : mSuperClass + <span class="string">"$sc"</span>) + id;</div><div class="line"><span class="number">12</span>:        &#125;</div><div class="line"><span class="number">13</span>:        <span class="comment">// 创建 mCtc</span></div><div class="line"><span class="number">14</span>:        mCtc = mPool.makeClass(mClassName);</div><div class="line"><span class="number">15</span>:        <span class="keyword">if</span> (mSuperClass != <span class="keyword">null</span>) &#123; <span class="comment">// 继承类</span></div><div class="line"><span class="number">16</span>:            mCtc.setSuperclass(ctcs);</div><div class="line"><span class="number">17</span>:        &#125;</div><div class="line"><span class="number">18</span>:        mCtc.addInterface(mPool.get(DC.class.getName())); <span class="comment">// add dynamic class tag.</span></div><div class="line"><span class="number">19</span>:        <span class="keyword">if</span> (mInterfaces != <span class="keyword">null</span>) &#123; <span class="comment">// 实现接口集合</span></div><div class="line"><span class="number">20</span>:            <span class="keyword">for</span> (String cl : mInterfaces) &#123;</div><div class="line"><span class="number">21</span>:                mCtc.addInterface(mPool.get(cl));</div><div class="line"><span class="number">22</span>:            &#125;</div><div class="line"><span class="number">23</span>:        &#125;</div><div class="line"><span class="number">24</span>:        <span class="keyword">if</span> (mFields != <span class="keyword">null</span>) &#123; <span class="comment">// 属性集合</span></div><div class="line"><span class="number">25</span>:            <span class="keyword">for</span> (String code : mFields) &#123;</div><div class="line"><span class="number">26</span>:                mCtc.addField(CtField.make(code, mCtc));</div><div class="line"><span class="number">27</span>:            &#125;</div><div class="line"><span class="number">28</span>:        &#125;</div><div class="line"><span class="number">29</span>:        <span class="keyword">if</span> (mMethods != <span class="keyword">null</span>) &#123; <span class="comment">// 方法集合</span></div><div class="line"><span class="number">30</span>:            <span class="keyword">for</span> (String code : mMethods) &#123;</div><div class="line"><span class="number">31</span>:                <span class="keyword">if</span> (code.charAt(<span class="number">0</span>) == <span class="string">':'</span>) &#123;</div><div class="line"><span class="number">32</span>:                    mCtc.addMethod(CtNewMethod.copy(getCtMethod(mCopyMethods.get(code.substring(<span class="number">1</span>))), code.substring(<span class="number">1</span>, code.indexOf(<span class="string">'('</span>)), mCtc, <span class="keyword">null</span>));</div><div class="line"><span class="number">33</span>:                &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">34</span>:                    CtMethod ctMethod = CtNewMethod.make(code, mCtc);</div><div class="line"><span class="number">35</span>:                    <span class="keyword">if</span> (compensableMethods.contains(code)) &#123;</div><div class="line"><span class="number">36</span>:                        <span class="comment">// 设置 @Compensable 属性</span></div><div class="line"><span class="number">37</span>:                        ConstPool constpool = mCtc.getClassFile().getConstPool();</div><div class="line"><span class="number">38</span>:                        AnnotationsAttribute attr = <span class="keyword">new</span> AnnotationsAttribute(constpool, AnnotationsAttribute.visibleTag);</div><div class="line"><span class="number">39</span>:                        Annotation annot = <span class="keyword">new</span> Annotation(<span class="string">"org.mengyun.tcctransaction.api.Compensable"</span>, constpool);</div><div class="line"><span class="number">40</span>:                        EnumMemberValue enumMemberValue = <span class="keyword">new</span> EnumMemberValue(constpool);</div><div class="line"><span class="number">41</span>:                        enumMemberValue.setType(<span class="string">"org.mengyun.tcctransaction.api.Propagation"</span>);</div><div class="line"><span class="number">42</span>:                        enumMemberValue.setValue(<span class="string">"SUPPORTS"</span>);</div><div class="line"><span class="number">43</span>:                        annot.addMemberValue(<span class="string">"propagation"</span>, enumMemberValue);</div><div class="line"><span class="number">44</span>:                        annot.addMemberValue(<span class="string">"confirmMethod"</span>, <span class="keyword">new</span> StringMemberValue(ctMethod.getName(), constpool));</div><div class="line"><span class="number">45</span>:                        annot.addMemberValue(<span class="string">"cancelMethod"</span>, <span class="keyword">new</span> StringMemberValue(ctMethod.getName(), constpool));</div><div class="line"><span class="number">46</span>:                        ClassMemberValue classMemberValue = <span class="keyword">new</span> ClassMemberValue(<span class="string">"org.mengyun.tcctransaction.dubbo.context.DubboTransactionContextEditor"</span>, constpool);</div><div class="line"><span class="number">47</span>:                        annot.addMemberValue(<span class="string">"transactionContextEditor"</span>, classMemberValue);</div><div class="line"><span class="number">48</span>:                        attr.addAnnotation(annot);</div><div class="line"><span class="number">49</span>:                        ctMethod.getMethodInfo().addAttribute(attr);</div><div class="line"><span class="number">50</span>:                    &#125;</div><div class="line"><span class="number">51</span>:                    mCtc.addMethod(ctMethod);</div><div class="line"><span class="number">52</span>:                &#125;</div><div class="line"><span class="number">53</span>:            &#125;</div><div class="line"><span class="number">54</span>:        &#125;</div><div class="line"><span class="number">55</span>:        <span class="keyword">if</span> (mDefaultConstructor) &#123; <span class="comment">// 空参数构造方法</span></div><div class="line"><span class="number">56</span>:            mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));</div><div class="line"><span class="number">57</span>:        &#125;</div><div class="line"><span class="number">58</span>:        <span class="keyword">if</span> (mConstructors != <span class="keyword">null</span>) &#123; <span class="comment">// 带参数构造方法</span></div><div class="line"><span class="number">59</span>:            <span class="keyword">for</span> (String code : mConstructors) &#123;</div><div class="line"><span class="number">60</span>:                <span class="keyword">if</span> (code.charAt(<span class="number">0</span>) == <span class="string">':'</span>) &#123;</div><div class="line"><span class="number">61</span>:                    mCtc.addConstructor(CtNewConstructor.copy(getCtConstructor(mCopyConstructors.get(code.substring(<span class="number">1</span>))), mCtc, <span class="keyword">null</span>));</div><div class="line"><span class="number">62</span>:                &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">63</span>:                    String[] sn = mCtc.getSimpleName().split(<span class="string">"\\$+"</span>); <span class="comment">// inner class name include $.</span></div><div class="line"><span class="number">64</span>:                    mCtc.addConstructor(CtNewConstructor.make(code.replaceFirst(SIMPLE_NAME_TAG, sn[sn.length - <span class="number">1</span>]), mCtc));</div><div class="line"><span class="number">65</span>:                &#125;</div><div class="line"><span class="number">66</span>:            &#125;</div><div class="line"><span class="number">67</span>:        &#125;</div><div class="line"><span class="number">68</span>: <span class="comment">//            mCtc.debugWriteFile("/Users/yunai/test/" + mCtc.getSimpleName().replaceAll(".", "/") + ".class");</span></div><div class="line"><span class="number">69</span>:        <span class="comment">// 生成</span></div><div class="line"><span class="number">70</span>:        <span class="keyword">return</span> mCtc.toClass();</div><div class="line"><span class="number">71</span>:    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line"><span class="number">72</span>:        <span class="keyword">throw</span> e;</div><div class="line"><span class="number">73</span>:    &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</div><div class="line"><span class="number">74</span>:        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</div><div class="line"><span class="number">75</span>:    &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</div><div class="line"><span class="number">76</span>:        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</div><div class="line"><span class="number">77</span>:    &#125;</div><div class="line"><span class="number">78</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>基于 Javassist 生成类。这里不做拓展解释，配合<a href="http://www.cnblogs.com/sunfie/p/5154246.html" rel="external nofollow noopener noreferrer" target="_blank">《Java学习之javassist》</a>一起理解。</li><li>第 18 行，添加 <code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator.DC</code> 动态生成类标记，标记该类由 TccClassGenerator 生成的。</li><li>第 34 至 50 行，设置 @Compensable 默认属性。</li></ul></li><li><p>第 141 至 142 行，设置 Dubbo Service 方法集合设置到静态属性 <code>methods</code> 上。</p></li></ul></li><li><p><strong>第 144 至 157 行，生成 Dubbo Service 调用 Proxy 工厂的代码</strong>。</p><ul><li><p>第 146 行，调用 <code>TccClassGenerator#newInstance(loader)</code> 方法， 创建生成 Dubbo Service 调用 <strong>Proxy 工厂</strong> 的代码生成器。</p></li><li><p>第 147 至 149 行，生成类名( 例如，<code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccProxy3</code> )，并调用 <code>TccClassGenerator#setClassName(...)</code> 方法，设置类名。</p></li><li><p>第 150 至 151 行，调用 <code>TccClassGenerator#addDefaultConstructor()</code> 方法，添加默认空构造方法。</p></li><li><p>第 152 至 153 行，调用 <code>TccClassGenerator#mSuperClass()</code> 方法，设置继承父类 <strong><code>TccProxy</code></strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的父类名字</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> String mSuperClass;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">setSuperClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</div><div class="line">   mSuperClass = cl.getName();</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 154 至 155 行，调用 <code>TccClassGenerator#addInterface(cl)</code> 方法，添加生成 Proxy 实现代码的方法。代码案例如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> proxy3(paramInvocationHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 156 至 157 行，调用 <code>TccClassGenerator#toClass()</code> 方法，<strong>生成类</strong>。</p></li></ul></li><li><p>第 159 行，调用 <code>TccProxy#newInstance()</code> 方法，创建 Proxy 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* get instance with default handler.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> instance.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> newInstance(THROW_UNSUPPORTED_INVOKER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* get instance with special handler.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> instance.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler handler)</span></span>;</div></pre></td></tr></table></figure></p><ul><li><code>#newInstance(handler)</code>，抽象方法，上面第 154 至 155 行生成。TccJavassistProxyFactory 调用该方法，获得 Proxy 。</li></ul></li><li><p>第 165 至 171 行，释放 TccClassGenerator 。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mCtc != <span class="keyword">null</span>) &#123;</div><div class="line">       mCtc.detach();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mInterfaces != <span class="keyword">null</span>) &#123;</div><div class="line">       mInterfaces.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mFields != <span class="keyword">null</span>) &#123;</div><div class="line">       mFields.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mMethods != <span class="keyword">null</span>) &#123;</div><div class="line">       mMethods.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mConstructors != <span class="keyword">null</span>) &#123;</div><div class="line">       mConstructors.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mCopyMethods != <span class="keyword">null</span>) &#123;</div><div class="line">       mCopyMethods.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mCopyConstructors != <span class="keyword">null</span>) &#123;</div><div class="line">       mCopyConstructors.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 172 至 180 行，设置 Proxy 工厂缓存，并唤醒等待线程。</p></li></ul><p>**ps：**代码比较多，收获会比较多，算是 Javassist 实战案例了。TCC-Transaction 作者在实现上述类，可能参考了 Dubbo 自带的实现：</p><ul><li><a href="https://github.com/alibaba/dubbo/blob/8f20e3a68efc350e3fbaa965e0a8e8a59fef1b3c/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/Proxy.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.alibaba.dubbo.common.bytecode.Proxy</code></a></li><li><a href="https://github.com/alibaba/dubbo/blob/8f20e3a68efc350e3fbaa965e0a8e8a59fef1b3c/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/ClassGenerator.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.alibaba.dubbo.common.bytecode.ClassGenerator</code></a></li><li><a href="https://github.com/alibaba/dubbo/blob/8f20e3a68efc350e3fbaa965e0a8e8a59fef1b3c/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/Wrapper.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.alibaba.dubbo.common.bytecode.Wrapper</code></a></li></ul><h3>2.1.4 配置 Dubbo Proxy</h3><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// META-INF.dubbo/com.alibaba.dubbo.rpc.ProxyFactory</div><div class="line">tccJavassist=org.mengyun.tcctransaction.dubbo.proxy.javassist.TccJavassistProxyFactory</div><div class="line"></div><div class="line">// tcc-transaction-dubbo.xml</div><div class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">proxy</span>=<span class="string">"tccJavassist"</span>/&gt;</span></div></pre></td></tr></table></figure></p><p>目前 Maven 项目 <code>tcc-transaction-dubbo</code> 已经<strong>默认</strong>配置，引入即可。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/05.png" alt=""></p><h2>2.2 JdkProxyFactory</h2><h3>2.2.1 JDK Proxy</h3><p><a href="http://blog.csdn.net/jiankunking/article/details/52143504#" rel="external nofollow noopener noreferrer" target="_blank">《 Java JDK 动态代理（AOP）使用及实现原理分析》</a></p><h3>2.2.2 TccJdkProxyFactory</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.jd.TccJdkProxyFactory</code>，TCC JDK 代理工厂。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccJdkProxyFactory</span> <span class="keyword">extends</span> <span class="title">JdkProxyFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</div><div class="line">        T proxy = (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="keyword">new</span> InvokerInvocationHandler(invoker));</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="keyword">new</span> TccInvokerInvocationHandler(proxy, invoker));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>项目启动时</strong>，调用 <code>TccJavassistProxyFactory#getProxy(...)</code> 方法，生成 Dubbo Service 调用 Proxy。</li><li><strong>第一次</strong>调用 <code>Proxy#newProxyInstance(...)</code> 方法，创建调用 Dubbo Service 服务的 Proxy。<code>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler</code>，Dubbo 调用处理器，点击<a href="https://github.com/alibaba/dubbo/blob/17619dfa974457b00fe27cf68ae3f9d266709666/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/InvokerInvocationHandler.java" rel="external nofollow noopener noreferrer" target="_blank">连接</a>查看代码。</li><li><strong>第二次</strong>调用 <code>Proxy#newProxyInstance(...)</code> 方法，创建对调用 Dubbo Service 的 Proxy 的 Proxy。为什么会有两层 Proxy？答案在下节 TccInvokerInvocationHandler 。</li></ul><h3>2.2.3 TccInvokerInvocationHandler</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.jdk.TccInvokerInvocationHandler</code>，TCC 调用处理器，在调用 Dubbo Service 服务时，使用 ResourceCoordinatorInterceptor 拦截处理。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccInvokerInvocationHandler</span> <span class="keyword">extends</span> <span class="title">InvokerInvocationHandler</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 4:      * proxy</span></div><div class="line"><span class="comment"> 5:      */</span></div><div class="line"> <span class="number">6</span>:     <span class="keyword">private</span> Object target;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="function"><span class="keyword">public</span> <span class="title">TccInvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>:         <span class="keyword">super</span>(handler);</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     <span class="keyword">public</span> &lt;T&gt; TccInvokerInvocationHandler(T target, Invoker&lt;T&gt; invoker) &#123;</div><div class="line"><span class="number">13</span>:         <span class="keyword">super</span>(invoker);</div><div class="line"><span class="number">14</span>:         <span class="keyword">this</span>.target = target;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="number">18</span>:         Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line"><span class="number">19</span>:         <span class="keyword">if</span> (compensable != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">20</span>:             <span class="comment">// 设置 @Compensable 属性</span></div><div class="line"><span class="number">21</span>:             <span class="keyword">if</span> (StringUtils.isEmpty(compensable.confirmMethod())) &#123;</div><div class="line"><span class="number">22</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"confirmMethod"</span>, method.getName());</div><div class="line"><span class="number">23</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"cancelMethod"</span>, method.getName());</div><div class="line"><span class="number">24</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"transactionContextEditor"</span>, DubboTransactionContextEditor.class);</div><div class="line"><span class="number">25</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"propagation"</span>, Propagation.SUPPORTS);</div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:             <span class="comment">// 生成切面</span></div><div class="line"><span class="number">28</span>:             ProceedingJoinPoint pjp = <span class="keyword">new</span> MethodProceedingJoinPoint(proxy, target, method, args);</div><div class="line"><span class="number">29</span>:             <span class="comment">// 执行</span></div><div class="line"><span class="number">30</span>:             <span class="keyword">return</span> FactoryBuilder.factoryOf(ResourceCoordinatorAspect.class).getInstance().interceptTransactionContextMethod(pjp);</div><div class="line"><span class="number">31</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">32</span>:             <span class="keyword">return</span> <span class="keyword">super</span>.invoke(target, method, args);</div><div class="line"><span class="number">33</span>:         &#125;</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 18 至 26 行，设置带有 @Compensable 属性的默认属性。</p></li><li><p>第 28 行，生成方法切面 <code>org.mengyun.tcctransaction.dubbo.proxy.jdk.MethodProceedingJoinPoint</code>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodProceedingJoinPoint</span> <span class="keyword">implements</span> <span class="title">ProceedingJoinPoint</span>, <span class="title">JoinPoint</span>.<span class="title">StaticPart</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 代理对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object proxy;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 目标对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Method method;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object[] args;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// Use reflection to invoke the method.</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ReflectionUtils.makeAccessible(method);</div><div class="line">            <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">            <span class="comment">// Invoked method threw a checked exception.</span></div><div class="line">            <span class="comment">// We must rethrow it. The client won't see the interceptor.</span></div><div class="line">            <span class="keyword">throw</span> ex.getTargetException();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"Tried calling method ["</span> +</div><div class="line">                    method + <span class="string">"] on target ["</span> + target + <span class="string">"] failed"</span>, ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//        throw new UnsupportedOperationException(); // TODO 芋艿：疑问</span></div><div class="line">        <span class="keyword">return</span> proceed();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略不重要的方法和对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>该类参考 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint</code></a> 实现。</li><li>TODO【1】 proxy 和 target 是否保留一个即可？</li><li>在切面处理完成后，调用 <code>#proceed(...)</code> 方法，进行远程 Dubbo Service 服务调用。</li><li>TODO【2】<code>#proceed(objects)</code> 抛出 throw new UnsupportedOperationException();。需要跟作者确认下。</li></ul></li><li><p>调用 <code>ResourceCoordinatorAspect#interceptTransactionContextMethod(...)</code> 方法，对方法切面拦截处理。<strong>为什么无需调用 CompensableTransactionAspect 切面</strong>？因为传播级别为 Propagation.SUPPORTS，不会发起事务。</p></li></ul><h3>2.2.4 配置 Dubbo Proxy</h3><p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// META-INF.dubbo/com.alibaba.dubbo.rpc.ProxyFactory</div><div class="line">tccJdk=org.mengyun.tcctransaction.dubbo.proxy.jdk.TccJdkProxyFactory</div><div class="line"></div><div class="line">// appcontext-service-dubbo.xml</div><div class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">proxy</span>=<span class="string">"tccJdk"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">proxy</span>=<span class="string">"tccJdk"</span> <span class="attr">id</span>=<span class="string">"captialTradeOrderService"</span></span></div><div class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.mengyun.tcctransaction.sample.dubbo.capital.api.CapitalTradeOrderService"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>/&gt;</span></div></pre></td></tr></table></figure></p><ul><li>ProxyFactory 的 <code>tccJdk</code> 在 Maven 项 <code>tcc-transaction-dubbo</code> 已经声明。</li><li>声明 <code>dubbo:provider</code> 的 <code>proxy=&quot;tccJdk&quot;</code>。</li><li>声明 <code>dubbo:reference</code> 的 <code>proxy=&quot;tccJdk&quot;</code>，否则不生效。</li></ul><h1>3. Dubbo 事务上下文编辑器</h1><p><code>org.mengyun.tcctransaction.dubbo.context.DubboTransactionContextEditor</code>，Dubbo 事务上下文编辑器实现，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        String context = RpcContext.getContext().getAttachment(TransactionContextConstants.TRANSACTION_CONTEXT);</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(context)) &#123;</div><div class="line">            <span class="keyword">return</span> JSON.parseObject(context, TransactionContext.class);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        RpcContext.getContext().setAttachment(TransactionContextConstants.TRANSACTION_CONTEXT, JSON.toJSONString(transactionContext));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>通过 Dubbo 的隐式传参的方式，避免在 Dubbo Service 接口上声明 TransactionContext 参数，对接口产生一定的入侵。</li></ul><h1>666. 彩蛋</h1><p>HOHO，对动态代理又学习了一遍，蛮 High 的。</p><p>这里推荐动态代理无关，和 Dubbo 相关的文章：</p><ul><li><a href="http://blog.kazaff.me/2015/01/27/dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%BB%86%E8%8A%82/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo的服务暴露细节》</a>。</li><li><a href="http://weifuwu.io/2016/01/03/dubbo-provider-start/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo Provider启动主流程》</a></li></ul><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/06.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/dubbo-support/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/stro
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
</feed>
